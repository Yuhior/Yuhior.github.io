<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>同步异步详解</title>
    <url>/2018/08/24/Function/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfL6hQ.jpg" alt="心静如水"></p>
<blockquote>
<p>最近从这个月的博客当中，也不难发现最近掉进了同步和异步的坑里，然后就在这里爬啊爬啊的，爬没爬出来不知道，不过现在有了一些见解分享给大家。并且查资料的过程中，发现阮一峰大神在文档中写到：”上个月，我偶然看到了Philip Roberts的演讲《Help, I’m stuck in an event-loop》。这才尴尬地发现，自己的理解是错的。我决定重写这个题目，详细、完整、正确地描述JavaScript引擎的内部运行机制。下面就是我的重写。” ，我猛的发现连这样的大牛都有理解错的时候，何况是我这样的渣渣，所以更应该准确认真理解。</p>
</blockquote>
<p>与这篇相关的文章看我上一篇<a href="https://yuhior.github.io/2018/08/15/callback/#more" target="_blank" rel="noopener">JavaScript回调函数</a></p>
<h3 id="先了解一下为什么有异步"><a href="#先了解一下为什么有异步" class="headerlink" title="先了解一下为什么有异步"></a>先了解一下为什么有异步</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。<br>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<h3 id="同步和异步（回调不一定是异步，异步可通过回调实现，注意区分关系）"><a href="#同步和异步（回调不一定是异步，异步可通过回调实现，注意区分关系）" class="headerlink" title="同步和异步（回调不一定是异步，异步可通过回调实现，注意区分关系）"></a>同步和异步（回调不一定是异步，异步可通过回调实现，注意区分关系）</h3><ol>
<li>纯JavaScript代码并不是异步的（不使用异步API等）像这样</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaaaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bbbbb'</span>);</span><br><span class="line">&#125;</span><br><span class="line">A();</span><br><span class="line">B();</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfqfoD.jpg" alt="Guo Mao Rain"></p>
<ol start="2">
<li>看下边的代码会 先执行函数a,而且不会等到a中的延迟函数执行完才执行函数b, 在延迟函数被触发的过程中就执行了函数b,当js引擎的event 队列空闲时才会去执行队列里等待的setTimeout的回调函数，这就是一个异步的例子。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行a函数"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行a函数的延迟函数"</span>);</span><br><span class="line">  &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行b函数"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufq4Fe.jpg" alt="Guo Mao Rain"></p>
<p>setTimeout 本身就是一个异步操作 ，将回调函数放在一个特殊的”任务队列”中(挂起)，只有”任务队列”通知主线程，某个异步任务可以执行了（这里就是延迟一秒到了，主进程空闲下来才会执行这个回调函数），有些人会觉得你本身就是延迟一秒执行啊！ 那么我们来看看将延迟时间设为0情况会是什么样？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"执行a函数"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行a函数的延迟函数"</span>);</span><br><span class="line">  &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"执行b函数"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfqWdO.jpg" alt="Guo Mao Rain"></p>
<p>举一个别人的栗子 ：在公路上，汽车一辆接一辆，有条不紊的运行。这时，有一辆车坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有应急车道，可以把故障车辆推到应急车道修理，而正常的车流不会受到任何影响。等车修好了，再从应急车道回到正常车道即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱。</p>
<h3 id="我们再来说开始的注意-回调函数不一定-异步操作-异步操作可以通过回调来实现-注意两者的定义"><a href="#我们再来说开始的注意-回调函数不一定-异步操作-异步操作可以通过回调来实现-注意两者的定义" class="headerlink" title="我们再来说开始的注意 回调函数不一定 = 异步操作 异步操作可以通过回调来实现  注意两者的定义"></a>我们再来说开始的注意 回调函数不一定 = 异步操作 异步操作可以通过回调来实现  注意两者的定义</h3><ol>
<li>同步回调</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">arg3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback Totle is:'</span> + arg3)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg1, arg2, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Total = arg1 + arg2;</span><br><span class="line">  callback(Total);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mainFunction Totle is:'</span> + Total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">2</span>, <span class="number">2</span>, callback)</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfqIWd.jpg" alt="Guo Mao Rain"></p>
<ol start="2">
<li>异步回调</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f2 finished'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    setTimeout(cb,<span class="number">1000</span>)        <span class="comment">//用setTimeout()模拟耗时操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f1 finished'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufq5JH.jpg" alt="Guo Mao Rain"></p>
<p>这里我们用setTimeout()来模拟耗时操作的前提是js中的setTimeout()函数支持异步处理，所以我们得到的结果是 f1 finished ，f2 finished</p>
<ol start="3">
<li>再来一个node的异步回调</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'input.txt'</span>,<span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束!"</span>);</span><br></pre></td></tr></table></figure>
<p>按照javascript单线程应该是先执行fs.readFile函数(读取文件)，一直到读完之后  才执行后面的console.log(),然而node中的fs.readFile是支持异步处理的，所以到fs.readFile()不会阻塞，继续向后执行，当读取文件之后在自动调取传入的匿名函数。</p>
<p>说明 ：比如node的 fs.readFile()函数是异步的，我们站在巨人的肩膀上进行开发。你要问他为什么的异步的，那只能你研究下node的这个函数是怎么实现的，setTimeout()也一样。<br>如果有理解不到之处请大牛指出，这样我就能能知道自己哪理解有误了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步和同步</tag>
      </tags>
  </entry>
  <entry>
    <title>实现数据响应式</title>
    <url>/2020/07/18/Proxy/</url>
    <content><![CDATA[<blockquote>
<p>今天是周末，难得的没有加班，没有出去浪，最近感觉很是无聊呀，可能我成了隔夜的杯中水吧，没有落灰，可能中了一种毒，这种毒里边还有一种蔬菜，那就是香菇呀，哈哈哈，猜到了吧，中了好菇毒，闲下来还是研究一下前端的知识吧，毕竟学海无涯，不进则退，再者也应该为了以后打算，毕竟还是要为了以后买各种东西，包括什么车啊房啊，毕竟凡人一个还是需要这些俗物的，哈哈哈，生活不止眼前的苟且，还有诗和远方。今天就看看Vue3到底是怎么实现数据响应的，数据变了然后视图也变了。</p>
</blockquote>
<ol>
<li><h4 id="Proxy数据代理和数据劫持"><a href="#Proxy数据代理和数据劫持" class="headerlink" title="Proxy数据代理和数据劫持"></a>Proxy数据代理和数据劫持</h4><p>Proxy 也就是代理，可以帮助我们完成很多事情，例如对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义。具体参考用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">    name:<span class="string">"xiaohua"</span>,</span></span><br><span class="line">    age:25</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="comment">// 用法 const p = new Proxy(target, handler)  </span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">set</span>(target,prop,newValue)&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(targer,prop,newValue);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments); <span class="comment">// Reflect 就是和Proxy配合 ，set将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="keyword">get</span>(target,prop)&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(target，prop,newValue);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments); <span class="comment">//获取对象身上某个属性的值，类似于 target[name]。</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  p.age = <span class="number">21</span>; <span class="comment">// 改变属性值，调用了Proxy的set方法 console 出的是object(data),age,21(新值)</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(p.name);  <span class="comment">// 调用了get ，console 出来的是21</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="实现数据渲染"><a href="#实现数据渲染" class="headerlink" title="实现数据渲染"></a>实现数据渲染</h4><p>想一下我们使用vue的时候，是不是数据data里边的变量，能使用 双花括号 写上变量的名称就可以渲染到浏览器上了呢，那么来看看到底是怎么实现的呢？那我们上边说的Proxy不可能随便说说的吧，怎么会呢？无事不登三宝殿，来吧用起来吧。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  &#123;&#123;name&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">"myvue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> vue(&#123;   <span class="comment">// 自己写一个小的vue 吧。激动么？</span></span></span><br><span class="line"><span class="javascript">    el:<span class="string">"#app"</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      name:<span class="string">"xiaohua"</span>,</span></span><br><span class="line"><span class="javascript">      message:<span class="string">"带着小明"</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option)&#123; <span class="comment">// 实例中的参数</span></span><br><span class="line">    <span class="keyword">this</span>.option = option;</span><br><span class="line">    <span class="keyword">this</span>._data = <span class="keyword">this</span>.option.data;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.option.el);</span><br><span class="line">    <span class="keyword">this</span>.compileNode(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">  compileNode(el)&#123;  <span class="comment">// 进行渲染的函数来了啊</span></span><br><span class="line">    <span class="keyword">let</span> child = el.childeNodes;</span><br><span class="line">    <span class="built_in">console</span>.log(child);</span><br><span class="line">    childe.forEach(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123;  <span class="comment">// 用[...child]可以保证是数组 </span></span><br><span class="line">      <span class="keyword">if</span>(node.nodeType===<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这是文本的节点"</span>)；</span><br><span class="line">        <span class="keyword">let</span> text = node.textContent; <span class="comment">// 应该是一个&#123;&#123;name&#125;&#125;这样的东西</span></span><br><span class="line">        <span class="comment">//进行匹配</span></span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;\s* ([^\s\&#123;\&#125;]+)  \s*\&#125;\&#125;/</span>;  <span class="comment">// 正则 [ ]表示取反，中间是 两端是&#123;&#123; 但是中间不能再是&#123;了 </span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(text))&#123;</span><br><span class="line">          <span class="keyword">let</span> $<span class="number">1</span> = <span class="built_in">RegExp</span>.$<span class="number">1</span>; <span class="comment">//匹配的第一个元素 也就是name</span></span><br><span class="line">          <span class="comment">//if(this._data[$1]) 写成下边这样</span></span><br><span class="line">          <span class="keyword">this</span>._data[$<span class="number">1</span>]&amp;&amp;(node.textContent=text.repalce(reg,this_data[$<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeType===<span class="number">1</span>)&#123; <span class="comment">// 也就是节点元素 div或者其他</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这是一个节点元素"</span>)；</span><br><span class="line">        <span class="keyword">this</span>.compileNode(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><p>我们渲染完数据了，那肯定想知道v-model这种双向数据绑定的了，不说下去我感觉自己都得好奇死，现在坐下来用小脑袋想一想，v-model 事件，1.要判定node上是不是有v-model属性，2.监听v-model的值的变化去改变data中的数据，3.监听一下(自定义一下这个事件)这个数据变化，再把这个渲染到页面有这个值的元素中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">  &#123;&#123;test&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> vue(&#123;</span></span><br><span class="line"><span class="javascript">    el:<span class="string">'#app'</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">      test:<span class="string">"双绑定数据"</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(vm)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(vm._data.name);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option)&#123; </span><br><span class="line">    <span class="keyword">this</span>.option = option;</span><br><span class="line">    <span class="keyword">this</span>._data = <span class="keyword">this</span>.option.data;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.option.el);</span><br><span class="line">    <span class="keyword">this</span>.compileNode(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">  compileNode(el)&#123;  </span><br><span class="line">    <span class="keyword">let</span> child = el.childeNodes;</span><br><span class="line">    <span class="built_in">console</span>.log(child);</span><br><span class="line">    childe.forEach(<span class="function">(<span class="params">node</span>)=&gt;</span>&#123; </span><br><span class="line">      <span class="keyword">if</span>(node.nodeType===<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> text = node.textContent; </span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;\s* ([^\s\&#123;\&#125;]+)  \s*\&#125;\&#125;/</span>; </span><br><span class="line">        <span class="keyword">if</span>(reg.test(text))&#123;</span><br><span class="line">          <span class="keyword">let</span> $<span class="number">1</span> = <span class="built_in">RegExp</span>.$<span class="number">1</span>; </span><br><span class="line">          <span class="keyword">this</span>._data[$<span class="number">1</span>]&amp;&amp;(node.textContent=text.repalce(reg,this_data[$<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodeType===<span class="number">1</span>)&#123; </span><br><span class="line">        <span class="comment">// 1. 这是一个input 元素在这里完成第一步 </span></span><br><span class="line">        <span class="keyword">let</span> attr = node.attributes; <span class="comment">// 获取所有节点属性对象</span></span><br><span class="line">        <span class="keyword">if</span>(attr.hasOwnProperty(<span class="string">'v-model'</span>)	)&#123;<span class="comment">// 对象中是否含有属性为v-model的</span></span><br><span class="line">          <span class="keyword">let</span> keyName = attr[<span class="string">'v-model'</span>].nodeValue;</span><br><span class="line">          node.value = <span class="keyword">this</span>.data_[keyName];<span class="comment">//先把data中的数据放进input的value里边  属于渲染</span></span><br><span class="line">         	<span class="comment">// 2.监听一下input值的变化，改变data的值</span></span><br><span class="line">          node.addEventListener(<span class="string">'input'</span>,e=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>._data[keyName] = node.value; </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.compileNode(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 怎么监听data数值中的变化呢？那是不想到上边的数据劫持，正戏来了,开始的proxy该用上了，劫持一下数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vue</span> <span class="keyword">extends</span> <span class="title">EventTarget</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option)&#123; </span><br><span class="line">   	<span class="keyword">super</span>();    <span class="comment">//进行继承</span></span><br><span class="line">    <span class="keyword">this</span>.option = option;</span><br><span class="line">    <span class="keyword">this</span>._data = <span class="keyword">this</span>.option.data;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.option.el);</span><br><span class="line">    <span class="keyword">this</span>.compileNode(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">  observe(data)&#123; </span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span> ;</span><br><span class="line">    <span class="keyword">this</span>._data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span><br><span class="line">      <span class="keyword">set</span>(target,propertyKey,newValue)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(propertyKey); <span class="comment">// 对应data的test</span></span><br><span class="line">         <span class="keyword">let</span> event =  <span class="keyword">new</span> CustomEvent(propertyKey,&#123; <span class="comment">// 自定义一个事件，在渲染的时候触发这个函数</span></span><br><span class="line">           detail:newValue</span><br><span class="line">         &#125;);</span><br><span class="line">        _this.dispatchEvent(event); <span class="comment">// 触发事件 注意this的指向 ，然后将这事件绑定到渲染&#123;&#123;&#125;&#125;的值的时侯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查漏补缺一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在学习一下自定义事件 ，要自定义事件必须继承一下自定义事件 EventTarget的方法   </span></span><br><span class="line"><span class="comment">//extends是继承   EventTarget 是将会创建一个新的EventTarget 对象实例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个事件对象，名字为newEvent，类型为build </span></span><br><span class="line"><span class="keyword">var</span> newEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="attr">bubbles</span>:<span class="literal">true</span>,<span class="attr">cancelable</span>:<span class="literal">true</span>,<span class="attr">composed</span>:<span class="literal">true</span> &#125;);</span><br><span class="line">       </span><br><span class="line"><span class="comment">//给这个事件对象创建一个属性并赋值，这里绑定的事件要和我们创建的事件类型相同，不然无法触发 </span></span><br><span class="line">newEvent.name = <span class="string">"新的事件！"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将自定义事件绑定在document对象上 </span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"build"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"你触发了使用CustomEvent创建的自定义事件！"</span> + newEvent.name);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//触发自定义事件 ，也叫做发布吧</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(newEvent);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vue</span> <span class="keyword">extends</span> <span class="title">EventTarget</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(option)&#123;  </span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.option=option;</span><br><span class="line">        <span class="keyword">this</span>._data = <span class="keyword">this</span>.option.data;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="keyword">this</span>.option.el);</span><br><span class="line">        <span class="keyword">this</span>.observe(<span class="keyword">this</span>._data)</span><br><span class="line">        <span class="keyword">this</span>.compileNode(<span class="keyword">this</span>.el);</span><br><span class="line">    &#125;</span><br><span class="line">    observe(data)&#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>._data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data,&#123;</span><br><span class="line">            <span class="keyword">set</span>(target,prop,newValue)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(prop);</span><br><span class="line">                <span class="keyword">let</span> event =  <span class="keyword">new</span> CustomEvent(prop,&#123;</span><br><span class="line">                    detail:newValue</span><br><span class="line">                &#125;);</span><br><span class="line">                _this.dispatchEvent(event);  </span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    compileNode(el)&#123;  </span><br><span class="line">        <span class="keyword">let</span> child =el.childNodes;</span><br><span class="line">        <span class="built_in">console</span>.log(child);</span><br><span class="line">        child.forEach(<span class="function"><span class="params">node</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>) &#123; </span><br><span class="line">                <span class="keyword">let</span> text = node.textContent;</span><br><span class="line">                <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;\s*([^\s\&#123;\&#125;]+)\s*\&#125;\&#125;/</span>;  </span><br><span class="line">                <span class="keyword">if</span> (reg.test(text)) &#123;</span><br><span class="line">                    <span class="keyword">let</span> $<span class="number">1</span> = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">this</span>._data[$<span class="number">1</span>]&amp;&amp;(node.textContent = text.replace(reg,<span class="keyword">this</span>._data[$<span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">this</span>.addEventListener($<span class="number">1</span>,c=&gt;&#123;  <span class="comment">//将上边自定义的函数，绑定到上边</span></span><br><span class="line">                        node.textContent =  text.replace(reg,c.detail);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.nodeType===<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span>  attr  = node.attributes;</span><br><span class="line">                <span class="built_in">console</span>.log(attr);</span><br><span class="line">                <span class="keyword">if</span> (attr.hasOwnProperty(<span class="string">'v-model'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">let</span> keyName = attr[<span class="string">'v-model'</span>].nodeValue;</span><br><span class="line">                    node.value = <span class="keyword">this</span>._data[keyName];</span><br><span class="line">                    node.addEventListener(<span class="string">'input'</span>,e=&gt;&#123;</span><br><span class="line">                        <span class="keyword">this</span>._data[keyName] = node.value;  </span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="built_in">console</span>.log(keyName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.compileNode(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>数据响应式</tag>
        <tag>vue双向数据流</tag>
      </tags>
  </entry>
  <entry>
    <title>说说正则的那些事</title>
    <url>/2020/05/22/RegExp/</url>
    <content><![CDATA[<blockquote>
<p>我胡汉三终于又又又回来了，哈哈哈哈……什么？你说我不着调？不可能的我堂堂Yuhior 怎么可能干不着调的事呢？回顾一下最近的生活和学习，越发觉得每天光用框架啊，什么Vue啊，什么React啊，当然这些我都不会啊，哈哈哈，学习这些感觉力不从心，决心重新学习js，打好自己的基础能力，深知自己这座小平房地基不稳，哪能期盼盖出高楼啊，那最后塌了，不得害死自己啊，所以最近在看书，看红宝书（超级推荐），今天看到正则表达式觉得自己原来哪会什么正则啊，都是临到用了去搜一搜，虽说造轮子和吹飞机有一定区别，但是自己还是应该去深入学习，毕竟自己的才是财富。废话不多说，来看看我对正则的理解，如有不到之处，求大佬们请勿嫌弃我这个小渣渣。开始吧</p>
</blockquote>
<ul>
<li><h3 id="招式一：元字符匹配"><a href="#招式一：元字符匹配" class="headerlink" title="招式一：元字符匹配"></a>招式一：元字符匹配</h3><p>正则表达式也就是匹配的模式，要么是要去匹配想要的字符，要么是匹配位置 ，但是有木有感觉元字符太多记不住？第一我们先知道匹配模式有3个标志 ：</p>
<p>g:表示全局模式，将被应用于所有的字符串。而非发现第一个匹配项时立即停止；</p>
<p>i:表示不区分大小写，即在确定匹配项时忽略模式与字符串的大小写；</p>
<p>m：表示多行模式，即在到达一行的文本末时，继续向下一行进行查找；</p>
<ol>
<li><p>有两种模糊匹配（如果精准匹配，没多大意义，那还不如用直接indexof）</p>
<ul>
<li><p>横向模糊（长度不固定） {2，5}</p>
<p>/ab{2，5}c/  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,5&#125;c/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc abbbbbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex))</span><br><span class="line"><span class="comment">//  ["abbc", "abbbc", "abbbbc", "abbbbbc"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>纵向模糊（配到某个字符不确定是特定的字符）[abc]</p>
<p>/a[123]b/</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex  =  <span class="regexp">/a[bcd]b/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abb acb adb afb agb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line">[<span class="string">"abb"</span>, <span class="string">"acb"</span>, <span class="string">"adb"</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符组 （很想数组把？ 也就是 [ ] 中有一些字符 ）</p>
<ul>
<li><p>范围表示</p>
<p>[abc]很短还好说，但是要很长怎么办？不能一个个写把? 那范围表示法就来了</p>
<p>[123456abcdefgHIJKLMN]    =&gt; [1-6a-gH-N]    用 连字符 -来省略和简写</p>
<p>但是要匹配 “a” “-“  “z” 任意一个字符怎么办？  可以写成[-az]或者[az-]或者[a-z]</p>
</li>
<li><p>排除字符组</p>
<p>有一种情况就是纵向模糊匹配，某位字符可以是任何东西，但是就是不能是某个字符，也就是求反</p>
<p>[^abc]</p>
<p>当然后边的也有相应的范围表示表示法  [ ^abcdefghijkl]  =&gt;[ ^a-l]</p>
</li>
<li><p>常见的简写形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\d =&gt;[<span class="number">0</span><span class="number">-9</span>]  表示一位数字  也就是digit</span><br><span class="line">\D =&gt;[^<span class="number">0</span><span class="number">-9</span>] 表示除数字外的任意字符</span><br><span class="line">\w =&gt;[<span class="number">0</span><span class="number">-9</span>a-zA-Z]  表示数字、大小写字母和下划线。word </span><br><span class="line">\W =&gt;[^<span class="number">0</span><span class="number">-9</span>a-zA-Z]  表示非单词字符</span><br><span class="line">\s =&gt;[\t\v\n\r\f] 表示空白符  记忆也就是 space</span><br><span class="line">\S =&gt;[^\t\v\n\r\f]  非空白符</span><br><span class="line">. 通配符  除换行符、回车符、行分隔符、段分隔符除外的所有</span><br><span class="line">匹配任意字符 [^]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>量词 {2，5}</p>
<ul>
<li><p>简写形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;m,&#125; =&gt; 至少出现m次</span><br><span class="line">&#123;m&#125; =&gt; 表示出现m次</span><br><span class="line">? =&gt;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,表示出现或者不出现 。记忆： 有么？</span><br><span class="line">+ =&gt;&#123;<span class="number">1</span>,&#125; 表示出现至少一次 。 记忆：加号是追加的意思，得先有一个，然后才考虑从追加</span><br><span class="line">* =&gt;&#123;<span class="number">0</span>,&#125; 表示出现任意次，有可能不出现，记忆：看天上星星，黑天啊没有，可能是零星几颗，也可能是数不过来</span><br></pre></td></tr></table></figure>
</li>
<li><p>贪婪匹配和惰性匹配</p>
<p>贪婪匹配：他会尽可能多的匹配，反正在能力范围之内，越多越好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;   <span class="comment">// 表示数字连续出现2-5次</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">//["123", "1234", "12345", "12345"]</span></span><br></pre></td></tr></table></figure>
<p>惰性匹配：很懒啊 像我一样，能匹配到俩个就绝不多匹配，量词后面加个问号就能实现惰性匹配，记忆方法：问一问你知足了吗，你很贪婪吗？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;?/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">//["12", "12", "34", "12", "34", "12", "34", "56"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>多选分支 （或者也可以叫 “或”  ）</p>
<p>多选模式：展现形式（p1 | p2 | p3 ),其中得p1,p2,p3都是子模式，表示其中任何之一都可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|nice/g</span>;</span><br><span class="line"><span class="keyword">var</span> string =<span class="string">"good idea, nice try."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">//  ["good", "nice"]</span></span><br></pre></td></tr></table></figure>
<p>*<em>注意 当我们用 /good|goodbye/ ，去匹配“goodbye”时，结果只是good</em>，说明分支结构是惰性得，也就是前边的上了，后边就不会再去尝试了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// ["good"]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/goodbye|good/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// ["goodbye"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="招式二：位置匹配攻略"><a href="#招式二：位置匹配攻略" class="headerlink" title="招式二：位置匹配攻略"></a>招式二：位置匹配攻略</h3><p>正则表达式也就是匹配的模式，要么是要去匹配想要的字符，要么是匹配位置，下面我们就来讲一讲位置匹配吧</p>
<ol>
<li><p>什么是位置</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufff3T.jpg" alt="位置"></p>
<p>也就是两个相邻字符之间的位置，比如图中箭头中的位置</p>
</li>
<li><p>如何匹配位置</p>
<p>目前有6个锚字符</p>
<p>^   $  \b  \B  (?=p)  (?!p)</p>
<ul>
<li><p>^ 脱字符 匹配开头的位置，在多行匹配中匹配行开头 (单行匹配)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^/g</span>;</span><br><span class="line"><span class="keyword">var</span> string =<span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">// #hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>$ 美元符号 匹配结尾，在多行匹配中匹配行尾 (单行匹配)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/$/g</span>;</span><br><span class="line"><span class="keyword">var</span> string =<span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">// hello#</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>\b  是单词边界，具体就是\w 和\W 之间的位置，也包括\w 和^之间的位置，也包括\w和$之间的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"[JS]Lesson_01.mp4"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">// [#JS#]#Lesson_01#.#mp4#</span></span><br></pre></td></tr></table></figure>
<p>稍微的解释一波，强调不是狡辩😂😂😂，第一个#是在”[“和”J”之间的位置，第二个也就是”S”和”]”之间  ….</p>
</li>
<li><p>\B  也就是\b的反义 ，那么这么讲也就好理解了 ，也就是\B是反义非单词边界。例如在字符串中所有的位置中，扣掉\b，剩下的都是\b的。 具体：/w与/w、\W与\W 、\W与$之间的位置，来个例子吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\B/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"[JS]Lesson_01.mp4"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">// #[J#S]L#e#s#s#o#n#_#0#1.m#p#4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(?=p) 其中p就是那个上边的子模式(或模式也就是随便一个)，即 p前边的位置。比如（?= t ),表示””字符前边的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?=l)/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"[JS]Lesson_01.mp4"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">//he#l#lo</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(?!p) 也就是（?=p)的反面意思</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?!p)/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">"#"</span>));</span><br><span class="line"><span class="comment">//#h#e#l#l#o#</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>位置的特性</p>
<p>对于位置的理解，我们理解成空字符串。</p>
<p>比如”hello” 字符串等价于如下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="string">"hello"</span> == <span class="string">""</span> + <span class="string">"h"</span> + <span class="string">""</span> + <span class="string">"e"</span> + <span class="string">""</span> + <span class="string">"l"</span> + <span class="string">""</span> + <span class="string">"l"</span> + <span class="string">""</span> + <span class="string">"o"</span> + <span class="string">""</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>还等价于 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="string">"hello"</span> == <span class="string">""</span> + <span class="string">""</span> + <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以把 /^hello$/ 写成/^^hello$$$/,是没有问题的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^^hello$$$/</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(result));</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>应用分析</p>
<ul>
<li><p>写一个不匹配任何东西的正则</p>
<p>/.^/  : 要求只有一个字符（.代表任意字符），但该字符后边是开头</p>
</li>
<li><p>数字的千位分隔符表示法</p>
</li>
</ul>
<p>先在最后弄一个逗号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg =  <span class="regexp">/(?=\d&#123;3&#125;$)/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">","</span>));</span><br><span class="line"><span class="comment">// 12345,678</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>最后弄出所有逗号，也就是后边的3个数字一组，也就是\d{3}至少出现一次。

 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?=(\d&#123;3&#125;)+$)/g</span>; <span class="comment">//使用量词 +</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"12345678"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">","</span>));</span><br><span class="line"><span class="comment">//12,345,678</span></span><br></pre></td></tr></table></figure>
</code></pre><p>  但是一旦遇到3的倍数位，那就有问题啦首位肯定也会加一个逗号啦，那就不要匹配开头啦 。那就来一个（?!^）;</p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+$)/g</span>; <span class="comment">//使用量词 +</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result.replace(reg,<span class="string">","</span>));</span><br><span class="line"><span class="comment">//123,456,789</span></span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><h3 id="招式三见下一篇吧"><a href="#招式三见下一篇吧" class="headerlink" title="招式三见下一篇吧"></a>招式三见下一篇吧</h3></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>异步发展之进化历程</title>
    <url>/2018/09/25/async/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/Uhpvkt.jpg" alt=" 秋天麦子 "></p>
<blockquote>
<p>昨天是中秋节，前段之间一直在研究这个异步操作，从之前的文章中也可以看出来，但这段时间公司比较忙，基本每天加班，所以拖到今天才更新自己的博客，记录之前学习的东西。仅供参考，如有版权问题，请联系我。</p>
</blockquote>
<ol>
<li><h3 id="旧时代之事件回调"><a href="#旧时代之事件回调" class="headerlink" title="旧时代之事件回调"></a>旧时代之事件回调</h3></li>
</ol>
<ul>
<li>readFile()会在文件 I/O 返回结果之后触发回调函数，通过这种嵌套的方式，我们能够保证文件是按序读取的，这种方式在JS中十分常见，比如定时器setInterval()、setTimeout()。回调实现的异步代码易于理解，但问题也很明显，层层嵌套使得代码逐层缩进，严重降低了可读性，我们把这种现象称为回调金字塔。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./package.json'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    data =<span class="built_in">JSON</span>.parse(data);</span><br><span class="line">    <span class="built_in">console</span>.log(data.name);</span><br><span class="line">    fs.readFile(<span class="string">'./package1.json'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data1</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        data1 = <span class="built_in">JSON</span>.parse(data1);</span><br><span class="line">        <span class="built_in">console</span>.log(data1.name);</span><br><span class="line">        fs.readFile(<span class="string">'./package2.json'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data2</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;)<span class="keyword">else</span>&#123;</span><br><span class="line">          data2 = <span class="built_in">JSON</span>.parse(data2);</span><br><span class="line">          <span class="built_in">console</span>.log(data2.name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// node cb-promise.js</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><h3 id="Promise-承诺异步"><a href="#Promise-承诺异步" class="headerlink" title="Promise 承诺异步"></a>Promise 承诺异步</h3></li>
</ol>
<ul>
<li>ES6出现之前，饱受回调地狱煎熬，这在我学习nodeJs中express框架中已经见识到了，使用ES6中的Promise对象实现异步，就彻底告别了“回调地狱”，Promise本质依然是事件回调，是基于事件机制实现。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileAsync</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    fs.readFile(path,(err,data)=&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) reject(err)</span><br><span class="line">      <span class="keyword">else</span> resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readFileAsync(<span class="string">'./package.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">    <span class="built_in">console</span>.log(data.name);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>node8.0+版本以上独立封装Promise</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); <span class="comment">//封装了一个返回Promise对象的方法</span></span><br><span class="line">util.promisify(fs.readFile)(<span class="string">'./package.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">    <span class="built_in">console</span>.log(data.name);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>高版本Ajax</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  $.ajax(&#123;<span class="attr">url</span>:<span class="string">'data/arr.txt'</span>,<span class="attr">dataType</span>:<span class="string">'json'</span>&#125;), <span class="comment">//高版本ajax返回的是Promise对象</span></span><br><span class="line">  $.ajax(&#123;<span class="attr">url</span>:<span class="string">'data/json.txt'</span>,<span class="attr">dataType</span>:<span class="string">'json'</span>&#125;)</span><br><span class="line">]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [arr,json] = results;</span><br><span class="line">  alert(<span class="string">'全部成功了'</span>);</span><br><span class="line">  alert(arr);</span><br><span class="line">  <span class="built_in">console</span>.log(json);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'失败了'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><h3 id="Generator-构造新方式"><a href="#Generator-构造新方式" class="headerlink" title="Generator 构造新方式"></a>Generator 构造新方式</h3></li>
</ol>
<ul>
<li><p>Generator函数也是ES6标准引入的新的特新，按照阮一峰老师的说法<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">《Generator 函数的语法》</a>,Generator函数是一个状态机，封装了多个内部状态，它提供了一种机制，通过yield关键字和next()方法来交付和归还线程的执行权，实现代码异步。</p>
<blockquote>
<p>说到Generator函数 就不得不说Iterator迭代器，手写一个简易的迭代器</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(nextIndex&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>:arr[nextIndex++] , <span class="attr">done</span>:<span class="literal">false</span> ,<span class="attr">index</span>:nextIndex&#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123; <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = makeIterator([<span class="string">'吃饭'</span>,<span class="string">'睡觉'</span>,<span class="string">'打豆豆'</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"首先"</span>+it.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"其次"</span>+it.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"然后"</span>+it.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"最后"</span>+it.next().value);<span class="comment">//console.log("最后"+it.next().done)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UhpXTI.jpg" alt=" 秋天麦子 "></p>
<ul>
<li><p>Generator函数执行到yield关键字会自动暂停，报出当前状态，返回一个遍历器(Iterator)对象，完成执行权交付。执行下一步通过调用该遍历器的next()方法，回归现场，驱动 Generator 函数从断点处继续执行，完成执行权归还。<br>生成器函数顾名思义，它是一个生成器，它也是一个状态机，内部拥有值及相关的状态，生成器返回一个迭代器Iterator对象，我们可以通过这个迭代器，手动地遍历相关的值、状态，保证正确的执行顺序。</p>
<blockquote>
<p>生成器函数长什么样呢？</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">makeIterator</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arr[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = makeIterator([<span class="string">'吃饭'</span>,<span class="string">'睡觉'</span>,<span class="string">'打豆豆'</span>]);</span><br><span class="line"><span class="built_in">console</span>.dir(gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"其次："</span>+gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"然后："</span>+gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"最后："</span>+gen.next().done);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UhpLmd.jpg" alt=" 秋天麦子 "></p>
<ul>
<li><p>我们不难理解Generator函数了，我们再来看看怎么使用Generator函数解决我们的异步回调呢？</p>
<blockquote>
<p>还是我们开头的fs函数,Generator + Promise +自己封装的run 方法</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个读取文件的函数</span></span><br><span class="line"><span class="keyword">const</span> read = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(path,<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(<span class="string">'fail'</span>);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dataA = <span class="keyword">yield</span> read(<span class="string">'package.json'</span>);  <span class="comment">// yield 在暂停时刻并没有赋值，dataA 的值是在重新执行时刻由 next 方法的参数传入的</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'package is :'</span>,<span class="built_in">JSON</span>.parse(dataA).name );</span><br><span class="line">        <span class="keyword">let</span> dataB = <span class="keyword">yield</span> read(<span class="string">'package1.json'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'package1 is :'</span>, <span class="built_in">JSON</span>.parse(dataB).name);</span><br><span class="line">        <span class="keyword">let</span> dataC = <span class="keyword">yield</span> read(<span class="string">'package2.json'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'package2 is :'</span>, <span class="built_in">JSON</span>.parse(dataC).name);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动 Generator 执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> it = generator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否遍历完成，标志位 result.done 为 true 表示遍历完成</span></span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">        <span class="comment">// result.value 即为返回的 promise 对象</span></span><br><span class="line">        <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UhpO0A.jpg" alt=" 秋天麦子 "></p>
<ul>
<li><p>co来啦 ！！解决Run函数自行封装的不统一</p>
<blockquote>
<p>co使用</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> util.promisify(fs.readFile)(<span class="string">'./package.json'</span>);</span><br><span class="line">  data = <span class="built_in">JSON</span>.parse(res);</span><br><span class="line">  <span class="built_in">console</span>.log(data.name);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>co 函数库是著名程序员 TJ 大神 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。</p>
<blockquote>
<p>对比上边的栗子,下边的是不是更像同步代码</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readAsync = util.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataA = <span class="keyword">yield</span> readAsync(<span class="string">'package.json'</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package is :'</span>,<span class="built_in">JSON</span>.parse(dataA).name );</span><br><span class="line">    <span class="keyword">let</span>  dataB = <span class="keyword">yield</span> readAsync(<span class="string">'package1.json'</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package1 is :'</span>,<span class="built_in">JSON</span>.parse(dataB).name );</span><br><span class="line">    <span class="keyword">let</span> dataC = <span class="keyword">yield</span> readAsync(<span class="string">'package2.json'</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package2 is :'</span>,<span class="built_in">JSON</span>.parse(dataC).name );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><h3 id="sAsync-Await-一统世界"><a href="#sAsync-Await-一统世界" class="headerlink" title="sAsync/Await 一统世界"></a>sAsync/Await 一统世界</h3></li>
</ol>
<ul>
<li>永远都有更厉害的方法，只有你做不到，没有javascript想不到，ES7推出Async/Await， 语法本质上只是 Generator 函数的语法糖，像 co 一样，它内置了 Generator 函数的自动执行器，并且支持更简洁更清晰的异步写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装成 await 语句期望的 promise 对象 ,或者使用util</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        fs.readFile(...args, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// await 会吸收 resolve 传入的值作为返回值赋给变量</span></span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataA = <span class="keyword">await</span> readFile(<span class="string">'package.json'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package is :'</span>,<span class="built_in">JSON</span>.parse(dataA).name );</span><br><span class="line">    <span class="keyword">let</span> dataB = <span class="keyword">await</span> readFile(<span class="string">'package.json'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package1 is :'</span>,<span class="built_in">JSON</span>.parse(dataB).name );</span><br><span class="line">    <span class="keyword">let</span> dataC = <span class="keyword">await</span> readFile(<span class="string">'package.json'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'package2 is :'</span>,<span class="built_in">JSON</span>.parse(dataC).name );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>
<p><strong>总之记住一点：我们是以同步代码的编写方式来执行异步函数，只是解决方案越来越优雅</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Async</tag>
        <tag>generator</tag>
        <tag>co</tag>
      </tags>
  </entry>
  <entry>
    <title>说说正则那些事2</title>
    <url>/2020/06/01/RegExp2/</url>
    <content><![CDATA[<blockquote>
<p>今天是六一儿童节啊，首先先祝福一下六一的小朋友们，节日快乐哦，不包含那些很大了还装小朋友的人儿哦，哈哈哈，开玩笑啦，心态年轻你们永远年轻啊，节日快乐节日快乐。(要不是怕挨打谁祝你们啊，切我堂堂…,真的很怂的啊)，给大佬们递茶，大佬们永远年轻啊。言归正传，上篇我们讲述了正则表达式招式一招式二，那么今天我们就继续把招式三四都看了吧，说招式其实感觉有点不好，因为大圣老师说过高手过招拼的都是内功，算了毕竟咱是菜鸟。</p>
</blockquote>
<ul>
<li><h3 id="招式三：正则表达式括号的作用"><a href="#招式三：正则表达式括号的作用" class="headerlink" title="招式三：正则表达式括号的作用"></a>招式三：正则表达式括号的作用</h3><ol>
<li><p>分组和分支结构</p>
<ul>
<li><p>分组：比如我们要匹配连续的一个字符可以用/a+/，进行匹配，而要匹配连续出现的ab时那我们就要使用括号了，就需要使用/(ab)+/,其中括号这个时候就是作用于ab整个整体的</p>
</li>
<li><p>分支结构：前边我们也见过了分支结构中就用了括号（P1|P2）中，此处的括号的作用也是不言而喻的，提供了子表达式的所有可能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (javascript|Regular Expression)$/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">"I love javascript"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">"I love Regular Expression"</span>));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>捕获分组</p>
<ul>
<li><p>括号的另一个作用也就是进行数据提取啊，为了更好的进行替换操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="comment">// 可以修改成括号版的：</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure>
<p>为什么用括号呢？那就来说说这么的好处的吧？，看下边的代码块返回的是一个数组，第一个元素就是返回整体匹配到的结果，然后就是各个分组（括号）匹配的内容，然后就是下标，最后是输出的文本，然后这样就可以很方便的提取数据了，并且使用构造函数的全局属性$1-$9来获取console.log(RegExp.$1); // “2020”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2020-06-01"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">//["2020-06-01", "2020", "06", "01", index: 0, input: "2020-06-01", groups: undefined]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>毋庸置疑获取到了肯定就是替换了啊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"2020-06-01"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string.replace(regex,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">2</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">3</span> + <span class="string">"/"</span> + <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// 06/01/2020</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>反向引用</p>
<ul>
<li><p>大家肯定很疑惑什么是反向引用，咱们获取了这个正则匹配到的然后进行替换，这叫引用，然后我们获取到了这个匹配的东西，然后再拿过来在进行匹配这就叫反向引用，也是是获取捕获的内容然后引用。这样不好理解，咱还是直接上菜吧，翠花来上酸菜吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要写个正则，需要匹配2020-06-01 2020/06/01 和2020.06.01,怎么进行写</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"2020-06-01"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"2020/06/01"</span>;</span><br><span class="line"><span class="keyword">var</span> string3 = <span class="string">"2020.06.01"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string3));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//==========停 这是一条正经的分割线 ，你有没有想过 "2020-06/01"这种形式也会匹配到呢？</span></span><br><span class="line"><span class="keyword">var</span> string4 = <span class="string">"2020-06/01"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string4));</span><br><span class="line"><span class="comment">//true  是的也会匹配到</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>那怎么办？这个时候你肯定会在想要是前边匹配到啥后边也就匹配到啥就好了，可以！js这么强大怎么不会想你所想，反向引用来了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">"2020-06-01"</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">"2020/06/01"</span>;</span><br><span class="line"><span class="keyword">var</span> string3 = <span class="string">"2020.06.01"</span>;</span><br><span class="line"><span class="keyword">var</span> string4 = <span class="string">"2020-06/01"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string1));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string2));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string3));</span><br><span class="line"><span class="built_in">console</span>.log(regex.test(string4));</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false  这不就已经实现了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>括号嵌套怎么办？？？？  记住一个括号一个组，$1就是最外边的，$2下一层，$3再下一层(开始我也懵逼树下懵逼果了啊)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^((\d)(\d(\d)))\1\2\3\4$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"1231231233"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);  <span class="comment">//123  第一层</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>); <span class="comment">//1  // 第一个（/d）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">3</span>)  <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">4</span>)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>\10 表示什么呢？  第十个分组？还是\1 和 0 呢？，显然是前者。</p>
</li>
</ul>
</li>
<li><p>非捕获分组</p>
<p>之前出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此称他们为捕获型分组。</p>
<p>如果只想要括号的最原始的特性，但不会进行引用不另作存储进行使用，那么可以使用非捕获型分组(?:p),再来看看一个栗子，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(?:ab)+/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"ababa abbb ababab"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">// ["abab", "ab", "ababab"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>来几个栗子尝尝</p>
<ul>
<li><p>模拟字符串trim方法，去掉字符串的开头和结尾的空白符,两种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(trim(<span class="string">" foobar "</span>));</span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/^\s*(.*?)\s*$/g</span>,<span class="string">"$1"</span>);   </span><br><span class="line">  <span class="comment">// 点 是任意字符,* 是取 0 至 无限长度,?是非贪婪模式</span></span><br><span class="line">  <span class="comment">// \s 代表空白符</span></span><br><span class="line">  <span class="comment">//.*?a 就是取前面任意长度的字符内，到底一个 a 出现，匹配如下容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(trim(<span class="string">" foobar "</span>));</span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将每个单词的字母大写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleize</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toLoewCase().replace(<span class="regexp">/?:^|\s\w/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.toUpperCase();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>驼峰化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/[-_\s]+(.)?/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">match,c</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> c ? c.toUpperCase() :<span class="string">""</span>;          </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(camelize(<span class="string">"-moz-transform"</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="招式四：正则表达式回溯法原理"><a href="#招式四：正则表达式回溯法原理" class="headerlink" title="招式四：正则表达式回溯法原理"></a>招式四：正则表达式回溯法原理</h3><blockquote>
<p>一看回溯这个词就肯定觉着比较高大上，本身这个程序员就是爱装13哈哈哈，确实这个词出现次数很多，那么大家理解不理解呢？</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>没有回溯的匹配</p>
<p>假设我们的正则是/ab{1,3}c/,其可视化形式是：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfWDT1.jpg" alt></p>
<p>而当目标字符串是”abbbc”时，就没有所谓的”回溯”。其匹配过程是：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfWyY6.jpg" alt></p>
<p>其中子表达式b{1,3}表示”b”字符连续出现1到3次。</p>
</li>
<li><p>有回溯的匹配</p>
<p>如果目标字符串是”abbc”,中间就有回溯</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfWsFx.jpg" alt></p>
<p>图中的第五步出现了红颜色的区域，表示匹配不成功，此时已经匹配到了2个字符的”b”,准备尝试去匹配第三个时，结果发现第三个不是要匹配的”b”,是”c”,那么也就说明b{1,3}已经匹配完毕，状态就应该回到原来之前的匹配到2个”b”字符的状态，也就是回到第四步的状态，然后再去匹配c这个时候就匹配成功了。上边的第六步也就是回溯。</p>
<p>再去举个栗子，这一天天的举这玩意真难啊</p>
<p>字符串是”abbbc”,匹配过程就是</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfW6fK.jpg" alt></p>
<p>其中的第七步和第十步就是回溯，第七步和第四步一样，此时都是b{1,3}匹配了两个b，而第十步与第三步一样，此时b{1,3}只匹配了一个”b”,这也是b{1,3}的最终匹配结果。</p>
</li>
<li><p>常见的回溯形式</p>
<p>回溯法简单来说就是：正因为有很多的可能，所以需要一个个进行尝试，直到到某一步时，整体匹配成功了，要么到最后都试完了发现后，发现整体匹配不成功，总之，万变不离一个字：试！试就完了，通俗的说就是我们常常说的笨方法，掰手指头哈哈哈哈，那么我门下边来看看正则表达式中，哪些地方会产生回溯呢？</p>
<ul>
<li><p>贪婪量词</p>
<p>{1,3}这种就是贪婪量词的典范，因为贪啊，不管多少都一直吃一直吃，尝试着按照顺序往下吃，只要有可能就一直尝试尝试，实在吃不下再吐出来，咦好恶心啊哈哈哈哈，所以贼贪婪，但是能吃下就吃。这就是贪婪量词，但是这个时候有一个特殊的地方，当多个贪婪量词在一起并且有冲突的时候怎么办？？那就符合社会法则了啊，先下手为强，后下手那就吃不到呗！机会总是留给有准备的人滴。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">// ["12345", "123", "45", index: 0, input: "12345", groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>其中前边的/d{1,3}匹配到的是”123”,后边的/d{1,3}匹配到的事”45”.</p>
</li>
<li><p>惰性量词</p>
<p>咱们前边也说过，惰性量词就是在贪婪量词之后加个问号？，表示尽可能少的匹配，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;1,3&#125;?)(\d&#123;1,3&#125;)/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">// ["1234", "1", "234", index: 0, input: "12345", groups: undefined]</span></span><br></pre></td></tr></table></figure>
<p>其中\d{1,3}?只匹配到一个字符”1”，而后边的\d{1,3}匹配到了”234”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;1,3&#125;?)(\d&#123;1,3&#125;)$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br></pre></td></tr></table></figure>
<p>虽然惰性量词不贪，但是也会有回溯现象。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfW0m9.jpg" alt></p>
<p>目标字符串”12345”,匹配过程是：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfW2lD.jpg" alt></p>
<p>虽然不贪，但是为了整体进行能够匹配成功，只能给你多塞一点了，因此最后\d{1,3}?匹配的字符是”12”,是两个数字，而不是一个。</p>
</li>
<li><p>分支结构</p>
<p>我们知道分支也是惰性的，比如<code>/can|candy/</code>，去匹配字符串”candy”，得到的结果是”can”，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。</p>
<p>分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfWgSO.jpg" alt></p>
<p>目标字符串是”candy”，匹配过程：</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfWR6e.jpg" alt></p>
<p>上面第5步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的</p>
</li>
</ul>
</li>
<li><p>小结</p>
<p>简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。</p>
<ol>
<li>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。</li>
<li>惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。</li>
<li>分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。</li>
</ol>
</li>
</ul>
<ul>
<li><h3 id="招式五：未完待续。。。"><a href="#招式五：未完待续。。。" class="headerlink" title="招式五：未完待续。。。"></a>招式五：未完待续。。。</h3></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + mongodb 的后台权限分配</title>
    <url>/2020/11/09/authority/</url>
    <content><![CDATA[<blockquote>
<p>人嘛总会有很多借口去拖延一件事，我发现这种人真的是无敌的用那个词怎么讲？哦对就是神烦。你看看我一天天的距离上次更新博客很长时间了吧？一直在忙忙周一到周五不是在上班就是在上班路上哈哈哈，反正就是没有一天在闲着，然后就是嘛…..,hahhahh 就拖着 就那么硬拖，我不是也没找理由 哈哈哈哈，貌似上边已经找了，反正吧，爱咋咋吧你能把我咋着吧！不好意思，先容我跪好哈哈哈。还好我足智多谋，看了个电视剧写了个观后感，灵机一动直接更新到博客，不能只看技术不看精神世界是吧？嗯！可以的！理由都衔接的这么完美。话说最近记忆力不太好，睡不着觉的时候，我想数数羊吧，数着数着，突然一个小羊瞥了我一眼并且非常不屑的说：“你已经数过我一次了”，我天我真的是居然被一只羊嘲笑了。哎人生啊，真的是 “卧槽，无情！”。好了最近没有更新多说了一点还是言归正传吧，上回书说到使用mongodb + vue完成登陆，这次我们要来搞一下后台的页面权限控制。来吧展示。</p>
</blockquote>
<ul>
<li><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><ul>
<li><p>公共页面不需要用户登陆的路由肯定有一个静态路由表  constantRouterMap</p>
</li>
<li><p>在前端肯定有一个带权限路由表 asyncRouterMap</p>
</li>
<li><p>后端有一整套的动态路由表存储</p>
</li>
<li><p>登陆时获取到用户的用户角色</p>
</li>
<li><p>使用Vue Router 路由守卫进行是否有权限进入的或者说存在权限菜单项的判断</p>
</li>
<li><p>发送用户角色到后台，返回可访问的路由相关信息，和前端存储的路由表进行匹配</p>
</li>
<li><p>使用router.addRoutes 方法进行动态路由的添加</p>
</li>
<li><p>思路图 </p>
<p><img src="https://s1.ax1x.com/2020/11/09/B7WWSe.png" alt></p>
</li>
</ul>
</li>
<li><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><ul>
<li><h5 id="Vue前端逻辑源码"><a href="#Vue前端逻辑源码" class="headerlink" title="Vue前端逻辑源码"></a>Vue前端逻辑源码</h5><ol>
<li><p>路由守卫，守的就是底线</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动跳转的页面白名单</span></span><br><span class="line">  <span class="keyword">const</span> whiteList = [</span><br><span class="line">    <span class="string">'/'</span>,</span><br><span class="line">    <span class="string">'/home'</span>,</span><br><span class="line">    <span class="string">'404'</span></span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> constantRouterMap = [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">"/home"</span>,</span><br><span class="line">      name: <span class="string">"Home"</span>,</span><br><span class="line">      component: Home,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">"/login"</span>,</span><br><span class="line">      name: <span class="string">"Login"</span>,</span><br><span class="line">      component: Login,</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">"history"</span>,</span><br><span class="line">    base: process.env.BASE_URL,</span><br><span class="line">    routes:constantRouterMap</span><br><span class="line">  &#125;);</span><br><span class="line">  router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (Cookie.getCookie(<span class="string">'username'</span>)) &#123; <span class="comment">// 验证是否已经登陆过了</span></span><br><span class="line">      <span class="keyword">if</span> (to.path!==<span class="string">'/login'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (store.state.menuList.length!==<span class="number">0</span>) &#123;</span><br><span class="line">          next();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          store.dispatch(<span class="string">'getPermission'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            store.dispatch(<span class="string">'getPermissionList'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="comment">// .....进行路由合并</span></span><br><span class="line">              &#123;  <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line">                path: <span class="string">"/404"</span>,</span><br><span class="line">                name: <span class="string">"notFound"</span>,</span><br><span class="line">                component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/layout/404.vue'</span>)</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                path: <span class="string">"*"</span>, <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line">                redirect: <span class="string">"/404"</span> <span class="comment">//无匹配到的路径自动重定向到404页面</span></span><br><span class="line">              &#125;</span><br><span class="line">              ]</span><br><span class="line">              router.addRoutes(accessRoutes) <span class="comment">// 动态添加可访问路由表</span></span><br><span class="line">              next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            router.replace(<span class="string">'/login'</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">'已经登陆过了'</span>);</span><br><span class="line">        <span class="comment">// 跳转默认的页面</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (whiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 免登陆白名单 直接进入</span></span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (to.path !== <span class="string">'/login'</span>) &#123;</span><br><span class="line">          <span class="comment">// 重定向到登录页面 不能这么写 因为假如之前的角色是 管理员页面 后又登陆了非管理员 重定向的页面就可能不存在,就会导致404</span></span><br><span class="line">          next(<span class="string">`/home?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">          <span class="comment">//next('/login');</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          next();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vuex</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把后台返回的的路由和前端路由表中的路由进行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>routes </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>roles </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">recursionRouter</span>(<span class="params">userRouter, allRouter </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> realRoutes = []</span><br><span class="line">    allRouter.forEach(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        userRouter.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.name === v.name) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.children &amp;&amp; item.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    v.children = recursionRouter(item.children, v.children)</span><br><span class="line">                &#125;</span><br><span class="line">                realRoutes.push(v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> realRoutes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'USER_TOKEN'</span>)) || <span class="string">''</span> <span class="comment">// 用户信息</span></span><br><span class="line">  <span class="keyword">const</span> userRoles = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'USER_ROLE'</span>))|| <span class="string">''</span> <span class="comment">// 用户角色</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      token,</span><br><span class="line">      userRoles,</span><br><span class="line">      menuList:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    strict:<span class="literal">true</span>, <span class="comment">// 使用严格模式</span></span><br><span class="line">    mutations: &#123;</span><br><span class="line">      setUserToken(state,token)&#123;</span><br><span class="line">        <span class="comment">//alert(token);</span></span><br><span class="line">        state.token= token;</span><br><span class="line">      &#125;,</span><br><span class="line">      SaveLoginInfo(state,userRoles)&#123;</span><br><span class="line">        state.userRoles = userRoles</span><br><span class="line">      &#125;,</span><br><span class="line">      setPermissList(state,data)&#123;</span><br><span class="line">        state.menuList  = data;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      getPermission(&#123;commit,state&#125;)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          api.GetPermission(&#123;</span><br><span class="line">            userRole:state.userRoles</span><br><span class="line">          &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            commit(<span class="string">'setPermissList'</span>,res.permission);</span><br><span class="line">            resolve(res.permission);</span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">           reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      getPermissionList(&#123; state &#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> permissionList = []</span><br><span class="line">          permissionList = recursionRouter(state.menuList, asyncRouterMap);</span><br><span class="line">          resolve(permissionList)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;&#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据路由生成的菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;el-aside width=&quot;201px&quot;  height=&quot;100vh&quot;</span><br><span class="line">        class=&quot;app-side app-side-left&quot;</span><br><span class="line">        :class=&quot;isCollapse ? &apos;app-side-collapsed&apos; : &apos;app-side-expanded&apos;&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div class=&quot;app-side-logo&quot;&gt;</span><br><span class="line">          &lt;img</span><br><span class="line">            src=&quot;@/assets/logo.png&quot;</span><br><span class="line">            :width=&quot;isCollapse ? &apos;60&apos; : &apos;60&apos;&quot;</span><br><span class="line">            height=&quot;60&quot;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;!-- 我是样例菜单 --&gt;</span><br><span class="line">          &lt;el-menu style=&quot;height:calc(100vh - 62px);overflow-y:auto; min-width:201px&quot;</span><br><span class="line">            :default-openeds= &quot;[&apos;0&apos;,&apos;1&apos;]&quot;</span><br><span class="line">            class=&quot;el-menu-vertical-demo&quot;</span><br><span class="line">            :router=&quot;true&quot;</span><br><span class="line">            :default-active=&quot;this.$route.path&quot;</span><br><span class="line">            @open=&quot;handleOpen&quot;</span><br><span class="line">            @close=&quot;handleClose&quot;</span><br><span class="line">          &gt;</span><br><span class="line">            &lt;el-submenu  v-for=&quot;(item,index) in activeMenuList&quot; :key=&quot;index&quot; :index=&quot;index+&apos;&apos;&quot;&gt;</span><br><span class="line">                &lt;template slot=&quot;title&quot;  &gt;</span><br><span class="line">                  &lt;i :class=&quot;item.type&quot; &gt;&lt;/i&gt;</span><br><span class="line">                  &lt;span  slot=&quot;title&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">                &lt;/template&gt;</span><br><span class="line">                &lt;div v-for=&quot;(c,cindex) in item.children&quot; :key=&quot;cindex&quot; &gt;</span><br><span class="line">                    &lt;el-menu-item :index=&quot;&apos;/user/&apos;+item.path+ &apos;/&apos;+ c.path&quot; &gt;&#123;&#123;c.text&#125;&#125;&lt;/el-menu-item&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-menu&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/el-aside&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  //import asyncRouterMap from &apos;./../../router/asyncRouterMap&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        isCollapse: true,</span><br><span class="line">        menuItemData:[],</span><br><span class="line">        openList:[],</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleOpen(key, keyPath) &#123;</span><br><span class="line">        console.log(key, keyPath);</span><br><span class="line">      &#125;,</span><br><span class="line">      handleClose(key, keyPath) &#123;</span><br><span class="line">        console.log(key, keyPath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted ()&#123;</span><br><span class="line">      this.menuItemData = this.$store.state.menuList;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">      activeMenuList:function()&#123;</span><br><span class="line">        return this.menuItemData.filter(function(item)&#123;</span><br><span class="line">          return item.children.length&amp;&amp;item.children</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h5 id="mongodb逻辑源码"><a href="#mongodb逻辑源码" class="headerlink" title="mongodb逻辑源码"></a>mongodb逻辑源码</h5><ol>
<li><p>主要是根据用户的角色返回对应角色的路由信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">'/getpermission'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;userRole&#125; = ctx.request.body;</span><br><span class="line">  <span class="keyword">if</span> (!userRole) <span class="keyword">return</span> ctx.body = &#123;<span class="attr">code</span>:<span class="number">4020</span>,<span class="attr">msg</span>:<span class="string">'该用户没有任何的权限'</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> args = &#123;<span class="attr">userRole</span>:userRole&#125;;</span><br><span class="line">  <span class="keyword">const</span> userRouters  = <span class="keyword">await</span> getRouters.query(args);</span><br><span class="line">  <span class="comment">//console.log(userRouters)</span></span><br><span class="line">  ctx.body = (userRouters.code ===<span class="number">200</span>) ? &#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">msg</span>:<span class="string">"获取权限成功"</span>,<span class="attr">permission</span>:userRouters.routerList&#125; : userRouters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Models 模块下的父路由和子路由  (这里踩了一个坑，当时认为mongodb的表直接把父路由和子路由直接写在一个表里，这样造成了很复杂的循环嵌套，请教了当时网上的一个大神，当时不明白，后来还是问后端的朋友才理解。)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose  =<span class="built_in">require</span>(<span class="string">'../db'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; model ,Schema&#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> PermissionSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  text:<span class="built_in">String</span>,</span><br><span class="line">  type:<span class="built_in">String</span>,</span><br><span class="line">  children:<span class="built_in">Array</span>,</span><br><span class="line">  userRoles:<span class="built_in">Array</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> RouteModel  = model(<span class="string">"parent_routers"</span>,PermissionSchema);</span><br><span class="line"><span class="built_in">module</span>.exports = RouteModel</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose  =<span class="built_in">require</span>(<span class="string">'../db'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; model ,Schema&#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> PermissionSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name:<span class="built_in">String</span>,</span><br><span class="line">  type:<span class="built_in">String</span>,</span><br><span class="line">  text:<span class="built_in">String</span>,</span><br><span class="line">  userRole:<span class="built_in">Array</span>,</span><br><span class="line">  parentRouterId:<span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> childRouteModel  = model(<span class="string">"children_routers"</span>,PermissionSchema);</span><br><span class="line"><span class="built_in">module</span>.exports = childRouteModel</span><br></pre></td></tr></table></figure>
</li>
<li><p>controllers模块下的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PermissionModel  = <span class="built_in">require</span>(<span class="string">'./../models/routers'</span>);</span><br><span class="line"><span class="keyword">const</span> PermissionChildModel =                 <span class="built_in">require</span>(<span class="string">'./../models/children_routers'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionCtl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> query (obj) &#123;  <span class="comment">// 用户权限查询接口</span></span><br><span class="line">    <span class="keyword">let</span> &#123; userRole &#125; = obj ;</span><br><span class="line">    <span class="keyword">if</span> (!userRole) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">code</span>:<span class="number">403</span>,<span class="attr">msg</span>:<span class="string">'用户权限丢失,请退出后重新登陆！'</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> routersDoc = <span class="keyword">await</span> PermissionModel.find(&#123;<span class="attr">userRoles</span>:&#123;<span class="attr">$elemMatch</span>:&#123;<span class="attr">$eq</span>:userRole&#125;&#125;&#125;);</span><br><span class="line">    <span class="keyword">const</span> routersChildDoc = <span class="keyword">await</span> PermissionChildModel.find(&#123;<span class="attr">userRole</span>:&#123;<span class="attr">$elemMatch</span>:&#123;<span class="attr">$eq</span>:userRole&#125;&#125;&#125;);</span><br><span class="line">    routersDoc.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//console.log(typeof(element._id));</span></span><br><span class="line">      routersChildDoc.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//console.log(typeof(item.parentRouterId));</span></span><br><span class="line">        <span class="keyword">if</span> (item.parentRouterId==element._id.toString()) &#123;</span><br><span class="line">          element.children.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(routersDoc);</span><br><span class="line">    <span class="keyword">return</span> !routersDoc ? &#123;<span class="attr">code</span>:<span class="number">403</span> ,<span class="attr">msg</span> :<span class="string">'改用户没有任何权限'</span>&#125;:&#123;<span class="attr">code</span>:<span class="number">200</span>,<span class="attr">routerList</span>:routersDoc,&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports =  <span class="keyword">new</span> PermissionCtl()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://s1.ax1x.com/2020/11/09/B7ICDJ.png" alt></p>
</li>
<li><h4 id="代码不全请访问github-获取全部源码"><a href="#代码不全请访问github-获取全部源码" class="headerlink" title="代码不全请访问github 获取全部源码"></a>代码不全请访问github 获取全部源码</h4><p><a href="https://github.com/Yuhior/vue-koa-mongo" target="_blank" rel="noopener">Yuhior的GitHub地址欢迎点赞</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>mongodb</tag>
        <tag>路由权限</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript回调函数</title>
    <url>/2018/08/15/callback/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UhSMCT.jpg" alt="Guo Mao Rain"></p>
<blockquote>
<p>实践的过程真是可以发现问题的过程的，自我总结的过程，使用nodeJs的过程中express的回调真的是太难受了，学习的时候感觉demo比较小，没感觉出来，但是等做东西之后，我的Tian简直忍受不了，回调嵌套一层一层又一层，别着急写完这层还有下一层（喝完这杯还有下一杯），人总是懒惰的，于是就想有没有回调的好方法，于是找到了promise和async/await的异步调用方法，这里先不说。突然意识到我去，函数调用模糊不清。</p>
</blockquote>
<ol>
<li>回调 先上英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。<br>用我蹩脚的英文二级水品翻译一下：回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。</li>
</ol>
<p>举个别人的栗子(果然自己家的栗子没有别人家的好吃)：约会结束后你送你女朋友回家，离别时，你肯定会说：“到家了给我发条信息，我很担心你。” 对不，然后你女朋友回家以后还真给你发了条信息。小伙子，你有戏了。其实这就是一个回调的过程。你留了个参数函数（要求女朋友给你发条信息）给你女朋友，然后你女朋友回家，回家的动作是主函数。她必须先回到家以后，主函数执行完了，再执行传进去的函数，然后你就收到一条信息了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"主函数执行完了！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"回调函数b"</span>);</span><br><span class="line">   &#125;, <span class="number">3000</span>); <span class="comment">// 这里是模仿耗时操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// callback函数以参数形式传递，保证变量的灵活性</span></span><br><span class="line">a(b);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UhSQ8U.jpg" alt="Guo Mao Rain"></p>
<ol start="2">
<li>普通的函数调用和回调函数有什么区别呢？</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    b();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">1000000000</span>;i++)&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    callback.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">1000000000</span>;i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">a(b); <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>
<ul>
<li>性能没有区别</li>
<li>回调函数是作为参数传递的,操作更加灵活，比如，你可以定义一个函数c,那可以运行b(c)，普通的函数调用当你在函数内运行函数的时候，就失去了变量的灵活性。</li>
</ul>
<ol start="3">
<li>可以通过回调函数来实现异步 假定有两个函数f1和f2，后者等待前者的执行结果。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure>
<p>f1是一个很耗时的任务，那么就可以考虑改写f1将f2写成f1的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">　　setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">"f1的任务代码"</span>);　　　</span><br><span class="line">　　&#125;, <span class="number">3000</span>);<span class="comment">//模拟一个耗时的操作</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"f2的任务代码"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">f1(f2)</span><br></pre></td></tr></table></figure>
<p><a href="https://yuhior.github.io/2018/08/15/callback/#more" target="_blank" rel="noopener">同步和异步详解</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>初识回调</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包你理解了么？</title>
    <url>/2020/12/24/colsure/</url>
    <content><![CDATA[<blockquote>
<p>都说包治百病，包治百病，今天我也带了一个名牌包包，不知道能不能治疗百病，猜猜是什么牌子，考验你对牌子的认识能力的时刻到了，LV、Prada、HERMES、CHANEL、Gucci、Versace、Coach反正我就知道这几个了太难了，但是通通都不是。今天给大家带来的是闭包。JavaScript中闭包这个点，相信很多的前端程序猿都听说过，不管是初级的还是高级的，而且是面试当中很容易被问到的一个，大家可能在对这个点的理解上，不太深刻。当然大佬们轻喷我泛指我一类的渣渣，毕竟人外有人天外有天，始终保持敬畏还是好的。那我们今天就开搞吧</p>
</blockquote>
<ol>
<li><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>提到闭包之前不得不提一下作用域的问题，在执行代码前很多的变量已经定义好。作用域里面保存的信息，在你写代码的时候已经决定了，而且会一直保持这个作用域不变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b= a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">999</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> n= a+ b+c;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    handle(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 输出 9</span></span><br></pre></td></tr></table></figure>
<p>我们用数学的集合的思想看一下作用域 。</p>
<p><img src="https://s3.ax1x.com/2020/12/28/ro6N9g.png" alt></p>
<p>1、查找标识符的过程会始终从当前作用域开始，然后逐级地向外层嵌套的作用域展开，直到找到标识符，或抵达最外层的作用域（也就是全局作用域）为止，如果找不到标识符，通常会导致错误发生。<br>2、每个执行环境都可以进入到外层作用域中查找标识符，但不能进入到内层作用域中查找标识符。</p>
</li>
<li><h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p>闭包是指有权访问另一个函数作用域中的变量的函数。从定义中我们可以得出两个结论 </p>
<ul>
<li>可以在函数的外部访问到函数内部的局部变量。 </li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ul>
<p>JavaScript高级程序设计（第3版）对作用域链的描述如下：</p>
<blockquote>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
</blockquote>
<p>所以这样我们就知道，能够访问一个函数A内部变量的除了这个函数A本身之外，其函数A所生成的包含环境中所在的函数B也可以访问。而知道了这一点我们就可以很容易猜到闭包的原理。那就是既然函数A内部所在的其它函数B可以访问到当前函数A的内部变量，那么如果我们将其内部所在的其它函数B作为返回值将其返回，并在函数A的外部用一个变量C来接收到这个返回值。那么这样，在函数A外部操作这个变量C时，实际上就是在操作函数A的返回值，也就是函数A所生成的包含环境中所在的内部函数B。而这个内部函数B是有权访问到函数A的内部变量的，所以在函数A外部的变量也就可以访问到函数A内部的变量。</p>
</li>
<li><h4 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h4><p>来吧 举栗子吧 不举栗子都不能讲清楚我的理解了 哈哈哈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    childFn();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//输出：1</span></span><br></pre></td></tr></table></figure>
<p>上边的函数 属于闭包么？ 那就看看函数会不会一直保持对定义时所处作用域的引用。上边的 栗子肯定能保持啊，只是好像不是我们看见的标准的那样的闭包写法，那我们就来改一下吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> childFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handle = fn();</span><br><span class="line">handle();</span><br></pre></td></tr></table></figure>
<p>在创建fn函数时，会创建一个预先包含<u>全局对象的作用域链</u> ，这个作用域链保存在内部的[[Scope]]属性当中。当调用fn函数的时候，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构成<u>执行环境的作用域链</u>，在函数childFn函数中实际上将fn的活动对象添加到了自己的作用域中，所以childFn函数的的作用域链被初始化为包含着父函数活动对象和全局变量对象。也就导致了当fn函数执行完毕后，并不会销毁，因为在childFn函数的作用域对象仍引用着这个活动。</p>
<p><img src="https://s3.ax1x.com/2020/12/28/rTC0MD.jpg" alt></p>
</li>
<li><h4 id="闭包和变量"><a href="#闭包和变量" class="headerlink" title="闭包和变量"></a>闭包和变量</h4><p>作用域链的这种配置机制引出了一个副作用 ，即闭包只能取得包含中任何变量的最后的一个值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result  = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    result[i]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">createFunctions()</span><br></pre></td></tr></table></figure>
<p>函数回返回一个数组，表面上好像是返回每一个函数的都应该返回自己的索引值，即位置0 的函数返回 0 ，1 的位置返回1 以此类推。但实际上每个函数都返回的10 ，因为每个函数作用域中都保存着createFunctions（）函数的活动对象，所以他们都是同一个变量当createFunctions（）函数返回后，变量i的值都是10 </p>
<p><img src="https://s3.ax1x.com/2020/12/28/rTFqJI.png" style="zoom:50%;"></p>
</li>
<li><h4 id="回调函数中闭包的使用"><a href="#回调函数中闭包的使用" class="headerlink" title="回调函数中闭包的使用"></a>回调函数中闭包的使用</h4><p>我们试一试回调函数中，是否仍然可以持有对定义时作用域的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">111</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runFn</span>(<span class="params">callBack</span>) </span>&#123;</span><br><span class="line">    callBack();</span><br><span class="line">&#125;</span><br><span class="line">runFn(fn());</span><br><span class="line"><span class="comment">//输出：111</span></span><br></pre></td></tr></table></figure>
<p>同步函数的回调支持定义时作用域的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">111</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">childFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> childFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runFn</span>(<span class="params">callBack</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        callBack();</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">runFn(fn());</span><br><span class="line"><span class="comment">//输出：111</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域请求的几种方式（一）</title>
    <url>/2018/07/25/cross-domain/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfxSsA.jpg" alt="Welcome"></p>
<blockquote>
<p>今日大雨，公交车上看到关注的某前端微信公众号，推送了一条消息。结尾是’你知道几种跨域请求的方式？‘脑子一闪貌似在曾经的面试中也遇到过类似的问题。了解了一下便不再理会了。今天又重新提出来，花了两个小时重新温习理解一下旧的东西。记录下来如有不足还请大神们指出。</p>
</blockquote>
<h3 id="最初始的jsonp"><a href="#最初始的jsonp" class="headerlink" title="最初始的jsonp"></a><strong>最初始的jsonp</strong></h3><ul>
<li>原生js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"><span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ajax原理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    sucess: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;,</span><br><span class="line">    error:</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  但是有一个缺点就是：只能实现get一种请求，显然不能满足我们的需求。</p>
<h3 id="空的iframe-form-发送请求，没有返回值"><a href="#空的iframe-form-发送请求，没有返回值" class="headerlink" title="空的iframe + form (发送请求，没有返回值)"></a><strong>空的iframe + form (发送请求，没有返回值)</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------简写并不完整</span></span><br><span class="line"><span class="keyword">const</span> requestPost = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//首先先创建一个用于发送数据的iframe</span></span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.name = <span class="string">'iframePost'</span>;</span><br><span class="line">    iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    <span class="keyword">const</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">    form.action = url;</span><br><span class="line">    form.target = iframe.name;</span><br><span class="line">    form.method = <span class="string">'post'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   原理 利用form的action和target属性向iframe发送数据，搭配iframe标签的跨域能力，实现跨域并且是提交无刷新。</p>
<h3 id="iframe跨域-分为主域相同-子域不同时和主域不相同时"><a href="#iframe跨域-分为主域相同-子域不同时和主域不相同时" class="headerlink" title="iframe跨域 (分为主域相同,子域不同时和主域不相同时)"></a><strong>iframe跨域 (分为主域相同,子域不同时和主域不相同时)</strong></h3><ul>
<li><h4 id="主域相同-子域不同"><a href="#主域相同-子域不同" class="headerlink" title="主域相同,子域不同"></a>主域相同,子域不同</h4><p> 先来举个栗子说明什么样的是主域相同而子域不同   （比如<a href="https://www.baidu.com和https://baike.baidu.com）" target="_blank" rel="noopener">https://www.baidu.com和https://baike.baidu.com）</a><br> 父窗口：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://child.domain.com/b.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">'admin'</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 子窗口：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">'get js data from parent ---&gt; '</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>原理：主域相同子域不同的条件下，实现跨域请求变量，两个域都需要设置域名 document.domain=‘xxxx’</p>
</li>
<li><h4 id="主域不相同"><a href="#主域不相同" class="headerlink" title="主域不相同"></a>主域不相同</h4></li>
</ul>
<ol>
<li>location.hash +iframe跨域<br>实现原理：想要A域与B域相互跨越通信，通过只能中间页C来实现。三个页面，不同域之间利用location.hash传值，相同域直接js访问通信<br>具体实现：A域（a.html）-&gt;B域（b.html）-&gt;A域（c.html），A与B不同域通过hash值单向传递，B与C不同域只能单向从B向C传递，但是A与C同域，C可通过parent.parent访问页面的所有对象。</li>
</ol>
<h5 id="a-html：http-www-yuhior1-com-a-html"><a href="#a-html：http-www-yuhior1-com-a-html" class="headerlink" title="a.html：http://www.yuhior1.com/a.html"></a>a.html：<a href="http://www.yuhior1.com/a.html" target="_blank" rel="noopener">http://www.yuhior1.com/a.html</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.yuhior2.com/b.html"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        iframe.src = iframe.src + <span class="string">'#user = admin'</span>;</span></span><br><span class="line">    &#125;, 1000);</span><br><span class="line"><span class="javascript">    <span class="comment">//提供同域c.html的回调方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">oncallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from c.html----&gt;'</span> + res);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="b-html：http-www-yuhior2-com-b-html"><a href="#b-html：http-www-yuhior2-com-b-html" class="headerlink" title="b.html：http://www.yuhior2.com/b.html"></a>b.html：<a href="http://www.yuhior2.com/b.html" target="_blank" rel="noopener">http://www.yuhior2.com/b.html</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.yuhior1.com/c.html"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//监听a.html传过来的hash值，然后在传给c.html</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="c-html：http-www-yuhior1-com-c-html"><a href="#c-html：http-www-yuhior1-com-c-html" class="headerlink" title="c.html：http://www.yuhior1.com/c.html"></a>c.html：<a href="http://www.yuhior1.com/c.html" target="_blank" rel="noopener">http://www.yuhior1.com/c.html</a></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//监听b.html传过来的hash值</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//再通过操作同域下a.html的js回调将结果返回</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">'hello'</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>window.name+iframe跨域<br>实现原理：window.name的不同之处在于：name值在不同的页面甚至不同的域名，加载后依旧存在，并且可以支持非常长的name值大约为2MB<br>具体实现原理：假设index.html页面需要请求远端服务器的数据，我在该页面下建一个iframe，它的src属性指向服务器文件地址（iframe标签的跨域能力），服务器文件里设置好window.name的值（也就是该iframe的contentWindow的name），然后在index.html里读取iframe的window.name的值。但是仅仅这样不能成功，因为index.html页面和该页面里边的iframe框架src不同域，则也就无法操作框架里边的东西，自然也就获取不到iframe的name值了，所以采用上边location.hash +iframe的思想  使用一个中间页面 ，在index.html同源下新建一个proxy.html 空页面</li>
</ol>
<p>上代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> state = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//防止onload事件之后，重置src ，重新载入页面，再触发onload事件</span></span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(iframe.contentWindow.name);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">            iframe.contentWindow.document.write(<span class="string">''</span>);</span></span><br><span class="line">            iframe.contentWindow.close();</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.removeChild(iframe);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span></span><br><span class="line">            state = 1;</span><br><span class="line"><span class="javascript">            iframe.contentWindow.location = <span class="string">'http://localhost:81/cross-domain/proxy.html'</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    iframe.src = <span class="string">'http://localhost:8080/data.php'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><center>未完待续……</center></p>
<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie和session</title>
    <url>/2018/07/20/cookie/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/Ufxddx.jpg" alt=" Cookie vs Session "></p>
<blockquote>
<p>最近在学习nodejs，对于视频教程上讲解的cookie和session理解的不太透，所以查了一些资料，有所体会现在把所理解的分享出来。</p>
</blockquote>
<h3 id="1-为什么会出现cookie和session"><a href="#1-为什么会出现cookie和session" class="headerlink" title="1. 为什么会出现cookie和session"></a>1. 为什么会出现cookie和session</h3><p>由于HTTP协议是无状态的，也就是说不会记录客户端和服务端的的连接信息，最简单的例子就是用户登录后，如果没有连接信息的话，短时间内访问一个网站的不同页面，每打开一个新的页面都要重新登录，对于用户来说这是不可能被接受的。所以需要一种机制来记录用户的信息，和用户状态。这样当用户在访问新的页面时，服务会反应过来，哦这个影虎已经登录过了，所以不需要在进行登录操作。</p>
<h3 id="2-cookie"><a href="#2-cookie" class="headerlink" title="2. cookie"></a>2. cookie</h3><p>　　cookie是客户端请求服务器时，服务端记录的用户信息，存储在客户端，下一次客户端发送请求时会将cookie一起发送。当客户端访问web服务器时，服务器会设置一个cookie返回给客户端，然后存储在客户端也就是我们的cookie信息，当用户下一次再请求web服务器时将会将cookie信息带上再发送给服务器，服务器通过cookie判断用户是否访问过该网站。<br>　　cookie是又时限的，有一个属性maxAge可以设置cookie的存储时间，超过时间后cookie会被删除，默认的是浏览器关闭时清除cookie。cookie一般用于用户的自动登录，记住密码等，将账户信息保存在cookie中，登录时cookie被传送到服务器完成自动登录。<br>　　cookie很方便但是由于用户信息存储在客户端，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。<br>　　<br><img src="https://s1.ax1x.com/2020/07/20/UfxNLR.jpg" alt="avatar"></p>
<h3 id="3-session"><a href="#3-session" class="headerlink" title="3. session"></a>3. session</h3><p>session同样是用来存储用户信息的，它存储在服务端，能够存储的数据比较大，而且很安全，那么为什么session这么好还要用cookie呢？现在所讲的session并不是能够单独存在的，它和cookie是相依赖的，session的运作是通过一个sessionid来进行，而这个sessionid通常放在客户端的 cookie 中。</p>
<p>通常来说session运转也就是在你访问一个用session的网站时，第一次访问时服务返回cookie中会存储一个sessionid，用户再次访问时客户端向服务器发送这个sessionid，有了sessionid之后通过查找这个sessionid对应的session信息，然后将用户信息返回给客户端。简单的来形容session存储在服务器中类似超市的储物柜，你来存东西按下存的按钮后，会给你一个开柜子的条形码（钥匙），这把钥匙也就是我们现在所说的session_id，当你买完东西后再次来开柜子时，你用你的钥匙只能开你那个柜子，而开不开别人的，别人也打开你的柜子，那么柜子里的东西就是你存的东西（存储在服务器中的相关信息）。<br>　　       不知道这样讲合不合适 。 哈哈0.0</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufxae1.jpg" alt="盗图哈哈哈"></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域请求的几种方式（二）</title>
    <url>/2018/07/19/cross-domain2/</url>
    <content><![CDATA[<blockquote>
<p>接着我们上一篇跨域请求的文章说</p>
</blockquote>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><strong>postMessage</strong></h3><p>window.postMessage()是HTML5的一个接口，专注实现在不同窗口不同页面的跨域通信。<br>用法：postMessage(data,origin)<br>参数：</p>
<ul>
<li>data：html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li>origin：协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<ol>
<li>a.html：（<a href="http://www.dotest1.com/a.html）" target="_blank" rel="noopener">http://www.dotest1.com/a.html）</a></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.dotest2.com/b.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">'aym'</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        <span class="comment">// 向dotest2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.dom2.com'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from dotest2 '</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>b.html：（<a href="http://www.dotest2.com/a.html）" target="_blank" rel="noopener">http://www.dotest2.com/a.html）</a></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'data from dotest1 ---&gt; '</span> + e.data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h3><p>cors全称是“跨域资源共享”（Cross-origin resource sharing），cors请求有两种请求，简单请求和非简单请求。<br><strong>只要同时满足以下两大条件，就属于简单请求。</strong></p>
<ol>
<li>请求方法是以下三种方法之一  </li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP的头信息不超出以下几种字段</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>普通请求只需要在服务端设置Access-Control-Allow-Origin即可，也就是告诉什么站点是被允许的。前端什么也不用干只需要正常的发送请求就好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.do1.com'</span>, <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是如果需要带cookie的话，前后端都需要进行设置</p>
<h4 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h4><ul>
<li>原生ajax </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.dotest2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>jQueryajax：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>vue框架 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><ul>
<li>Node </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跨域后台设置</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>, <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.dotest1.com'</span>, <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 此处设置的cookie还是dotest2的而非dotest1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">     * 但只要dotest2中写入一次cookie认证，后面的跨域接口都能从dotest2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.dotest2.com;HttpOnly'</span> </span><br><span class="line">    <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>非简单请求：如果请求方法是PUT、DELETE，或者Content-type的类型为applicetion/json的。使用非简单请求</strong><br>会发出一次预检测，返回码是204，预检测通过才会发送真正的请求</p>
<ul>
<li>Node </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allowCrossDomain = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://localhost:63342'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET,PUT,POST,DELETE,OPTIONS'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,accept,X-Custom-Header'</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>前端</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://www.domain2.com:8080/login'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
<p>上边代码中，HTTP请求方法是PUT，并且发送了一个自定义头信息X-Custom-Header。浏览器发现这是一个非简单请求 ，就会发出一个预检请求，要求服务器确认可以这样请求。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a><strong>代理</strong></h3><p><strong>跨域原理：</strong> 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。<br><strong>实现思路：</strong>通过nginx配置一个代理服务器（域名与dotest1相同，端口不同）做跳板机，反向代理访问dotest2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<h4 id="1-nginx具体配置"><a href="#1-nginx具体配置" class="headerlink" title="1. nginx具体配置"></a>1. nginx具体配置</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">81</span>;</span><br><span class="line">    server_name www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http: <span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">            proxy_cookie_domain www.domain2.com www.domain1.com;#修改cookie里域名</span><br><span class="line">        index index.html index.htm;</span><br><span class="line"></span><br><span class="line">        #当用webpack - dev - server等中间件代理接口访问nignx时， 此时无浏览器参与， 故没有同源限制， 下面的跨域配置可不启用</span><br><span class="line">        add_header Access - Control - Allow - Origin http: <span class="comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span></span><br><span class="line">            add_header Access - Control - Allow - Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前端代码示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<ul>
<li>后台Nodejs</li>
</ul>
<h4 id="2-Nodejs中间件代理插件-这篇有详细说明详见"><a href="#2-Nodejs中间件代理插件-这篇有详细说明详见" class="headerlink" title="2. Nodejs中间件代理插件 这篇有详细说明详见"></a>2. Nodejs中间件代理插件 这篇有详细说明<a href="https://blog.csdn.net/song_de/article/details/79652818" target="_blank" rel="noopener">详见</a></h4><h3 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域请求</tag>
      </tags>
  </entry>
  <entry>
    <title>图片缩放及拖拽</title>
    <url>/2020/07/08/darg/</url>
    <content><![CDATA[<blockquote>
<p>不知不觉又一个月过去，这段时间早上的看书也是颇有收获，真心推荐大家打好基础，在进行更深一步的学习，现在感觉自己从书籍中收获颇丰，打算在用一些天把这本书（js红皮书）看完，之后的心得体会一定和大家进行分享，当然如有不对之处还是请大佬们轻点开火。闲话咱也不多说，都在酒里，不不不，说错了，都在文章里。今天一改之前的学习风格，今天分享一下今天在工作中遇到的麻烦。</p>
</blockquote>
<ul>
<li><p>功能要求：进行图片的放大之后的滚轮缩放</p>
<ol>
<li><p>首先我先实现图片的放大吧</p>
<ul>
<li><p>使用了一个jquery的插件，baguetteBox.js这款插件还是不错的选择，符合正常的功能需求，强力推荐！！！</p>
</li>
<li><p>废话也不多说，毕竟一款插件看看就能上手，贴一下自己的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baguetteBox.run(<span class="string">'.z3d_goods_img'</span>, &#123;  <span class="comment">// .z3d_goods_img  就是被放大的图片元素</span></span><br><span class="line">  captions: <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>].alt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> oldIE === <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Object</span>.keys) &#123;</span><br><span class="line">  hljs.initHighlighting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>正题来了啊，实现滚轮缩放吧，鼠标滚轮缩放的方法都了解吧？什么不是很了解？一只脚送走，哈哈哈开玩笑应该送走我才对啊，来了滚轮滑动onmousewheel ，妥妥的了</p>
<ul>
<li><p>大佬们我还没说完，先别着急骂我，上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">image.onmousewheel=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> UpDown =  event.wheelDelta</span><br><span class="line">  <span class="comment">//大于0滚轮向上滚动,小于0滚轮向下滚动</span></span><br><span class="line">  <span class="keyword">if</span>(UpDown&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> maxScaleHeight = toPoint(<span class="keyword">this</span>.style.maxHeight);  <span class="comment">// 我是使用的是百分比，所以转了一下小数</span></span><br><span class="line">    <span class="keyword">var</span> maxScaleWidth = toPoint(<span class="keyword">this</span>.style.maxWidth) ;</span><br><span class="line">    <span class="keyword">this</span>.style.maxHeight = toPercent(maxScaleHeight<span class="number">-0.1</span>); <span class="comment">// 再转回百分比，感觉有点low ，请大佬给出方案</span></span><br><span class="line">    <span class="keyword">this</span>.style.maxWidth = toPercent(maxScaleWidth<span class="number">-0.1</span>);</span><br><span class="line">    <span class="keyword">var</span> scaleper = maxScaleWidth<span class="number">-0.1</span>;</span><br><span class="line">    <span class="keyword">this</span>.style.transform = <span class="string">'scale('</span>+ scaleper+<span class="string">')'</span>; <span class="comment">// 持续缩放，无限缩放，还被设计吐槽为啥能无限放大</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxScaleHeight = toPoint(<span class="keyword">this</span>.style.maxHeight);</span><br><span class="line">    <span class="keyword">var</span> maxScaleWidth = toPoint(<span class="keyword">this</span>.style.maxWidth) ;</span><br><span class="line">    <span class="keyword">this</span>.style.maxHeight = toPercent(maxScaleHeight+<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">this</span>.style.maxWidth = toPercent(maxScaleWidth+<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">var</span> scaleper = maxScaleWidth+<span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">this</span>.style.transform = <span class="string">'scale('</span>+ scaleper+<span class="string">')'</span>;</span><br><span class="line">       </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上完代码，谷歌浏览器一测没毛病，360没毛病 ，香香的了兄弟们，火狐（浏览器）狗哥不同意了啊整一句：我就不缩放，没办法啊 ，改吧！！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">image.addEventListener(<span class="string">'DOMMouseScroll'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> UpDown =  event.detail*<span class="number">40</span></span><br><span class="line">  <span class="comment">//大于0滚轮向上滚动,小于0滚轮向下滚动</span></span><br><span class="line">  <span class="keyword">if</span>(UpDown&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> maxScaleHeight = toPoint(<span class="keyword">this</span>.style.maxHeight);</span><br><span class="line">    <span class="keyword">var</span> maxScaleWidth = toPoint(<span class="keyword">this</span>.style.maxWidth) ;</span><br><span class="line">    <span class="keyword">this</span>.style.maxHeight = toPercent(maxScaleHeight+<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">this</span>.style.maxWidth = toPercent(maxScaleWidth+<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">var</span> scaleper = maxScaleWidth+<span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">this</span>.style.transform = <span class="string">'scale('</span>+ scaleper+<span class="string">')'</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxScaleHeight = toPoint(<span class="keyword">this</span>.style.maxHeight);</span><br><span class="line">    <span class="keyword">var</span> maxScaleWidth = toPoint(<span class="keyword">this</span>.style.maxWidth) ;</span><br><span class="line">    <span class="keyword">this</span>.style.maxHeight = toPercent(maxScaleHeight<span class="number">-0.1</span>);</span><br><span class="line">    <span class="keyword">this</span>.style.maxWidth = toPercent(maxScaleWidth<span class="number">-0.1</span>);</span><br><span class="line">    <span class="keyword">var</span> scaleper = maxScaleWidth<span class="number">-0.1</span>;</span><br><span class="line">    <span class="keyword">this</span>.style.transform = <span class="string">'scale('</span>+ scaleper+<span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这不能这两大段吧？，来吧！展示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	1.先合并一下event.detail和detail吧</span></span><br><span class="line"><span class="comment">*	2.兼容一下DOMMouseScroll和onmousewheel吧</span></span><br><span class="line"><span class="comment">*	3. 写共同的方法吧</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">var</span> wheel = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> delta = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!event) <span class="comment">/* For IE. */</span>  </span><br><span class="line">        event = <span class="built_in">window</span>.event;  </span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123; <span class="comment">/* IE/Opera. */</span>  </span><br><span class="line">        delta = event.wheelDelta / <span class="number">120</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.detail) &#123;  </span><br><span class="line">        delta = -event.detail / <span class="number">3</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (delta)  </span><br><span class="line">        handle(delta);   <span class="comment">// todo</span></span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault)  </span><br><span class="line">        event.preventDefault();  </span><br><span class="line">    event.returnValue = <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;  </span><br><span class="line">    <span class="comment">/** DOMMouseScroll is for mozilla. */</span>  </span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMMouseScroll'</span>, wheel, <span class="literal">false</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** IE/Opera. */</span>  </span><br><span class="line">iamge.onmousewheel = wheel;</span><br><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">delta</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> random_num = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">100</span>) + <span class="number">50</span>);  </span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// todo something</span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       <span class="comment">// todo something</span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li><p>功能要求：进行图片的放大之后鼠标拖拽</p>
<ol>
<li><p>前边弄完第二天，经理过来说，大佬再来个拖拽被，我心中那个美啊（…..反话大集合来了），美滋滋，搞起来吧，那就这样吧，那就这样吧 再爱都曲终人散了。我再贴</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	1. 先来获取图片的左右位置吧，毕竟要拖肯定得移动元素啊，记得要给元素定位哦</span></span><br><span class="line"><span class="comment">*	2. 来个对象记录一下开始的left top 和现在的left top吧</span></span><br><span class="line"><span class="comment">* 3. 鼠标按下和鼠标松开来记录位置吧</span></span><br><span class="line"><span class="comment">* 4. 那就开是移动吧</span></span><br><span class="line"><span class="comment">*/</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getCss(image, <span class="string">"left"</span>) !== <span class="string">"auto"</span>) &#123;</span><br><span class="line">   params.left = getCss(image, <span class="string">"left"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (getCss(image, <span class="string">"top"</span>) !== <span class="string">"auto"</span>) &#123;</span><br><span class="line">  params.top = getCss(image, <span class="string">"top"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getCss = <span class="function"><span class="keyword">function</span>(<span class="params">o,key</span>)</span>&#123;  <span class="comment">// 获取元素样式 ，这个没毛病吧 很常见</span></span><br><span class="line">  <span class="keyword">return</span> o.currentStyle? o.currentStyle[key] : <span class="built_in">document</span>.defaultView.getComputedStyle(o,<span class="literal">false</span>)[key];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">  zoomVal:<span class="number">1</span>,</span><br><span class="line">  left: <span class="number">0</span>,</span><br><span class="line">  top: <span class="number">0</span>,</span><br><span class="line">  currentX: <span class="number">0</span>,</span><br><span class="line">  currentY: <span class="number">0</span>,</span><br><span class="line">  flag: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  <span class="comment">// 鼠标按下获取 当时的鼠标的相对位置吧</span></span><br><span class="line">  params.flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!event) &#123;</span><br><span class="line">    event = <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="comment">//防止IE文字选中</span></span><br><span class="line">    bar.onselectstart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> e = event;</span><br><span class="line">  params.currentX = e.clientX;</span><br><span class="line">  params.currentY = e.clientY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">image.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  params.flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (getCss(<span class="keyword">this</span>, <span class="string">"left"</span>) !== <span class="string">"auto"</span>) &#123;  <span class="comment">// 获取图片的位置了吧</span></span><br><span class="line">    params.left = getCss(<span class="keyword">this</span>, <span class="string">"left"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getCss(<span class="keyword">this</span>, <span class="string">"top"</span>) !== <span class="string">"auto"</span>) &#123;</span><br><span class="line">    params.top = getCss(<span class="keyword">this</span>, <span class="string">"top"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  <span class="comment">// 鼠标开始移动了啊</span></span><br><span class="line">  <span class="keyword">if</span> (params.flag) &#123;</span><br><span class="line">    <span class="keyword">var</span> nowX = e.clientX, nowY = e.clientY;  <span class="comment">// 现在鼠标的位置</span></span><br><span class="line">    <span class="keyword">var</span> disX = nowX - params.currentX, disY = nowY - params.currentY; <span class="comment">// 移动的距离</span></span><br><span class="line">    <span class="keyword">this</span>.style.left = <span class="built_in">parseInt</span>(params.left) + disX + <span class="string">"px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.style.top = <span class="built_in">parseInt</span>(params.top) + disY + <span class="string">"px"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback == <span class="string">"function"</span>) &#123;</span><br><span class="line">      callback((<span class="built_in">parseInt</span>(params.left) || <span class="number">0</span>) + disX, (<span class="built_in">parseInt</span>(params.top) || <span class="number">0</span>) + disY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完毕，美滋滋！soeasy嘛，经理，我这个拖拽实现完了啊，上传，喝茶、葛优躺、抽根烟，回来了，经理：不能用这拖拽，写的什么玩意，我：小朋友你是不是有很多的❓❓❓，查看一番发现的 火狐这浏览是真的gou啊，拖拽居然是新开页面打开图片。整吧，这肯定得禁用默认事件啊，后来发现冒泡事件也得禁用，不知道什么鬼</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">iamge.onmousedown =<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = event ? event : <span class="built_in">window</span>.event;  <span class="comment">// 加上</span></span><br><span class="line">  <span class="keyword">if</span> (e.preventDefault) e.preventDefault();</span><br><span class="line">  <span class="keyword">else</span> e.returnvalue = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(e.stopPropagation)&#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// todo之前那些</span></span><br><span class="line">&#125;</span><br><span class="line">image.onmouseup  =<span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 加上</span></span><br><span class="line">  <span class="comment">// todo之前那些</span></span><br><span class="line">&#125;</span><br><span class="line">image.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 也加上吧</span></span><br><span class="line">  <span class="comment">// todo之前那些</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>缩放</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title>浅拷贝和深拷贝</title>
    <url>/2020/04/30/deep-copy/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfXSrq.jpg" alt="黑松、蓝天、白雪"></p>
<blockquote>
<p>上一篇文章还是沉浸再要过年的喜庆气氛当中，但怎么都没有想到疫情是如此的严重，还是希望各位珍爱生命远离病毒吧！，回顾一下过去的几个月，还好像再眼前，不禁感叹道时间过得实在太快，最近也在持续关注各大厂的招聘情况，感觉疫情之下，机会更少了，要求更多了，但是话又说回来，上天对每个人都是公平的，机会是对等的，只有不断地充实自己才是王道。所以我又来给各位灌毒鸡汤来了，干了这碗，咱们开始讲今天的主题，也就是我最近再啃得原生js。</p>
</blockquote>
<ol>
<li><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型分为两种，基本数据类型和引用数据类型，基本数据类型存储直接存储在栈内存中，而对于引用类型来说，它在栈内存中仅仅存了一个引用，而真正得数据存储在堆内存中。看一下示例图</p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfOzMn.jpg" alt></p>
<p>引用类型就是存在堆内存中，两个对象是在用指针指向同一个堆内存得地址 </p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfvBvj.jpg" alt></p>
</li>
</ol>
<ol start="2">
<li><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>既然要说深拷贝，那估计大家都知道肯定有浅拷贝啊，那什么是浅拷贝呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本类型得的浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> ; </span><br><span class="line"><span class="keyword">var</span> b = a ;</span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的浅拷贝</span></span><br><span class="line"><span class="keyword">var</span>  obj = &#123;</span><br><span class="line">    name:<span class="string">'yuhior'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    class:'三年二班'</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj ;</span><br><span class="line">obj2.name = <span class="string">'张三了'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// 张三了</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name)  <span class="comment">// 张三了</span></span><br></pre></td></tr></table></figure>
<p>上边我们发现 基本类型由于存储在栈内存中，是两个相对独立的数据，所以更改一个另一个并不会改变，但是引用类型的obj 改变的name ，将 obj 赋予 obj2 的时候，我们其实仅仅只是将 obj 存储在栈堆中的的引用赋予了 obj2 ，而两个对象此时指向的是在堆内存中的同一个数据，所以当我们修改任意一个值的时候，修改的都是堆内存中的数据。我称 这种 = 只拷贝对象的引用，而不深层次的拷贝对象的值叫浅拷贝</p>
</li>
<li><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在实际项目中，尤其是使用vue ，数据双向绑定的框架时，尤其明显的能感知到每个对象指向一个堆内存，一个改变另一些全部改变，根本不便于操作 。所以我们要深拷贝，我们要自由 哈哈哈哈哈。深拷贝就不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一下，形成一个全新的堆内存存储。    </p>
</li>
<li><h3 id="深拷贝的实现方法"><a href="#深拷贝的实现方法" class="headerlink" title="深拷贝的实现方法"></a>深拷贝的实现方法</h3><ul>
<li><p>低配版 JSON.stringify()和JSON.parse() </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  obj = &#123;</span><br><span class="line">    name:<span class="string">'yuhior'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    class:'三年二班'</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj2.name = <span class="string">'张三了'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// yuhior</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name)  <span class="comment">// 张三了</span></span><br></pre></td></tr></table></figure>
<p>缺点：不可以拷贝undefined 、function 、RegExp类型 的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// 直接报错  </span></span><br><span class="line"><span class="comment">// VM4562:1 Uncaught SyntaxError: Unexpected token u in JSON at position 0</span></span><br><span class="line"><span class="comment">//     at JSON.parse (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:1:17</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.assign (target,source)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>缺点：可以看到对于一层对象来说是没有任何问题的，但是如果对象的属性对应的是其它的引用类型的话，还是只拷贝了引用，修改的话还是会有问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;    <span class="comment">// 来一个多层的</span></span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">11</span>,</span><br><span class="line">    c: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.c[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.c); <span class="comment">// ["a", 6, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c); <span class="comment">// ["a", 6, "c"] </span></span><br><span class="line"><span class="comment">// 两个都改变了说明还是引用了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>递归拷贝 ，也是面试官常考的 ，我们还是先来举个栗子，毕竟学习了，还能吃栗子还是很爽的把 ，哈哈哈哈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  写一个深拷贝的方法把</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depClone</span>(<span class="params">tar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// tar如果是一个对象的话</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(tar)===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="comment">// typeof(Array) ==='object';  如果是一个数组</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(tar))&#123;</span><br><span class="line">            result = []; <span class="comment">// 将result 设定为数组 并执行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tar)&#123;</span><br><span class="line">                <span class="comment">//进行克隆数组中的每一项</span></span><br><span class="line">                result.push(deepClone(tar[i])); </span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//  如果是null的话，那就直接赋值null</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar === <span class="literal">null</span>)&#123; </span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar.constructor===<span class="built_in">RegExp</span>)&#123;</span><br><span class="line">             result = tar;</span><br><span class="line">         <span class="comment">//最后就是普通的对象了，直接进行循环，递归赋值所有的值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tar)&#123;</span><br><span class="line">                result[i] = deepClone(tar[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象的话，那就是一个基本类型了，那就直接赋值被</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = tar ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终于到回归结果的时候啦</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锅都准备好啦，那就赶紧做个饭试一下把！！！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一个对象 多层嵌套，还含有undefined  </span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        b:<span class="regexp">/a/</span>,</span><br><span class="line">        c:<span class="literal">undefined</span>,</span><br><span class="line">        d:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,</span><br><span class="line">    c:[</span><br><span class="line">        &#123;</span><br><span class="line">            b:<span class="regexp">/a/</span>,</span><br><span class="line">            c:<span class="literal">undefined</span>,</span><br><span class="line">            d:<span class="literal">null</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'a'</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">//  相信你勤快的小手，自己打印一下看看把</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>exports与module.exports区别</title>
    <url>/2018/11/07/exports/</url>
    <content><![CDATA[<blockquote>
<p>其实说起两者的区别也很简单 ，今天这个只是给自己和刚开始node的新手解释，大佬们不喜勿喷啊。</p>
</blockquote>
<h3 id="exports和module-exports区别"><a href="#exports和module-exports区别" class="headerlink" title="exports和module.exports区别"></a>exports和module.exports区别</h3><ul>
<li><p>解释之前先铺一个小例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="attr">name</span>:<span class="string">'lihua'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">b.name = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b= &#123;<span class="attr">name</span>:<span class="string">'lisi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//结果</span><br><span class="line">&#123; name: &apos;lihua&apos; &#125;</span><br><span class="line">&#123; name: &apos;lihua&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;lisi&apos; &#125;</span><br></pre></td></tr></table></figure>
<p>来分析一波吧！开始var了一个对象a，b是对a的引用。也就是说a和b此时指向同一块内存，当改变b.name时，还是指向的那块内存，改变了那块内存里的内容，所以a也发生了改变。当b被覆盖时（var b= {name:’lisi’}），b也就指向了一块新的内存，所以最后结果不同。</p>
</li>
<li><p>当一个node.js文件执行时 ，会创建一个module对象，同时module对象会创建一个exports属性，初始化的值是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果希望模块成为一个传统的模块实例，也就是 exports.xxx=xxx 这种情况下可以直接使用exports导出</p>
</li>
</ul>
<blockquote>
<p>这时exports.xxx就像开始例子中的直接改变b.name的情况，随着exports 的改变module.exports也改变</p>
</blockquote>
<ul>
<li><p>但是如果希望模块是一个特别的类型（我称它是覆盖式类型） ，引用时 直接就像下面这样，就必须使用module.exports了，不能只用exports。因为如果只是用exports就像开始例子中 var b= {name:’lisi’};b直接被覆盖，它此时指向就和module.exports不同了 。结果也就不同了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;rmbToDollar,dollarToRmb&#125; = <span class="built_in">require</span>(<span class="string">'./currency/currency'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rmbToDollar(<span class="number">6</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dollarToRmb(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>为甚么非要两者相同 ，因为module.exports才是真正的接口，exports只不过是它的一个辅助工具。require引用时最终返回调用的是module.exports而不是exports。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>exports</tag>
        <tag>module.exports</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue和小程序的区别</title>
    <url>/2018/10/24/different/</url>
    <content><![CDATA[<p><img src="http://ph4yay1pp.bkt.clouddn.com/1024.jpg" alt=" 1024程序猿节日 "></p>
<blockquote>
<p>正在电脑前敲代码的你知道今天是什么日子，1024程序员节，像我这这种前端小白也来凑凑热闹，近期没有怎么学习，事情比较多，除了正常的上班外，还有一些别的事情，比如让自己的肚子感受一下美味，让自己的脑子进一下水，哈哈哈反正就是没学习，没学习啊没学习，满满的负罪感，愧疚感，觉得对不起自己。因为不能让脑子太饱，保持饥饿，才能学习。用了小程序发现和Vue极其相似，那就来区别一下。、</p>
</blockquote>
<h3 id="1-生命周期-话不多说，上来先po图"><a href="#1-生命周期-话不多说，上来先po图" class="headerlink" title="1.生命周期 (话不多说，上来先po图)"></a>1.生命周期 (话不多说，上来先po图)</h3><ul>
<li><p>Vue生命周期<br><img src="https://s1.ax1x.com/2020/07/20/UfOFgA.jpg" alt></p>
</li>
<li><p>小程序生命周期</p>
</li>
</ul>
<p><img src="http://ph4yay1pp.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20181024151730.jpg" alt=" 1024程序猿节日 "></p>
<h4 id="从上边可以看得出，小程序的钩子函数要简单的很多"><a href="#从上边可以看得出，小程序的钩子函数要简单的很多" class="headerlink" title="从上边可以看得出，小程序的钩子函数要简单的很多"></a>从上边可以看得出，小程序的钩子函数要简单的很多</h4><p>Vue 的钩子函数在跳转的新的页面时，钩子函数都会触发，小程序的钩子函数，页面跳转时不同的跳转方式，触发的钩子并不相同。</p>
<ul>
<li>onLoad: 页面加载</li>
<li>一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。</li>
<li>onShow: 页面显示，每次打开页面都会调用一次。</li>
<li>onReady: 页面初次渲染完成，一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期</li>
<li>onHide: 页面隐藏，当navigateTo或底部tab切换时调用。</li>
<li>onUnload: 页面卸载，当redirectTo或navigateBack的时候调用。</li>
</ul>
<h4 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h4><p>在页面加载请求数据时，两者钩子使用有些类似。</p>
<ul>
<li>vue一般会在created或者mounted中请求数据，</li>
<li>小程序在会在onLoad或者onShow中请求数据。</li>
</ul>
<h3 id="2-数据绑定"><a href="#2-数据绑定" class="headerlink" title="2.数据绑定"></a>2.数据绑定</h3><ul>
<li>VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"&#123;&#123;imgSrc&#125;&#125;"</span> &gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;imgSrc&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-列表渲染"><a href="#3-列表渲染" class="headerlink" title="3.列表渲染"></a>3.列表渲染</h3><ul>
<li>vue</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in msg"</span>&gt;</span></span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#demo'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">           msg: [</span><br><span class="line"><span class="javascript">              &#123; <span class="attr">message</span>: <span class="string">'商品列表1'</span> &#125;,</span></span><br><span class="line"><span class="javascript">              &#123; <span class="attr">message</span>: <span class="string">'商品列表2'</span> &#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小程序</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;item&#125;&#125;"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js文件里边 --&gt;</span></span><br><span class="line">    Page(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">       msg: [</span><br><span class="line">          &#123; message: '商品列表1' &#125;,</span><br><span class="line">          &#123; message: '商品列表21'&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4-显示与隐藏"><a href="#4-显示与隐藏" class="headerlink" title="4.显示与隐藏"></a>4.显示与隐藏</h3><ul>
<li><p>vue中，使用v-if 和v-show控制元素的显示和隐藏</p>
</li>
<li><p>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
</li>
</ul>
<h3 id="5-事件处理"><a href="#5-事件处理" class="headerlink" title="5.事件处理"></a>5.事件处理</h3><ul>
<li><p>vue中使用v-on:event绑定事件，或者使用@event绑定事件</p>
</li>
<li><p>小程序中使用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,</p>
</li>
</ul>
<h3 id="6-双向数据绑定"><a href="#6-双向数据绑定" class="headerlink" title="6.双向数据绑定"></a>6.双向数据绑定</h3><h4 id="a、设置值"><a href="#a、设置值" class="headerlink" title="a、设置值"></a>a、设置值</h4><ul>
<li>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点(对比完可以发现 当页面表单元素很多的时候，更改值就是一件头疼的事。vue的v-model简直爽的不要不要的。)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"reason"</span> <span class="attr">class</span>=<span class="string">'reason'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'.app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            reason:<span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小程序却没有这个功能，它只能通过事件触发，当表单发生变化时，触发表单的绑定方法，然后在这个方法中，通过this.setData({key:value})的形式将表单中值赋给data</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindinput</span>=<span class="string">"bindReason"</span> <span class="attr">class</span>=<span class="string">'reason'</span> <span class="attr">value</span>=<span class="string">'&#123;&#123;reason&#125;&#125;'</span> <span class="attr">name</span>=<span class="string">"reason"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js文件里边 --&gt;</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        reason:''</span><br><span class="line">    &#125;,</span><br><span class="line">    bindReason(e) &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          reason: e.detail.value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="b、取值"><a href="#b、取值" class="headerlink" title="b、取值"></a>b、取值</h4><ul>
<li><p>vue中，通过this.reason取值</p>
</li>
<li><p>小程序中，通过this.data.reason取值</p>
</li>
</ul>
<h3 id="7-绑定事件进行传参"><a href="#7-绑定事件进行传参" class="headerlink" title="7.绑定事件进行传参"></a>7.绑定事件进行传参</h3><ul>
<li>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> @<span class="attr">click</span>=<span class="string">"say('今天1024节，过节不上班')"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'.btn'</span>,</span></span><br><span class="line">        methods:&#123;</span><br><span class="line">            say(msg)&#123;</span><br><span class="line">               consloe.log(msg)  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，现在一想到当时做项目传参传的就头疼</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'tr'</span> <span class="attr">bindtap</span>=<span class="string">'toApprove'</span> <span class="attr">data-id</span>=<span class="string">"&#123;&#123;id&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js文件里边 --&gt;</span></span><br><span class="line">Page(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        id:0</span><br><span class="line">    &#125;,</span><br><span class="line">    toApprove(e) &#123;</span><br><span class="line">        let id = e.currentTarget.dataset.id;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          id: id</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="8-子组件及父子组件通信"><a href="#8-子组件及父子组件通信" class="headerlink" title="8.子组件及父子组件通信"></a>8.子组件及父子组件通信</h3><h4 id="a、子组件使用"><a href="#a、子组件使用" class="headerlink" title="a、子组件使用"></a>a、子组件使用</h4><ul>
<li>vue中需要以下几步 1.准备子组件  2.在需要使用的父组件中通过import引入  3.在父组件vue的components中注册  4.在模板中使用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 bar.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"write"</span> <span class="attr">:title</span>=<span class="string">"title"</span> <span class="attr">class</span>=<span class="string">"icon-dismiss"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        props:&#123;</span><br><span class="line"><span class="javascript">            title:<span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">            <span class="keyword">default</span>:<span class="string">''</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            write()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'过节不上班'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">'今天1024'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件 foo.vue--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bar</span> <span class="attr">:title</span>=<span class="string">"title"</span> @<span class="attr">helloWorld</span>=<span class="string">"helloWorld"</span>&gt;</span><span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./bar.vue'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            title:<span class="string">"我是标题"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            helloWorld()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'我接收到子组件传递的事件了'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            Bar</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小程序中 </li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--components/tabBar/child.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'tabbar-wrapper'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'left-bar &#123;&#123;currentpage==="index"?"active":""&#125;&#125;'</span> <span class="attr">bindtap</span>=<span class="string">'jumpToIndex'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'iconfont icon-shouye'</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">'right-bar &#123;&#123;currentpage==="setting"?"active":""&#125;&#125;'</span> <span class="attr">bindtap</span>=<span class="string">'jumpToSetting'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">'iconfont icon-shezhi'</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>设置<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在子组件的json文件中，将该文件声明为组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;component&quot;: true&#125;</span><br></pre></td></tr></table></figure>
<p>在父组件中，直接引入即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tab-bar</span> <span class="attr">currentpage</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">tab-bar</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="b、父子组件通信"><a href="#b、父子组件通信" class="headerlink" title="b、父子组件通信"></a>b、父子组件通信</h4><ul>
<li>vue中父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递</li>
<li>子组件向父组件通信可以通过this.$emit将方法和数据传递给父组件。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  父组件 foo.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bar</span> <span class="attr">:title</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./bar.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="javascript">        title:<span class="string">"我是标题"</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        Bar</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子组件bar.vue</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">"title"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">    props:&#123;</span><br><span class="line">        title:&#123;</span><br><span class="line"><span class="javascript">           type:<span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">           <span class="keyword">default</span>:<span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>微信小程序 父组件向子组件通信，但小程序没有通过v-bind，而是直接将值赋值给一个变量</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tab-bar</span> <span class="attr">currentpage</span>=<span class="string">"index"</span>&gt;</span><span class="tag">&lt;/<span class="name">tab-bar</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- index就是要向子组件传递的值 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>在子组件properties中，接收传递的值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">    currentpage: &#123;         </span><br><span class="line">      type: String,     <span class="comment">&lt;!--类型（必填） --&gt;</span></span><br><span class="line">      value: 'index'    <span class="comment">&lt;!-- 属性初始值（可选） --&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>微信小程序</tag>
        <tag>不同</tag>
      </tags>
  </entry>
  <entry>
    <title>node中请求静态文件（图片例子）</title>
    <url>/2018/11/06/fs/</url>
    <content><![CDATA[<blockquote>
<p>读node的API过程中发现了response的中一句</p>
<p>The response inherits from <a href="https://nodejs.org/api/http.html" target="_blank" rel="noopener">Stream</a>, and additionally implements the following:</p>
<p>（这个类实现了（而不是继承自）<a href="http://nodejs.cn/s/9JUnJ8" target="_blank" rel="noopener">可写流</a> 接口。 它是一个有以下事件的 [<code>EventEmitter</code>]：）</p>
</blockquote>
<ol>
<li><h3 id="来理解一下-fs-createReadStream-filePath-pipe-response"><a href="#来理解一下-fs-createReadStream-filePath-pipe-response" class="headerlink" title="来理解一下  fs.createReadStream( filePath).pipe(response);"></a>来理解一下  fs.createReadStream( filePath).pipe(response);</h3><ul>
<li>createReadStrem 是返回 : &lt;fs.ReadStream&gt;  详见<a href="http://nodejs.cn/s/YuDKX1" target="_blank" rel="noopener">可读流</a>。</li>
<li>response 当然就是响应</li>
<li>pipe是将两个数据流连接起来。</li>
</ul>
</li>
<li><p>这样就可以输出数据流了么？</p>
<ul>
<li>我们知道WriteStream （可写流是对数据要被写入的目的地的一种抽象。）</li>
<li>所有可写流的例子（包括fs的写入流）都实现了 stream.Writable类定义的接口。</li>
<li>也就是说可以输出数据流</li>
<li>而前言提到response 也实现了可写流接口 </li>
<li>那么fs.createReadStream 与response拼接响应，就可以输出了</li>
</ul>
</li>
<li><p>来个小例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path =<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 从命令行参数获取root目录，默认是当前目录:</span></span><br><span class="line"><span class="keyword">var</span> root = path.resolve(process.argv[<span class="number">2</span>] || <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Static root dir: '</span> + root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得URL的path，类似 '/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="comment">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> filepath = path.join(root, pathname);</span><br><span class="line">    <span class="comment">// 获取文件状态:fs.stat() 来检查某个文件是否存在，stats 为 fs.Stats 对象，它提供了一个文件的信息</span></span><br><span class="line">    fs.stat(filepath, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;	</span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; stats.isFile()) &#123;<span class="comment">//如果 fs.Stats对象表示一个普通文件，stats.isFile()则返回 true</span></span><br><span class="line">            <span class="comment">// 没有出错并且文件存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'200 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送200响应:</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 将文件流导向response:</span></span><br><span class="line">            fs.createReadStream(filepath).pipe(response)；</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错了或者文件不存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'404 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送404响应:</span></span><br><span class="line">            response.writeHead(<span class="number">404</span>);</span><br><span class="line">            response.end(<span class="string">'404 Not Found'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>流</tag>
      </tags>
  </entry>
  <entry>
    <title>git小记</title>
    <url>/2020/05/07/git/</url>
    <content><![CDATA[<blockquote>
<p>最近看了好多公众号的推送，基本都是给同行打气的，还有诉说当前互联网大环境的，疫情之下充满了挑战，很多的程序员都面临降薪被辞退的可能，但是挑战伴随着机遇，（是不是很官方哈哈哈哈），其实不管环境怎样，你改变不了环境只能改变自己，当然不是让你随波逐流，不要曲解我的意思哦，改变自己是硬道理，提升自己不管在什么样的环境下都会比较吃香，毕竟优胜略汰，有着它一定的法则，是金子总会发光的，是吧？老铁们。哈哈哈哈听懂的请扣1。</p>
</blockquote>
<ol>
<li><p>项目初始化</p>
<ul>
<li><p>先要有个项目库  github上创建一个</p>
<p>会有一个https连接产生 ，也就是项目库地址</p>
</li>
<li><p>连接项目库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init   				// 项目初始化产生.git文件夹，如果是脚手架则省略这步</span><br><span class="line">git remote add origin &lt;刚才产生的https地址&gt;</span><br><span class="line">git remote -v    		 // 查询是否连接到项目库</span><br><span class="line">git add .    		 	// 工作区中所有未跟踪或者修改的文件添加到暂存区</span><br><span class="line">git commit -m  "信息" 	// 提交了啊</span><br><span class="line">git push origin master   //上传本地当前分支代码到master分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入用户名和密码，每次push都要输入是不是很麻烦？ 采用修改git配置文件的方法</p>
<p>在用户文件夹下找到 <code>.gitconfig</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = xxx</span><br><span class="line">    email = xxx@xxxxx.com</span><br></pre></td></tr></table></figure>
<p>后边追加一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">     helper=store</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>2. </p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/07/13/hello-world/</url>
    <content><![CDATA[<p>这是我第一篇文章表达一下心情 . 我想通过博客来记录自己的学习过程，从而不断的提高自己，文章中可能有不对之处，望请不吝赐教。</p>
<p>北冥有鱼，其名为鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。《齐谐》者，志怪者也。《谐》之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟，置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力。故九万里，则风斯在下矣，而后乃今培风；背负青天，而莫之夭阏者，而后乃今将图南。蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣，奚以之九万里而南为？”适莽苍者，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知！</p>
<p>小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎！汤之问棘也是已。穷发之北，有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名为鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云，抟扶摇羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鴳笑之曰：“彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？”此小大之辩也。</p>
<p>故夫知效一官，行比一乡，德合一君，而征一国者，其自视也，亦若此矣。而宋荣子犹然笑之。且举世誉之而不加劝，举世非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。</p>
]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>第一</tag>
      </tags>
  </entry>
  <entry>
    <title>前端求生之路</title>
    <url>/2018/12/21/go/</url>
    <content><![CDATA[<blockquote>
<p>最近忙着加班学习  ，等哪天把学习笔记分享一下。</p>
</blockquote>
<p>根据 <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">w3schools</a>   网上的文章讲解：</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>GET请求在浏览器回退时候是无害的，而POST请求会再一次提交请求的。</li>
<li>GET请求产生的URL地址可以被Bookmark(书签)，而POST不可以。</li>
<li>GET请求会被浏览器主动缓存，而POST请求不会，除非手动设置。</li>
<li>GET请求只能进行URL编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整的保留在浏览器历史记录里，而POST请求中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST请求的长度限制要远大于GET请求的参数长度。</li>
<li>对参数的数据类型，GET请求只接受字符串类型，而POST请求没有限制。</li>
<li>GET请求比POST请求更不安全，因为参数暴露在URL上，不能用来传递敏感信息。</li>
<li>GET请求参数通过URL传递，POST请求参数放在Request body中。</li>
</ul>
<p>但是，实际上GET请求和POST请求本质上是没有区别的。GET请求和POST请求是HTTP协议中的两种发送请求的方法。而HTTP是基于TCP/IP的关于数据在万维网中通信的协议。</p>
<p>HTTP的底层是TCP/IP。所以GET请求和POST请求的底层也是TCP/IP，即GET/POST都是TCP链接，GET和POST请求能做的事情是一样的。在理论上来说，可以给GET请求加上Request body，给POST请求带上URL参数。</p>
<p>那么，回到这个问题上，GET请求和POST请求的区别是什么？</p>
<h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>在万维网中，TCP就像是汽车，我们用TCP来运输数据，但是如果道路上都是一摸一样的汽车，那么这个路线看起来是一片混乱，送急件的汽车可能为前面装载货物的汽车拦堵在路上，整个交通系统一定会瘫痪的。</p>
<p>为了避免这种情况的发生，交通规则HTTP诞生了，HTTP给汽车运输设定了几种服务类型，例如GET、POST、PUT、DELETE、PATCH、OPTION等，HTTP规定，当执行GET请求的时候要给汽车贴上GET标签(设置method为GET)，并且要求把传送的数据放到车顶(URL)上以方便记录，如果是POST请求，就要在车上贴上POST标签(设置method为POST)，并把货物放到车厢(Request body)中。虽然我们可以在GET请求的时候往车厢里偷偷藏点货物，或是在POST请求的时候，在车顶放一些数据。HTTP只是一个行为准则，而TCP才是GET和POST的实现基本。</p>
<p>那么，为什么会有对参数的大小限制呢？</p>
<p>在万维网这个交通网络中，除了车辆，还有运输公司。不同的浏览器(发送HTTP请求)和服务器(接收HTTP请求)就是不同的运输公司。</p>
<p>虽然我们我们可以在车辆上装了无限的货物，但是运输公司对于装货和卸货也是要很大成本的。他们会限制单词运输量来控制风险，数据量过大对浏览器和服务器都是很大负担。大部分浏览器会限制URL长度在2K个字符，而服务器大部分最多处理 64K大小的URL。超出的部分是不会处理的。如果我们在GET请求中在request body藏了数据，不同的服务器处理的方式是不同的，有些会卸货读取数据，有些服务器直接就会忽略，所以，不建议GET请求的Request body中放数据。</p>
<p>所以，从这个角度来说：GET请求和POST请求本质都是TCP链接，并无差异，但是由于HTTP的规定和浏览器、服务器的限制，导致他们在应用过程里体现出不同。</p>
<p>除此以外，他们还有一个重大的区别：GET请求会产生一个TCP数据包，POST请求会产生两个TCP数据包。</p>
<p>对于GET请求，浏览器会把header和data一并发送出去，服务器响应200，返回数据。</p>
<p>对于POST请求，浏览器会先发送header，服务器响应100，浏览器再发送data，服务器响应200，返回数据。</p>
<p>换句话来，GET请求只需要汽车跑一趟就把货物送到了，POST请求需要跑两趟，第一趟过来先和服务器打一声招呼，“嗨，我等下要送一批货物过来，你们打开门迎接我一下”，然后再回头把货物送过去。</p>
<p>最后，为什么不能通过GET请求来替代POST请求？<br>GET请求与POST请求都有自己的语义，不能混用。<br>在网络环境良好的情况下，发一次包的时间和发两次包的时间差别基本可以忽略不计，而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器的POST请求会发送两次包，Firefox就只发送一次。</p>
]]></content>
      <tags>
        <tag>HTTP扫盲</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程一</title>
    <url>/2020/07/21/inherited/</url>
    <content><![CDATA[<blockquote>
<p>早吃撑、午吃撑、晚吃撑天天就是吃啊造啊吃完吐泡泡啊，每天都吃，也不胖这找谁说理去啊，最近虽然吃的频率比较少，但是真心吃了好几家环境不错又好吃的地方，主要我自己找能实力不太允许，大佬就不一样喽，不出手则已，一出手就是吃撑，哈哈哈哈哈。最近反正就是木空抽空也得写东西，因为我感觉我的js真的超烂，对于原生理解真的很浅，所以感觉自己触碰到了核心，那就忍不住就想一直触碰核心的内容，需要赶紧消化理解，如果不能消化总感觉自己有什么事情没有完成，这种感觉可是很不好吃饭不香，睡觉不香，干啥啥不香，哈哈哈哈反正就掌握了就很香啊。</p>
</blockquote>
<h4 id="1-理解对象"><a href="#1-理解对象" class="headerlink" title="1. 理解对象"></a>1. 理解对象</h4><ul>
<li><p>构造函数</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nichplas"</span> ;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">person.job  = <span class="string">""</span>Software Engineer<span class="string">";</span></span><br><span class="line"><span class="string">person.sayName = function ()&#123;</span></span><br><span class="line"><span class="string">    alert(this.name);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字变量语法</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nichplas"</span>,</span><br><span class="line">    age:<span class="number">29</span>,</span><br><span class="line">    job:<span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-属性类别"><a href="#2-属性类别" class="headerlink" title="2. 属性类别"></a>2. 属性类别</h4><ul>
<li><p>数据属性<br>数据属性包含了一个数据的值位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性</p>
<ul>
<li>[[ Configurable ]]:能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>[[ Enumerable ]]:表示能否通过for-in 循环返回属性。</li>
<li>[[ Writable ]]:表示能都修改属性的值</li>
<li>[[ Value ]]:包含这个属性的数据值。读取属性值的时候，从这位置读；写入属性值的时候，把新值保存在这个位置。默认为undefined。<br>Object.defineProperty()接受三个参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Object.defineProperty(属性所在对象,属性名称,&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 后边对象的属性一定是configurable、enumerable、writable、value设置其中一个或者多个的值</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.definePeoperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    value:<span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name); <span class="comment">// Nicholas</span></span><br><span class="line">person.name = <span class="string">"lihua"</span>;</span><br><span class="line">alert(person.name); <span class="comment">// Nicholas</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问器属性<br>访问其属性不包含属性值；他们包含一个getter和setter函数(非必须)<em>Vue的数据响应式其中就是使用了getter和setter函数</em>，在读取访问器属性时，会调用getter函数返回有效的值；在写入访问器属性时，会调用setter函数并传入新值</p>
<ul>
<li>[[ Configurable ]]:同数据属性的Configurable</li>
<li>[[ Enumberable ]]:同数据属性的Enumberable</li>
<li>[[ Get ]]:在读去属性时调用的函数。默认值为undfined.</li>
<li>[[ Set ]]:在写入属性时调用的函数<br>Object.defineProperty()定义访问器属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year :<span class="number">2020</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>:function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2020</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition + = newValue <span class="number">-2020</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">book.year =<span class="number">2022</span>; <span class="comment">//触发set方法</span></span><br><span class="line">alert(book.edition) <span class="comment">// 触发get方法  3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>定义多个属性<br>Object.defineProperties(),接受两个参数：第一个是添加和修改属性的对象，第二个是对象的属性与第一个对象中要添加或修改的属性一一对应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">2020</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function()&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2020</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>._year =newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition+ =  newValue <span class="number">-2020</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取属性特性<br>Object.getOwnPropertyDescriptor(),接受两个参数:第一个是：属性所在的对象和要读取其描述符的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value) ;  <span class="comment">// 2020</span></span><br><span class="line">alert(descriptor.configurable) ; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3. 创建对象"></a>3. 创建对象</h4><p>   使用字变量或者new对象的方式虽然都可以创建对象，但明显有缺点，使用同一个借口创建很多对象，会产生大量的重复的代码</p>
<ul>
<li><p>工厂模式：把实现同一件事情的相同代码放到同一个函数中，想实现这个功能只要执行这个函数即可，这就是工厂模式，也叫做“函数的封装”，这也是”低耦合，高内聚“，从而达到减少页面冗余码，提高代码重复利用率的作用.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person =<span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//创建一个新对象</span></span><br><span class="line">    <span class="comment">//原料</span></span><br><span class="line">    person.name = name;</span><br><span class="line">    person.age = age;</span><br><span class="line">    <span class="comment">//加工</span></span><br><span class="line">    person.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    person.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"年龄："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出厂</span></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">"张三"</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p1.showName();</span><br><span class="line">p2.showName();</span><br><span class="line"><span class="built_in">console</span>.log(p1.showName==p2.showName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>缺点：一般我们创建对象是通过new来创建，比如new Date()，这里使用的是方法创建。（var p1=createPerson(“张三”,45)）使用new来创建可以简化一些代码，也带来一些新的特性。<br>每个对象都有一套自己的方法，浪费资源   console.log(p1.showName==p2.showName); false  说明两个方法不一样  ，因为创建function()的时候其本质是通过new Function()来创建的，会诞生一个新的函数对象，造成资源浪费。</p>
</li>
<li><p>构造函数模式：Array、Object、Function等这些都是内置类，所有的数组都是内置类Array的实例，所以的对象都是内置类Object的实例，所以函数都是Function的实例，而构造函数就是自定义一个类。</p>
<ul>
<li><p>构造函数写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span> (<span class="params">name,age</span>)</span>&#123;  <span class="comment">//首先构造函数 开头首字母大写</span></span><br><span class="line">    <span class="keyword">this</span>.name =name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+ <span class="keyword">this</span>.name);</span><br><span class="line">    &#125; ;</span><br><span class="line">    <span class="keyword">this</span>.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不用返回对象啦！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">"张三"</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">p1.showName();</span><br><span class="line">p2.showName();</span><br><span class="line"><span class="built_in">console</span>.log(p1.showName==p2.showName); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor == CreatePerson) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.constructor == CreatePerson) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//1.我们看到这里使用了new方法来创建对象.</span></span><br><span class="line"><span class="comment">//2.但是console.log(p1.showName==p2.showName); //false 依旧是false  说明还是存在浪费资源的问题.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将构造函数当作对象<br>构造函数和其他函数的唯一的区别，就在于调用它们的方式不同。不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> person =<span class="keyword">new</span> CreatePerson(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">person.showName();</span><br><span class="line"><span class="comment">// 作为普通函数</span></span><br><span class="line">CreatePerson(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line"><span class="built_in">window</span>.showName();</span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o,<span class="string">"kasare"</span>,<span class="number">25</span>);</span><br><span class="line">o.showName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数的问题<br>构造函数虽然很好用但是并不是没有缺点，使用构造函数主要问题就是每个方法都要在每个实例上重新创建一遍，上边的p1.showName和p2.showName不相等。创建两个完成同样任务的Function实例确实没有什么必要；况且有this对象在，根本不用在执行代码前就把函数对象绑定到特定对象上边</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age= age;</span><br><span class="line">    <span class="keyword">this</span>.showName = showName;</span><br><span class="line">&#125;</span><br><span class="line">funtion showName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样由于showName包含的是只想函数的指针，因此实例对象就共享了全局作用域中的同一个showName函数，但是存在一个新的问题，全局作用域的函数，却只能被某个对象调用，这在全局作用域下有点不太优雅，还有就是万一有很多的方法，那就需要在全局作用域下定义很多方法。所以就有更好的方法来啦</p>
</li>
</ul>
</li>
<li><p>原型模式<br> javascript规定每个函数都有一个prototype(原型属性)，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。也就是说prototype就是通过调用构造函数而创建的那个对象实例的原型对象。说了半天也没明白是啥 哈哈哈 看看代码吧</p>
<ul>
<li><p>弥补构造函数的缺点</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();  <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();  <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>理解原型对象</p>
<ol>
<li>只要创建了一个新的函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。所有的原型对象都会自动获得一个constructor(指向构造函数)的属性，就拿前边的栗子来说Person.prototype.constructor指向Person。<br>只要通过调用构造函数创建一个实例后，该实例的内部将包含一个指针(内部的属性)，指向构造函数的原型对象。这个指针叫[[ Prototype ]] (<strong>protp</strong>)。明确最重要的一点就是这个链接存在于实例和构造函数的原型对象之间。来看一个关系图<br><img src="https://s1.ax1x.com/2020/07/21/UoGoid.png" alt></li>
<li><p>isPrototypeOf():[[ Prototype ]]在现实中都无法访问到，但是通过isPrototypeof()来确定对象之间是否存在这种关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.isPrototypeof(person1);  <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeof(person2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getPrototypeOf():Object.getPrototypeOf()返回[[ Prototype ]]的值。</p>
</li>
<li>如何进行搜索某个属性:<br>首先:从实例本身开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值；没有找到进行下一步<br>然后:继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回属性的值。<br>当实例属性和原型对象的属性相同时，只会返回这个实例中的值</li>
<li><p>hasOwnProperty():用于检测一个属性是存在于实例中还是存在于原型中，只有在给定的属性存在于对象实例中时，才会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)) <span class="comment">// false</span></span><br><span class="line">person1.name =<span class="string">"Greg"</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.name);</span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型与in操作符<br>由于hasOwnProperty(),只能确定在实例中存在的时候才返回true，但是在没有该属性或者在原型中存在的时候则否返回false，那么如何判定属性在原型中呢？in操作符理解你的困扰，in操作符号可以判断属性无论在实例中还是在原型中都返回true的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过定义这个函数就能判定属性存在与原型中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span> (<span class="params">object,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name)&amp;&amp;(name <span class="keyword">in</span> object)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.keys():该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.sayName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line">alert(keys);  <span class="comment">// "name,age,job,sayName"</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"Rob"</span>;</span><br><span class="line">person1.age = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> p1keys =<span class="built_in">Object</span>.keys(person1);</span><br><span class="line">alert(p1keys);  <span class="comment">// "name,age"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更简单的原型语法<br>大家可能注意到了，上边的栗子中，每添加一个属性就要敲一遍Person.prototype。那肯定有更简单的写法吧,但是可以观察到下边的写法，Person.prototype 等于一个新的对象。造成了constructor不再指向Person了，本质上相当于重写了默认的prototype对象,如果constructor很重要，那就手动设置一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype =&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person, // 手动设置一下</span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型的动态性<br>由于在原型中查找过程是一次一次的查找，因此我们在原型中修改的内容立马会在实例中体现出来–即使先创建了实例后修改了原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">friend.sayHi();  <span class="comment">// "hi" 不会报错</span></span><br></pre></td></tr></table></figure>
<p>尽管可以随时为原型添加属性和方法，但是重写原型对象就不同了，当我们调用构造该函数时会为实例添加一个最初原型的[[ Prototype ]]指针，如果完全修改了原型那就切断了两者的联系<br><img src="https://s1.ax1x.com/2020/07/22/U7WC5Q.png" alt></p>
</li>
<li>原生对象的原型<br>原生引用类型（Object、Array、String…）都在其构造函数的原型上定义了方法。比如Array.prototype中可以找到sort方法（我们现在所有直接调用的方法，其实都写在原型对象中）；</li>
<li>原型对象也有问题<br>可以翻一翻我们上边的构造函数，小船别翻啊哈哈哈，都可以在函数中进行参数的传递，但是原型对象中并不能进行参数的传递。第二个重大的问题是，原型中的属性被很多实例共享，这种共享对于函数非常合适，但是那些包含引用类型值的属性来说，问题就比较大了。下面的例子要是我想有个自己全部属性怎么办？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Person.prototype =&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person, </span><br><span class="line">    name:"Nicholas",</span><br><span class="line">    age:29,</span><br><span class="line">    friends:["Shelby","Count"],</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">// "Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">// "Shelby,Count,Van"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>组合使用构造函数模式和原型模式<br> 解决单独使用原型模式，而导致的共享的属性，不能拥有自己的实例属性副本</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age= age; <span class="comment">// 想要独有的属性都放在构造函数里边 </span></span><br><span class="line">    <span class="keyword">this</span>.showName = showName;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype =&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Person, </span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">// "Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">// "Shelby,Count"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态原型模式<br> 动态原型模式致力于吧所有信息封装在构造函数里边，而通过构造函数中初始化原型，又保持了同时使用构造函数和原型的优点，换句话说就是，可以通过检查某个应该存在 的方法是否有效，来决定是否需要初始化原型。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age= age; </span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)&#123;</span><br><span class="line">      Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          alert(<span class="keyword">this</span>.name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生构造函数模式<br> 这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子。除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p> 这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加值</span></span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>稳妥构造函数模式<br> 在了解稳妥构造函数模式之前，先了解下稳妥对象这个概念。稳妥对象指没有公共属性，而且其他方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有亮点不同：一是新创建对象的实例方法不引用this;二是不使用new操作符调用构造函数。如：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建要返回的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = Persion(<span class="string">'bill'</span>, <span class="number">23</span>, <span class="string">'FE'</span>);</span><br><span class="line">p1.sayName() <span class="comment">// bill;</span></span><br></pre></td></tr></table></figure>
<p> 以上代码变量p1中保存的是一个稳妥对象，而除了调用sayName()外，没有别的方式可以访问其他数据成员。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象基本</tag>
        <tag>对象属性</tag>
        <tag>函数对象和普通对象</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期理解</title>
    <url>/2018/07/27/lifecycle/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfbmEF.jpg" alt="WeiChang Autumn senery"></p>
<blockquote>
<p>用了一段时间的Vue，当然还处于初级小白，对一些基本的东西还是不太了解，首先应该就说Vue的生命周期(钩子)，不明白这个估计在以后会踩好多的坑，所以今天去度娘上搜了好多文章。</p>
</blockquote>
<h3 id="1-话不多说上来先Po一张图"><a href="#1-话不多说上来先Po一张图" class="headerlink" title="1. 话不多说上来先Po一张图"></a>1. 话不多说上来先Po一张图</h3><center><br><img src="http://wx1.sinaimg.cn/mw690/005N9IKrly1fto7b92bmxj309j0m8wg6.jpg" alt="avatar"><br></center>

<h3 id="2-Lifecycle-Hooks"><a href="#2-Lifecycle-Hooks" class="headerlink" title="2. Lifecycle Hooks"></a>2. Lifecycle Hooks</h3><table>
<thead>
<tr>
<th>Vue2.0</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforeCreate</td>
<td>组件实例刚被创建，组件属性计算之前，比如data属性</td>
</tr>
<tr>
<td>created</td>
<td>组件实例创建完成，属性已经绑定，但DOM还未生成，$el属性还不存在</td>
</tr>
<tr>
<td>beforeMount</td>
<td>模板编译/挂载之前</td>
</tr>
<tr>
<td>mounted</td>
<td>模板编译/挂载之后</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件更新之前,数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</td>
</tr>
<tr>
<td>updated</td>
<td>组件更新之后</td>
</tr>
<tr>
<td>activated</td>
<td>for keep-alive，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>for keep-alive，组件被移除时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody>
</table>
<h3 id="3-废话不多说Po代码吧！！！"><a href="#3-废话不多说Po代码吧！！！" class="headerlink" title="3. 废话不多说Po代码吧！！！"></a>3. 废话不多说Po代码吧！！！</h3><ul>
<li>先说创建和挂载如下图   （注意标注）<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            msg: <span class="string">'this is yuhior Blog'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeCreate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.group(<span class="string">'beforeCreate组件实例刚被创建，属性计算前--------&gt;'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.group(<span class="string">'created 创建完毕,--------&gt;'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.group(<span class="string">'beforeMount挂载之前--------&gt;'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.group(<span class="string">'mounted挂载之后--------&gt;'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/20/UfbVBT.jpg" alt="avatar"></p>
<ul>
<li>在看组件更新   （这里我们在 chrome console里执行以下命令）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</span></span><br><span class="line">beforeUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'beforeUpdate组件更新前--------&gt;'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'真实dom结构：'</span> + <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'updated 更新完成状态--------&gt;'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'真实dom结构：'</span> + <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.msg= <span class="string">'我是更新'</span>; <span class="comment">//效果如下</span></span><br></pre></td></tr></table></figure>
<p><img src="http://wx1.sinaimg.cn/mw690/005N9IKrly1ftoggagulvj30id0azt8x.jpg" alt="avatar"></p>
<ul>
<li>最后就是销毁了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">beforeDestory: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'beforeDestory 组件销毁之前--------&gt;'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">destoryed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.group(<span class="string">'beforeDestory 组件销毁之后--------&gt;'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> beforeDestory：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。</p>
<p>destoryed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p><strong>注意：vue2.0之后主动调用$destroy()不会移除dom节点，不推荐直接destroy这种做法，如果实在需要这样用可以在这个生命周期钩子中手动移除dom节点</strong></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Linux之一</title>
    <url>/2019/12/25/linux-publish/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfH40O.jpg" alt=" 2020第一场雪 "></p>
<blockquote>
<p>好久没有更新自己的博客了，也说明自己在这几个月的时间没有怎么学习，主要吧事情真的很多(强行狡辩)，不过虽然技术没有增长太多，但是还是有很多的收获的，今年好像对新年没有太多的概念，但是深切的感觉到这一年又过去了，所以啊，想抓住这一年的尾巴，抽一下自己哈哈哈哈。</p>
</blockquote>
<h4 id="一、Linux服务器介绍及购买"><a href="#一、Linux服务器介绍及购买" class="headerlink" title="一、Linux服务器介绍及购买"></a>一、Linux服务器介绍及购买</h4><ul>
<li><p>​    linux服务器介绍</p>
<p>对于linux服务器本人也知之甚少，作为一个前端菜鸟贼喜欢折腾的我，自己的服务器到期了，然后就续费被，然后就续了个linux，至于为什么要买linux系统呢？哈哈哈，我也不知道。只是听朋友说好，就这么简单。不过还是简单说一下相对于window服务器的可视化界面，linux命令行好像更符合程序员，毕竟大多程序员都喜欢带你装*带你飞（开玩笑别打我哈！！！），linux系统应该是通过一系列命令行来进行操作，这就是我对它最表面的看法。</p>
<ol>
<li>最稳定：使用Linux服务器是有意义的，因为它被认为是当今市场上最稳定的平台。您不必担心重新启动系统或不断下载更新。</li>
<li>性能佳：Linux也因其目前可用的任何服务器的最佳性能而闻名。使用Linux，您可以让大量用户在同一服务器上工作而不会出现任何问题。它也是用于网络目的的理想服务器。</li>
<li>多任务处理能力：使用Linux服务器时，您还可以执行多任务。众所周知，Linux能够处理同时运行的许多不同程序。对于其他操作系统，当您打开其他内容时，他们可能会将某些程序置于“睡眠模式”。</li>
<li>灵活性高：在Linux的平台被称为是非常灵活，适用于多种不同的情况。由于它来自开源程序，程序员可以根据您的需要进行自定义。凭借这种灵活性，它还使平台更加安全。</li>
</ol>
</li>
<li><p>购买</p>
<p>本人是购买的阿里云的服务器，其他服务器自行查询购买，直接进阿里云官方，直接选云服务器ECS，看需要进行购买，我的是CPU：两核，内存 4G，操作系统： CentOS 7.7 64位，然后买就完事了。</p>
</li>
</ul>
<h4 id="二、部署web网站"><a href="#二、部署web网站" class="headerlink" title="二、部署web网站"></a>二、部署web网站</h4><ul>
<li><p>部署FTP</p>
<p>有了Linux服务器是不是感觉不知所措不知道干什么，停下来想一想，在我们平常工作的时候网站运行的时候都需要什么？这其实就好比你在做饭之前，需要想好都需要什么食材，虽然我做的饭很难吃（还被某人说过菜的长相贼丑，黑乎乎啥也看不出……..）,回到正题是不是需要MySQL、web服务环境、FTP等各种工具。</p>
<hr>
<ol>
<li><p>Centos7 FTP安装与部署</p>
<ul>
<li><p>FTP安装包下载及安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y vsftpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">systemctl stop vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">systemctl status vsftpd.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置FTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置 12 行</span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置 33 行</span></span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置48行</span></span><br><span class="line">chown_uploads=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置72行</span></span><br><span class="line">async_abor_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置82行</span></span><br><span class="line">ascii_upload_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置83行</span></span><br><span class="line">ascii_download_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置86行</span></span><br><span class="line">ftpd_banner=Welcome to blah FTP service.</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置100行</span></span><br><span class="line">chroot_local_user=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加下列内容到vsftpd.conf末尾</span></span><br><span class="line">use_localtime=YES</span><br><span class="line">listen_port=21</span><br><span class="line">idle_session_timeout=300</span><br><span class="line">guest_enable=YES</span><br><span class="line">guest_username=vsftpd</span><br><span class="line">user_config_dir=/etc/vsftpd/vconf</span><br><span class="line">data_connection_timeout=1</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">pasv_min_port=40000</span><br><span class="line">pasv_max_port=40010</span><br><span class="line">accept_timeout=5</span><br><span class="line">connect_timeout=1</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立用户文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建编辑用户文件</span></span><br><span class="line">vim /etc/vsftpd/virtusers</span><br><span class="line"><span class="comment">#第一行为用户名，第二行为密码。不能使用root作为用户名 </span></span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成用户数据文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定PAM验证文件，并指定对虚拟用户数据库文件进行读取</span></span><br><span class="line"></span><br><span class="line">chmod 600 /etc/vsftpd/virtusers.db</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改/ect/pam.d/vsftpd  文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改前先备份 </span></span><br><span class="line"></span><br><span class="line">cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak</span><br><span class="line"></span><br><span class="line">vi /etc/pam.d/vsftpd</span><br><span class="line"><span class="comment">#先将配置文件中原有的 auth 及 account 的所有配置行均注释掉</span></span><br><span class="line">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers </span><br><span class="line">account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果系统为32位，上面改为lib</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建系统用户vsftpd，用户目录为/home/vsftpd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户登录终端设为/bin/false(即：使之不能登录系统)</span></span><br><span class="line">useradd vsftpd -d /home/vsftpd -s /bin/<span class="literal">false</span></span><br><span class="line">chown -R vsftpd:vsftpd /home/vsftpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立虚拟用户个人配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/vsftpd/vconf</span><br><span class="line"><span class="built_in">cd</span> /etc/vsftpd/vconf</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里建立虚拟用户leo配置文件</span></span><br><span class="line">touch admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑leo用户配置文件，内容如下，其他用户类似</span></span><br><span class="line">vi admin</span><br><span class="line"></span><br><span class="line">local_root=/home/vsftpd/leo/</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立leo用户根目录</span></span><br><span class="line">mkdir -p /home/vsftpd/leo/</span><br></pre></td></tr></table></figure>
</li>
<li><p>防火墙设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IPtables 的设置方式：</span><br><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line"><span class="comment">#编辑iptables文件，添加如下内容，开启21端口</span></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 40000:40010 -j ACCEPT</span><br><span class="line"></span><br><span class="line">firewall 的设置方式：</span><br><span class="line">firewall-cmd --zone=public --add-service=ftp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=40000-40010/tcp --permanent</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启vsftpd服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Centos7 FTP连接</p>
<ul>
<li><p>这个时候，使用ftp的工具连接时，我们发现是可以连接的。传输文件的时候，会发现文件上传和下载都会出现500、503 、200等问题。这个时候，可以进行以下三种操作：</p>
<ul>
<li><p>关闭SELINUX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开SELINUX配置文件</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置参数</span></span><br><span class="line"><span class="comment">#注释  </span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加  </span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改完成后，需要重启！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改SELINUX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0 <span class="comment">#暂时让SELinux进入Permissive模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与ftp相关的设置</span></span><br><span class="line">getsebool -a|grep ftp</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是显示出来的权限，off是关闭权限，on是打开权限。不同的机器显示的可能不一样。我看了我的显示的，和网上其他教程就不太一样</span></span><br><span class="line">ftp_home_dir --&gt; off</span><br><span class="line">ftpd_anon_write --&gt; off</span><br><span class="line">ftpd_connect_all_unreserved --&gt; off</span><br><span class="line">ftpd_connect_db --&gt; off</span><br><span class="line">ftpd_full_access --&gt; off</span><br><span class="line">ftpd_use_cifs --&gt; off</span><br><span class="line">ftpd_use_fusefs --&gt; off</span><br><span class="line">ftpd_use_nfs --&gt; off</span><br><span class="line">ftpd_use_passive_mode --&gt; off</span><br><span class="line">httpd_can_connect_ftp --&gt; off</span><br><span class="line">httpd_enable_ftp_server --&gt; off</span><br><span class="line">sftpd_anon_write --&gt; off</span><br><span class="line">sftpd_enable_homedirs --&gt; off</span><br><span class="line">sftpd_full_access --&gt; off</span><br><span class="line">sftpd_write_ssh_home --&gt; off</span><br><span class="line">tftp_anon_write --&gt; off</span><br><span class="line">tftp_home_dir --&gt; off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将包含有 ftp_home_dir 和 ftpd_full_access 相关的都设置为 1</span></span><br><span class="line"></span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line">setsebool -P allow_ftpd_anon_write 1</span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line"></span><br><span class="line">setenforce 1 <span class="comment">#进入Enforcing模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SELINUX不对vsftp不做任何限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsebool -P ftpd_connect_all_unreserved 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Node.js安装</p>
<ol>
<li><p>去官网复制安装包信息</p>
<p>[<a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">http://nodejs.cn/download/]</a>: </p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfHjnf.jpg" alt></p>
</li>
<li><p>使用xshell（推荐）或者putty连接你的Linux，在xshell里cd到安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入命令连接开始下载node.js安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/v12.14.1/node-v12.14.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xz -d node-v10.16.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v10.16.0-linux-x64.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p>重命名解压文件夹名称为nodejs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv node-v10.16.0-linux-x64 nodejs</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入解压目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nodejs</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/local/nodejs/bin/node /usr/local/bin/node</span><br><span class="line">ln -s  /usr/local/nodejs/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试node是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装cnpm淘宝镜像并创建软连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment">#检查安装成功是否通过</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用express或者koa或egg搭建web服务环境请见《初识Linux之二》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>node项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Linux之二</title>
    <url>/2020/01/15/linux-publish2/</url>
    <content><![CDATA[<blockquote>
<p>2020年了，这是今年的第一篇，希望新的一年有新的开始，并希望你们像我一样越来越优秀哈哈哈，临近新年过年的气息也越来越浓郁，自己也期盼过年回家呀，临近年底项目还是无情的一如既往的压榨着我们，忙的手忙脚乱的（菜鸟专属毕竟大佬们可都是临危不乱的），某人鼓励我坚持写博客，我也重拾起写博客的习惯，坚持学习，坚持记录，毕竟这是一个记录成长的过程。2020少皱眉多微笑。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/07/20/Uf4WXF.jpg" alt="GUOMAO Night"></p>
<p>上回书说道，张飞张翼德驾马来到曹操营前，大声骂道，曹操…..,停停停不好意思走错频道了，一看就不是个正经写记录的哈哈哈，上篇文章我们讲了Linux下的FTP安装配置还有Linux下安装node.js ，那今天我们就说Linux下使用Express搭建web服务把，如果你想用koa或者egg，不好意思哈，你问下度娘告不告诉你哈。开始吧。</p>
<ul>
<li><p>Linux下用Express搭建web服务器（其实和本地搭建没什么区别）</p>
<ol>
<li><p>先连接上我们的服务器把，启动xshell，输入用户名和密码连接上服务器。</p>
</li>
<li><p>cd到指定目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /var/www/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建web服务项目文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入项目目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地下的项目安装express模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g express express-generator</span><br><span class="line">express ***（项目名）--hbs （模板引擎）</span><br><span class="line">#cd 项目文件下</span><br><span class="line">#安装依赖</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目打包，将打包好的如vue的dist文件放进var/www/demo文件夹下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用FTP进行上传</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>你会发现你访问你的服务器ip加端口时会访问的到，但是关闭了，服务器这个也关闭了。下面将应对方法</p>
</li>
</ol>
</li>
<li><p>安装PM2托管Node Web服务程序</p>
<ol>
<li><p>安装pm2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建软连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/nodejs/bin/pm2 /usr/local/bin/pm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动托管命令，输入下面的命令启动托管任务，<code>abc</code>为托管项目定义的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --name abc</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>node项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb + node + vue 实现前后台分离</title>
    <url>/2020/08/31/mongodb/</url>
    <content><![CDATA[<blockquote>
<p>八月的前奏就是狮子座，那八月的尾巴还是处女座嘞，今天是八月的最后一天，决定在自己脑子清醒的时候，抓住八月的尾巴，抓紧时间写一篇经典有用瞎折腾的博客，最近可真的是太忙啦，从上篇文章的朋友结婚，到接老妈来京，再到青海之游，再到朋友周末来访，简直安排的满满。不过真的很充实。有的朋友就该问了，朋友结婚你瞎忙什么啊，哈哈哈哈哈别瞎想啊，俺可是伴郎团内的颜值担当呦。不像别人说就我怎么也能当伴郎？？？我也是满脸问号啦！还有出去游玩虽然感冒，虽然第一天天公不作美，虽然很冷，有那么虽然，但是我们很开心，终于没有留下遗憾。目前就是希望时间慢一些慢一些慢一些……好了废话不说了，最近偷功夫赶紧折腾一下吧。sql学习不知道成本有多大，但是还是不想走常规之路，我想搞一下mongodb，先牛刀小试一把，打算用mongodb+ node +vue 搞个登陆的小demo。来吧，展示！</p>
</blockquote>
<ul>
<li><h4 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a>mongodb安装</h4><ol>
<li><p>手动mac安装mongodb </p>
<p>手动安装mongodb 去某度上一搜一大把，这个我不想多提，按照上边写的一步一步来就行了。</p>
</li>
<li><p>brew安装mongodb</p>
<p>用brew安装mongodb可是走了一个大坑</p>
<ul>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install mongodb</span><br></pre></td></tr></table></figure>
<p>结果报错，找不到mongodb，网上需找原因，<code>MongoDB</code>不再开源，不能用上面的命令直接安装了，不过还是可以用<code>brew</code>安装的</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br><span class="line">brew install mongodb-community@4.4</span><br></pre></td></tr></table></figure>
<p>安装成功了，启动和停止服务</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start mongodb-community</span><br><span class="line">brew services stop mongodb-community</span><br></pre></td></tr></table></figure>
<p>配置文件路径：<code>/usr/local/etc/mongod.conf</code><br> log文件路径：<code>/usr/local/var/log/mongodb/mongo.log</code><br> data目录路径：<code>/data/db</code><br> bin目录路径：<code>/usr/local/Cellar/mongodb-community/4.2.6/bin</code></p>
</li>
<li><p>值得注意的是，使用<code>brew</code>安装MongoDB不需要添加<code>PATH</code>环境变量，通过<code>brew</code>安装的软件，默认安装在<code>/usr/local/Cellar/</code>目录下，执行<code>brew list</code> 可以查看所有通过<code>brew</code>安装的软件：</p>
</li>
</ul>
</li>
<li><p>设置账号和密码</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs   //查看所有数据库</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin  // 进入admin数据库，安装完mongodb初始有一个System和一个congfig数据库</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123; user: &quot;admin&quot;, pwd: &quot;password&quot;, roles: [&#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125;] &#125;)</span><br><span class="line">// 创建管理员账户，mongodb中的用户是基于身份role的，该管理员账户的 role是 userAdminAnyDatabase。admin用户用于管理账号，不能进行关闭数据库等操作。</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;user: &quot;root&quot;,pwd: &quot;password&quot;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ]&#125;)</span><br><span class="line">//创建完admin管理员，创建一个超级管理员root。角色：root。root角色用于关闭数据库。</span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use yourdatabase  //进入你自己的数据库</span><br><span class="line">db.createUser(&#123;user: &quot;user&quot;,pwd: &quot;password&quot;,roles: [ &#123; role: &quot;dbOwner&quot;, db: &quot;yourdatabase&quot; &#125; ]&#125;)</span><br><span class="line">//role: &quot;dbOwner&quot;代表数据库所有者角色，拥有最高该数据库最高权限。比如新建索引等当账号管理员和超级管理员，可以为自己的数据库创建用户了。（坑）这时候一定，一定要切换到所在数据库上去创建用户，不然创建的用户还是属于admin。</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(&quot;admin&quot;,&quot;password&quot;)</span><br><span class="line">//删除单个用户</span><br><span class="line">db.system.users.remove(&#123;user:&quot;XXXXXX&quot;&#125;)</span><br><span class="line">//删除所有用户</span><br><span class="line">db.system.users.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>连接mongodb数据库</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo  // 坑坑坑 找了好久的网上说的命令，最后还是的自己看英文的文档，还是英文文档比较靠谱</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use xxx    数据名</span><br><span class="line">switched to db xxx </span><br><span class="line">&gt; db</span><br><span class="line">xxx</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs</span><br><span class="line">// 可以看到并没有新建的数据库</span><br><span class="line">// 新建的数据库需要向新建的数据库中插入数据才能显示出来</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.xxx.insert(&#123;&quot;name&quot;:&quot;yuhior&quot;&#125;)   //</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可视化工具Robo T3  这个有点类似于mysql 的可视化工具navact，其实也没有什么就是可以看到数据</p>
<p><img src="https://s1.ax1x.com/2020/08/31/dOiWbF.png" alt></p>
</li>
</ol>
</li>
<li><h4 id="node连接mongodb"><a href="#node连接mongodb" class="headerlink" title="node连接mongodb"></a>node连接mongodb</h4><ol>
<li><p>安装node 吧我使用的koa2的脚手架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建项目文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">koa2 --hbs koa2-zcls   // handlebars 模版</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>目录结构 自己增加一个db文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--bin</span><br><span class="line">	--www</span><br><span class="line">--db</span><br><span class="line">	--db.js</span><br><span class="line">	--index.js</span><br><span class="line">--node_modules</span><br><span class="line">--public</span><br><span class="line">	--images</span><br><span class="line">	--javascripts</span><br><span class="line">	--stylesheets</span><br><span class="line">--routes</span><br><span class="line">	--index.js</span><br><span class="line">	--users.js</span><br><span class="line">--views</span><br><span class="line">	--error.hbs</span><br><span class="line">	--index.hbs</span><br><span class="line">	--layout.hbs</span><br><span class="line">--app.js</span><br><span class="line">package.json</span><br><span class="line">package-lock.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mongoose进行数据库连接</p>
<p>安装mongoose库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mongoose --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>db目录下db.js上代码 先导出mongoose扩展模块 ，该模块进行连接数据库 连接异常 断开连接等扩展</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="keyword">const</span> DB_URL = <span class="string">'mongodb://localhost:27017/myBlog'</span></span><br><span class="line"></span><br><span class="line">mongoose.connect(DB_URL)</span><br><span class="line"></span><br><span class="line">mongoose.connection.on(<span class="string">'connected'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose connection open to '</span> + DB_URL);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接异常error 数据库链接错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">mongoose.connection.on(<span class="string">'erroe'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose connection disconnected'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接断开disconnected 连接异常断开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mongoose.connection.on(<span class="string">'disconnected'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose</span><br></pre></td></tr></table></figure>
</li>
<li><p>db的index.js ，定义查询和保存方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'./db'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; model ,Schema&#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">//const Schema = mongoose.Schema;</span></span><br><span class="line"><span class="keyword">const</span> ceshiSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">    body:<span class="built_in">String</span>,</span><br><span class="line">    date:<span class="built_in">Date</span></span><br><span class="line">&#125;,&#123; <span class="attr">collection</span>: <span class="string">'ceshi'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'ceshi'</span>, ceshiSchema);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mongodb</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询</span></span><br><span class="line">    query () &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            MyModel.find(&#123;&#125;,(err,res)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    save(obj)&#123;</span><br><span class="line">        <span class="keyword">const</span> m = <span class="keyword">new</span> MyModel(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            m.save(<span class="function">(<span class="params">err,res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(res)</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Mongodb()</span><br></pre></td></tr></table></figure>
</li>
<li><p>routes/index.js中进行定义接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ModelDb  = <span class="built_in">require</span>(<span class="string">'./../db'</span>);</span><br><span class="line">outer.get(<span class="string">'/mongotest'</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> ModelDb.query()</span><br><span class="line">  ctx.body = data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/08/31/dODf58.png" alt></p>
</li>
</ol>
</li>
<li><h4 id="欲知后事如何且听先回分解-下一章应该会讲vue请求弄的接口，功力不够还需要来回折腾啊，和自己性格一样想走就走想做就做。"><a href="#欲知后事如何且听先回分解-下一章应该会讲vue请求弄的接口，功力不够还需要来回折腾啊，和自己性格一样想走就走想做就做。" class="headerlink" title="欲知后事如何且听先回分解 下一章应该会讲vue请求弄的接口，功力不够还需要来回折腾啊，和自己性格一样想走就走想做就做。"></a>欲知后事如何且听先回分解 下一章应该会讲vue请求弄的接口，功力不够还需要来回折腾啊，和自己性格一样想走就走想做就做。</h4></li>
</ul>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程二之继承</title>
    <url>/2020/08/07/inherited2/</url>
    <content><![CDATA[<blockquote>
<p>今日阳光明媚，今日多云转晴，我的心情从晴天一下子就多云啦，为什么呢这是，因为我找到我姥爷啦… 。鸭蛋不差钱上的经典语录，我还是以一个欢快的语句入场。在这两章一直在讲面向对象面向对象，也不知道面向了个啥，最后没有面着对象只能面着自己啦哈哈哈，虽然现实中没面成也可能你抓不住身边的目标，但是js里边的对象可是只要你想就可以抓的住的，这可是稳扎稳打这波绝对不亏的啊。穿过西风与山河，安知甜与乐。毕竟这是学习的天地，这里只有未来的梦想和你想成为的那个人，还有诗和远方。今天我们就来讲讲面向对象中的继承吧，也不知道js为什么要从对象中继承，不是应该从老爹继承嘛，哈哈哈，管它呢先码了再说，还是那句话，本人菜鸟望大佬们轻喷。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>   大家应该都知道OO语言中的最为人津津乐道的东西就是继承了吧，不服来辩哈哈哈，那么今天就来看看js是怎么实现继承的呢？</p>
<ol>
<li><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul>
<li><p>原型链</p>
<p>  简单回顾一下构造函数、原型、实例的关系：每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果让原型对象等于另一个类型的实例，那此时原型对象将包含一个指向另一个原型的指针，相应的另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例呢，那么上述关系依然成立。那这就好玩了呀，就像你让你条蛇咬住另一条蛇的尾巴，下一条又咬住另一条的尾巴….,那这就成了啊，原型链。先看看代码和图吧，毕竟oppoR50000s 让你的思路更清晰 哈哈哈。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty  =<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line">SubType.prototype =  <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype .getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert (instance.getSuperValue()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/08/07/aWG21s.png" alt></p>
<p>要注意此时的instance.constructor 现在指向的是SuperType ，这是因为原来SubType.prototype中的constructor被重写了的缘故。</p>
<p>调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例;2)搜索SubType.prototype; 3)搜索SuperType.prototype,最后这一步菜找到该方法。就是一层一层往上找呗。</p>
</li>
<li><p>默认原型</p>
<p> 别忘了咱们所有的引用类型都继承了Object，在使用所有的引用类型时，不是一般都有什么tostring方法、valueOf方法，那它们哪里来的啊，不可能和孙悟空一样凭空一样吧？哦不，不是凭空是仙石孕育而生吧？？哈哈哈那是不存在的吧，他们都是通过继承而来，这个继承也是通过原型链实现的，所以记住所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也是所有自定义类型都会继承tostring()、valueOf()的根本原因。</p>
<p><img src="https://s1.ax1x.com/2020/08/07/aWdi8S.png" alt></p>
</li>
<li><p>确定原型和实力的关系</p>
<p>如何确定原型和实例之间的关系，上边的原型链我们也看到了，多乱的关系啊，那不得有个方法能确定确定实例和原型的关系嘛</p>
<ul>
<li><p>instanceof 可以测试实例原型链中出现过的构造函数，结果就会返回true。由于原型链的关系，我们可以说instance是Object 、SuperType或者SubType中任何类型的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">// true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>isPrototypeOf()方法，同样的只要原型链中出现过的原型，都可以说是该原型链所派生的实例的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">// true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">// true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>谨慎定义方法</p>
<p>子类型有时候需要覆盖超类中的某个方法，或者需要添加超类型中不存在的方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property =<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype =  <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 添加新的方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><em>注意问题：</em>在通过原型链实现继承的时候，不能使用对象自变量(重新写了)创建原型方法。因为这样就重写了原型链，此时原型链就会被切断，两个类之间也就没有什么关系了</p>
</li>
<li><p>原型链问题</p>
<ul>
<li><p>原型链虽然很强大，可以用来实现继承，但是也存在问题，不存在问题怎么会有更好的出现呢？是吧？最最主要的就是太能吃哈哈哈，开玩笑的啊 ，最主要的问题就是包含引用值的原型属性会被所有实例共享；原型链中一个原型变成另一个类型的实例，于是也就顺理成章的实现了现在的原型的属性啦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">// red,blue,green, black</span></span><br><span class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">alert(instance2.colors); <span class="comment">// red,blue,green, black</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上应该说没有办法在不影响所有对象实例的情况下，给超类传递参数。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><ul>
<li><p>这种技术的主要思想非常简单，就是在子类型构造函数的内部调用超类型构造函数。函数只不过是再特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数,代码借调了超类型的构造函数，通过call（）方法（或apply（）方法也可以）实际就是在新创建的SubType的实例环境中调用了SuperType构造函数。这样在新的SubType对象上执行SuperType（）函数中定义的所有对象初始化代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors= [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">// red,blue,green, black</span></span><br><span class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> Subtype();</span><br><span class="line">alert(instance2.colors); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SuperType，同时还传递了参数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>,<span class="string">"Nicholas"</span>);</span><br><span class="line">  <span class="comment">//实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.age =<span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);  <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(instance.age);    <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>该模式存在的问题</p>
<p>该模式存在的问题其实和构造函数存在的问题一样，方法都是在构造函数中定义，因此函数复用就无从谈起来，因为在每次进行new 实例的时候 就相当于拷贝了一份构造函数的方法，方法多了那内存也就相当大了。</p>
</li>
</ul>
</li>
<li><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><ul>
<li><p>它来了它来了，它带着绝招走来了，组合继承是当前最常用的继承方式，指的就是将原型链和借用构造函数的技术组合到一起。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors= [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.protptype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>,name);</span><br><span class="line">  <span class="keyword">this</span>.age =age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor =SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>,<span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">// red,blue,green, black</span></span><br><span class="line">instance1.sayName();  <span class="comment">//Nicholas</span></span><br><span class="line">instance1.sayAge();  <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>,<span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">// red,blue,green</span></span><br><span class="line">instance2.sayName(); <span class="comment">//Greg</span></span><br><span class="line">instance2.sayAge();  <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><ul>
<li><p>用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了可以随意添加属性的实例或对象。object.create()就是这个原理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">"Nicholas"</span>,</span><br><span class="line">    friends:[<span class="string">"Shelby"</span>,<span class="string">"Court"</span>,<span class="string">"Vant"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup1=object(person);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：类似复制一个对象，用函数来包装。</p>
</li>
<li><p>缺点：1.所有实例都会继承原型上的属性。2.无法实现复用。(新实例的属性都是后面添加)</p>
</li>
</ul>
</li>
<li><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><ul>
<li><p>给原型式继承外面套个壳子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = obj; <span class="comment">// 继承了传入的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();  <span class="comment">// 返回函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup1=object(person);</span><br><span class="line"><span class="comment">// 以上是原型式继承，给原型式继承在涛哥壳子传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subobject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sub = object(obj);</span><br><span class="line">  sub.sayHi= <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">return</span> sub</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup2 = subobject(person);</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点： 没有创建自定义类型，因为只是套了个壳子返回对象，这个函数就顺理成章的创建了新的对象</p>
</li>
<li><p>缺点： 没用到原型，无法复用</p>
</li>
</ul>
</li>
<li><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><ul>
<li><p>前边说过组合继承是javascript中最常用的继承模式，不过它也有它的缺点的，毕竟嘛人无完人是吧？组合继承最大的问题就在于无论什么情况下，都会调用两次超类型的构造函数：依次是在创建子类型原型的时候，另一次是在子类型构造函数内,造成的结果就是有两组的name和colors属性一组是在实例上一组是在SubType的原型中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name =name;</span><br><span class="line">  <span class="keyword">this</span>.colors =[<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>,name); <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype =<span class="keyword">new</span> SuperType();<span class="comment">// 第一次调用</span></span><br><span class="line">SubType.protptype.construtor = SubType;</span><br><span class="line">SubType.protptype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/08/13/azy3gs.png" alt></p>
</li>
<li><p>寄生组合式继承那就来啦：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。基本思路就是：不必为了指定子类型的的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已，本质上就是使用寄生式继承来继承超类型的原型，然后在将结果指定给子类型的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType,superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor =subType; <span class="comment">// 增强对象</span></span><br><span class="line">  subType.prototype = prototype;  <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数内部，第一步创建超类型原型的一个副本，第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去默认的construtor属性，最后一步，将创建的对象（副本），赋值给子类型的原型。</p>
</li>
</ul>
<blockquote>
<p>这周事情比较多，趁着等着后台做接口的功夫，赶紧把未完成的东西写完，接口大佬还在睡觉，咱也不敢打搅哈哈哈，认真且怂，终于搞定了js对象，虽然感觉很是晦涩难懂，但还是啃了这块难啃的骨头，之后的知识应该是顺风顺水了吧，想多了哈哈哈，一想到乱七八糟的知识点怎么会那么容易，反正不管怎么样，盘它就完了。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象基本</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>vue + koa2 + mongodb 前后端分离登陆demo</title>
    <url>/2020/09/09/mongodb2/</url>
    <content><![CDATA[<blockquote>
<p>世界上最遥远的距离就是从星期一到星期五，Oh，boss我太困了，我需要休息。boss：下次吧！根据墨菲定律，人们通常下次吧的意思就是星期八可以让你休息。当然啦这是不能的，我们的boss 可不是这样的人，老板会说没事困了就play ping-pang吧 ，哈哈哈所以有了公司的乒乓球台，我也是满脸问号？？？，至于为什么今天才来吐槽，是因为今天路过看见长久不用的乒乓球桌在那静静的静静地在那睡觉，睡的多么香啊，好想和它一起哈哈哈哈。有人肯定要问了一个学习的博客天天开场乱七八糟的东西，那我就不客气啦，博客技术肯定是很正经啊，但是写博客的人正不正经别人不知道哇哈哈哈，好了闲话少说，我们上一篇讲了mongodb的搭建，这一篇讲一下vue + koa2 + mongodb 的前后端小demo的实践吧</p>
</blockquote>
<ol>
<li><h4 id="前端登陆页面的搭建"><a href="#前端登陆页面的搭建" class="headerlink" title="前端登陆页面的搭建"></a>前端登陆页面的搭建</h4><p>vue脚手架不用多说了吧？直接来一个项目结构，写一个前端登陆页面 ，话不多说上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router 的index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/Login'</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/login"</span>,</span><br><span class="line">    name: <span class="string">"Login"</span>,</span><br><span class="line">    component: Login</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/register"</span>,</span><br><span class="line">    name: <span class="string">"Register"</span>,</span><br><span class="line">    component: Register</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">"history"</span>,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Login.vue </span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;login_form_input&quot; label=&quot;用户&quot; style=&quot;margin-top: 58px;&quot;&gt;</span><br><span class="line">    &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;ruleForm.username&quot; placeholder=&quot;请输入用户名或手机号&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;login_form_input&quot; label=&quot;密码&quot; style=&quot;margin-bottom:7px ;&quot;&gt;</span><br><span class="line">    &lt;el-form-item prop=&quot;userpass&quot;&gt;</span><br><span class="line">      &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.userpass&quot; placeholder=&quot;请输入用户密码&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">  &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;login_btn&quot;&gt;</span><br><span class="line">    &lt;input class=&quot;login_submit&quot; type=&quot;button&quot; @click=&quot;submitForm(&apos;ruleForm&apos;)&quot; value=&quot;登录&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        username: &quot;&quot;,</span><br><span class="line">        userpass: &quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        username: [</span><br><span class="line">          &#123; required: true, message: &quot;用户名或手机号&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        userpass: [</span><br><span class="line">            &#123; required: true, message: &quot;请选择活动区域&quot;, trigger: &quot;change&quot; &#125;,</span><br><span class="line">            &#123; min: 6, max: 18, message: &quot;长度在 3 到 18 个字符&quot;, trigger: &quot;blur&quot; &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    async submitForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].validate(valid =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          // 点击登陆进行的提交 肯定会用axios  </span><br><span class="line">            this.$api.login(&#123;</span><br><span class="line">                username:this.ruleForm.username,</span><br><span class="line">                password:this.ruleForm.userpass</span><br><span class="line">            &#125;).then(res =&gt; &#123;</span><br><span class="line">                console.log(res);</span><br><span class="line">            &#125;).catch((err) =&gt; &#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="axios的二次封装"><a href="#axios的二次封装" class="headerlink" title="axios的二次封装"></a>axios的二次封装</h4><p>上边提到了使用axios进行请求，我们平常都是直接在组件中直接用axios进行请求，这样造成当我们需要修改某一个接口的时候需要去组件里边找，下面我们就对axios进行封装 </p>
<ul>
<li><p>目录结构</p>
<p>-src</p>
<p>​    – http</p>
<p>​        –api.js</p>
<p>​        –config.js</p>
<p>​        –index.js</p>
<p>​        –insterface.js</p>
</li>
<li><p>config.js : axios配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    method:<span class="string">'post'</span>,</span><br><span class="line">    <span class="comment">//基础url前缀</span></span><br><span class="line">    baseURL:<span class="string">'/api'</span>,</span><br><span class="line">    <span class="comment">//请求信息头</span></span><br><span class="line">    headers:&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>:<span class="string">'application/json;charset=UTF-8'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    <span class="comment">//设置超时时间</span></span><br><span class="line">    timeout:<span class="number">10000</span>,</span><br><span class="line">    <span class="comment">// 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">    withCredentilas:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">    responseType: <span class="string">'json'</span>, <span class="comment">// default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>api.js :具体封装 包含拦截、处理数据、返回服务器信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config'</span>  <span class="comment">//倒入默认配置</span></span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>  <span class="comment">//序列化请求数据，视服务端的要求</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./../router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">$axios</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">            baseURL: config.baseURL,</span><br><span class="line">            headers: &#123;&#125;,</span><br><span class="line">            transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data)</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//request 拦截器</span></span><br><span class="line">        instance.interceptors.request.use(</span><br><span class="line">            config =&gt; &#123;</span><br><span class="line">                <span class="comment">// Tip 1 ：请求开始的时候可以结合vuex开启全屏的loading动画</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Tip2 ：带上token ，可以结合vuex 或者重localStorage</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// if (store.getter.token) &#123;</span></span><br><span class="line">                <span class="comment">//     config.headers['X-Token'] = getToken() // 让每个请求携带token -- ['X-Token']为自定义key 请根据实际情况自行修改</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     重定向到登陆页面</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// Tip3 ：根据请求方法，序列化传过来的参数，根据后端需求是否序列化</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (config.method.toLocaleLowerCase() === <span class="string">'post'</span> || config.method.toLocaleLowerCase() === <span class="string">'put'</span> || config.method.toLocaleLowerCase() === <span class="string">'delete'</span>) &#123;</span><br><span class="line">                    config.data = qs.stringify(config.data)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> config</span><br><span class="line">            &#125;,</span><br><span class="line">            error =&gt; &#123; <span class="comment">// 请求错误时做些事(接口错误、超时等)</span></span><br><span class="line">                <span class="comment">// Tip: 4 关闭loadding  </span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'request:'</span>, error);</span><br><span class="line">                <span class="comment">//  1. 判断请求超时</span></span><br><span class="line">                <span class="keyword">if</span> (error.code === <span class="string">'ECONNABORTED'</span> &amp;&amp; error.message.indexOf(<span class="string">'timeout'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'根据你设置的timeout/真的请求超时 判断请求现在超时了，你可以在这里加入超时的处理方案'</span>)</span><br><span class="line">                    <span class="comment">// return service.request(originalRequest);//例如再重复请求一次</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. 需要重定向到错误页面</span></span><br><span class="line">                <span class="keyword">const</span> errorInfo = error.response;</span><br><span class="line">                <span class="built_in">console</span>.log(errorInfo);</span><br><span class="line">                <span class="keyword">if</span> (errorInfo) &#123;</span><br><span class="line">                    <span class="comment">// error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject</span></span><br><span class="line">                    <span class="keyword">const</span> errorStatus = errorInfo.status; <span class="comment">// 404 403 500 ... 等</span></span><br><span class="line">                    router.push(&#123;</span><br><span class="line">                        path: <span class="string">`/error/<span class="subst">$&#123;errorStatus&#125;</span>`</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);   <span class="comment">//在调用的那边可以拿到(catch)你想返回的错误信息</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// response 拦截器</span></span><br><span class="line"></span><br><span class="line">        instance.interceptors.response.use(</span><br><span class="line">            response =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> data;</span><br><span class="line">                <span class="comment">// IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串)</span></span><br><span class="line">                <span class="keyword">if</span> (response.data == <span class="literal">undefined</span>) &#123;</span><br><span class="line">                    data = response.request.responseText</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = response.data</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据返回的code 值来做不同的处理 和后端进行约定</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (data.code) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">''</span>:</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果不是正确的返回code ，且已经登陆，那就抛出错误</span></span><br><span class="line">                <span class="comment">// const err = new Error(data.description)</span></span><br><span class="line">                <span class="comment">// err.data = data</span></span><br><span class="line">                <span class="comment">// err.response = response</span></span><br><span class="line">                <span class="comment">// throw err</span></span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            &#125;,</span><br><span class="line">            error =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (error &amp;&amp; error.response) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (error.response.status) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                            error.message = <span class="string">'请求错误'</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">                            error.message = <span class="string">'未授权，请登录'</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                            error.message = <span class="string">'拒绝访问'</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                            error.message = <span class="string">`请求地址出错: <span class="subst">$&#123;error.response.config.url&#125;</span>`</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">408</span>:</span><br><span class="line">                            error.message = <span class="string">'请求超时'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                            error.message = <span class="string">'服务器内部错误'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">501</span>:</span><br><span class="line">                            error.message = <span class="string">'服务未实现'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">502</span>:</span><br><span class="line">                            error.message = <span class="string">'网关错误'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">503</span>:</span><br><span class="line">                            error.message = <span class="string">'服务不可用'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">504</span>:</span><br><span class="line">                            error.message = <span class="string">'网关超时'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">505</span>:</span><br><span class="line">                            error.message = <span class="string">'HTTP版本不受支持'</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.error(error)</span><br><span class="line">                <span class="comment">// 此处我使用的是 element UI 的提示组件</span></span><br><span class="line">                Message.error(<span class="string">`ERROR: <span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error) <span class="comment">// 返回接口返回的错误信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//请求处理 执行 instance 的方法</span></span><br><span class="line">        instance(options)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>interface.js :接口统一管理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'./api'</span>  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 讲所有接口统一起来管理</span></span><br><span class="line"><span class="comment"> * 如果项目很大可以将url 独立成文件，接口分成不同的模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function"><span class="params">params</span> =&gt;</span>&#123;  <span class="comment">// 其中的一个接口</span></span><br><span class="line">    <span class="keyword">return</span> axios(&#123;</span><br><span class="line">        url: <span class="string">'/mongotest'</span>,</span><br><span class="line">        method: <span class="string">'get'</span>,</span><br><span class="line">        params</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 注意post 请求啊，坑了我好久</span></span><br><span class="line"> <span class="comment">//const Register = params =&gt;&#123;</span></span><br><span class="line">   <span class="comment">// return axios(&#123;</span></span><br><span class="line">        <span class="comment">//url:'/users/register',</span></span><br><span class="line">        <span class="comment">//method:'POST',</span></span><br><span class="line">        <span class="comment">//data:params</span></span><br><span class="line">    <span class="comment">//&#125;)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    login</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给Vue添加方法，然后进行挂载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> apiList <span class="keyword">from</span> <span class="string">'./interface'</span>;</span><br><span class="line"><span class="keyword">const</span> install  = <span class="function"><span class="params">Vue</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (install.installed) <span class="keyword">return</span> ;</span><br><span class="line">    install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Vue.prototype,&#123;</span><br><span class="line">        $api:&#123;</span><br><span class="line">            <span class="keyword">get</span>()&#123;</span><br><span class="line">                <span class="keyword">return</span> apiList</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install</span><br></pre></td></tr></table></figure>
</li>
<li><p>Main.js:进行使用挂在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'./http/index'</span></span><br><span class="line">Vue.use(api);</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中进行使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$api.login(&#123;</span><br><span class="line">  username:this.ruleForm.username,</span><br><span class="line">  password:this.ruleForm.userpass</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="vue-本地调试跨域请求的代理"><a href="#vue-本地调试跨域请求的代理" class="headerlink" title="vue 本地调试跨域请求的代理"></a>vue 本地调试跨域请求的代理</h4><p>我服务端是localhost:3000，客户端是：localhost：3001 这样进行请求那肯定涉及到跨域问题啊，身为小白菜的我，在这卡了半天啊， 开始的时候我在koa使用 koa-cors 进行后台的跨域开放，很轻松的完成了，但是我轴啊，我就非要代理来进行，我要和你死磕到底哈哈哈哈，这是多大仇这是。在vue.config.js中进行proxy代理。这块我捣鼓了好一会。axiso封装的配置config.js ，baseURL:’/api’,就是这样 ，然后接口直接写成 url: ‘/mongotest’,对应好了跨域就不存在问题了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// 本地运行地址</span></span><br><span class="line">        host: <span class="string">'localhost'</span>,</span><br><span class="line">        <span class="comment">// 本地运行端口</span></span><br><span class="line">        port: <span class="string">'3001'</span>,</span><br><span class="line">        <span class="comment">// 代理配置</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="comment">// 匹配拦截路由  那就请求的接口是localhost:3000/api/XXX</span></span><br><span class="line">            <span class="string">'/api'</span>: &#123;   </span><br><span class="line">                target: <span class="string">'http://localhost:3000/'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                ws: <span class="literal">false</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="登陆数据token的"><a href="#登陆数据token的" class="headerlink" title="登陆数据token的"></a>登陆数据token的</h4><p>这一块真的是考虑良久或许我很菜吧，请大佬勿喷，但是绝对是很全面的，我自己肯定是很细节的走了一遍。</p>
<ul>
<li><p>先来讲前端登陆，前端登陆页面发送登陆请求，后台返回token </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$api.Login(&#123;</span><br><span class="line">  username:<span class="keyword">this</span>.ruleForm.username,</span><br><span class="line">  password:<span class="keyword">this</span>.ruleForm.userpass</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> loginType = <span class="string">''</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="keyword">if</span> (res.code===<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">//登陆之后进行token的储存</span></span><br><span class="line">    <span class="comment">//localStorage.setItem('USER_TOKEN', JSON.stringify(res.token));</span></span><br><span class="line">    (res.token)&amp;&amp;(<span class="keyword">this</span>.$store.commit(<span class="string">'setUserToken'</span>,res.token)); </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 对登陆状态的cookie 存储</span></span><br><span class="line">    <span class="keyword">this</span>.$cookie.setCookie(&#123;<span class="attr">username</span>:res.username&#125;,<span class="number">2</span>/<span class="number">144</span>);</span><br><span class="line">    loginType =<span class="string">'success'</span> ;</span><br><span class="line">     </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    loginType =<span class="string">'error'</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台koa 进行接收，聊一下思路，请短发送请求，1.后台需要再路由处有接口，2.有了接口肯定会去对比用户名和密码对吧？不用别人点头那肯定的啊。3.进行mongo查询 4. 返回查询到信息生成token返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口处进行接收</span></span><br><span class="line">router.post(<span class="string">'/login'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//console.log(ctx.request.body);</span></span><br><span class="line">  <span class="keyword">let</span> &#123;username, password&#125; = ctx.request.body;</span><br><span class="line">  <span class="keyword">if</span>(!username || !password) <span class="keyword">return</span> ctx.body = &#123;<span class="attr">code</span>: <span class="number">4020</span>,<span class="attr">msg</span>: <span class="string">'请填写用户名或密码'</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = &#123;username, password&#125;;</span><br><span class="line">  <span class="keyword">const</span> userData = <span class="keyword">await</span> getUsers.userLogin(args)</span><br><span class="line">  ctx.body = userData</span><br><span class="line">  <span class="built_in">console</span>.log(userData);</span><br><span class="line">  ctx.body = (userData.code === <span class="number">200</span>) </span><br><span class="line">     ? &#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">msg</span>: <span class="string">'登陆成功'</span>,<span class="attr">username</span>:userData.username, <span class="attr">token</span>: jwt._createToken(userData)&#125; </span><br><span class="line">     : userData</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对比密码你肯定不可能直接输入了就对比吧？那不得进行密码加密啊 我们使用bcrypt 进行密码加密</span></span><br><span class="line">usersSchema.methods = &#123;</span><br><span class="line">    comparePassword: <span class="function">(<span class="params">_pass, password</span>) =&gt;</span> &#123; <span class="comment">//验证方法</span></span><br><span class="line">        <span class="comment">// _pass传递过来的密码，password是数据库中的密码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        bcrypt.compare(_pass, password, (err, isMath) =&gt; &#123; <span class="comment">//compare官方方法</span></span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                        res(isMath); <span class="comment">// isMath返回true和false,true代表验证通过</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rej(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 进行调用密码加密的方法</span></span><br><span class="line"> <span class="keyword">let</span> result = <span class="keyword">await</span> usersDoc.comparePassword(password, usersDoc.password).then(<span class="function">(<span class="params">isMath</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (isMath) &#123; <span class="comment">// 返回true账户密码存在</span></span><br><span class="line">     <span class="keyword">return</span> isMath</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则是账户存在密码错误</span></span><br><span class="line">     <span class="built_in">console</span>.log(isMath, <span class="string">"密码不存在............"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"服务器出现异常，请重启服务器......"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(result);</span></span><br><span class="line"><span class="keyword">return</span> !result ? &#123;<span class="attr">code</span>:<span class="number">-2</span> ,<span class="attr">msg</span> :<span class="string">'密码不正确'</span>&#125; : &#123;<span class="attr">code</span>:<span class="number">200</span>, <span class="attr">_id</span>: usersDoc._id,<span class="attr">username</span>: usersDoc.username,<span class="attr">avatar</span>: usersDoc.avatar, <span class="attr">mobile</span>: usersDoc.mobile,<span class="attr">email</span>: usersDoc.email&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行mongo 查询 使用mongoose ，我们新建一个db目录，需要 有对mongose 配置文件，数据的模型model文件，contoller文件，出口调用的index文件</span></span><br><span class="line"><span class="comment">// db 目录结构详细为：</span></span><br><span class="line"><span class="comment">//	--index.js</span></span><br><span class="line"><span class="comment">//	--db.js</span></span><br><span class="line"><span class="comment">//	--models</span></span><br><span class="line"><span class="comment">//  	--users.js</span></span><br><span class="line"><span class="comment">//	--controllers</span></span><br><span class="line"><span class="comment">//    --user.js</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件 db.js</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="comment">// 连接</span></span><br><span class="line"><span class="keyword">const</span> DB_URL = <span class="string">'mongodb://localhost:27017/msjx'</span></span><br><span class="line">mongoose.set(<span class="string">'useCreateIndex'</span>, <span class="literal">true</span>)</span><br><span class="line">mongoose.connect(DB_URL)</span><br><span class="line"></span><br><span class="line">mongoose.connection.on(<span class="string">'connected'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接成功 '</span> + DB_URL);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接异常error 数据库链接错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mongoose.connection.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mongoose connection disconnected'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接断开disconnected 连接异常断开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mongoose.connection.on(<span class="string">'disconnected'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'链接断开'</span>+ DB_URL)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = mongoose</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型文件</span></span><br><span class="line"><span class="keyword">const</span> mongoose  =<span class="built_in">require</span>(<span class="string">'../db'</span>);</span><br><span class="line"><span class="keyword">const</span> bcrypt  = <span class="built_in">require</span>(<span class="string">"bcrypt"</span>)</span><br><span class="line"><span class="keyword">const</span> stringRandom = <span class="built_in">require</span>(<span class="string">'string-random'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; model ,Schema&#125; = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"> <span class="comment">// 定义加密密码计算强度</span></span><br><span class="line"><span class="keyword">const</span> SALT_WORK_FACTOR = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> usersSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    username:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>:stringRandom(<span class="number">8</span>),</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    alias_name:<span class="built_in">String</span>,</span><br><span class="line">    mobile: <span class="built_in">String</span>,</span><br><span class="line">    password: <span class="built_in">String</span>,</span><br><span class="line">    userType: <span class="built_in">Number</span>,  <span class="comment">// 用户角色</span></span><br><span class="line">    school_type:<span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    family_name: <span class="built_in">String</span>,</span><br><span class="line">    reg_time:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    avatar:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 保存之前的操作 </span></span><br><span class="line">usersSchema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 仅当密码被修改(或新)时才对其进行散列</span></span><br><span class="line">    <span class="keyword">if</span> (!user.isModified(<span class="string">'password'</span>)) <span class="keyword">return</span> next();</span><br><span class="line">    <span class="comment">// 进行加盐</span></span><br><span class="line">    bcrypt.genSalt(SALT_WORK_FACTOR, <span class="function"><span class="keyword">function</span>(<span class="params">err, salt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">        <span class="comment">// 使用加盐密码之后的密码进行hash</span></span><br><span class="line">        bcrypt.hash(user.password, salt, <span class="function"><span class="keyword">function</span>(<span class="params">err, hash</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">            <span class="comment">// 用散列后的密码覆盖明文密码</span></span><br><span class="line">            user.password = hash;</span><br><span class="line">            next();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">usersSchema.methods = &#123;</span><br><span class="line">    comparePassword: <span class="function">(<span class="params">_pass, password</span>) =&gt;</span> &#123; <span class="comment">//验证方法</span></span><br><span class="line">        <span class="comment">// _pass传递过来的密码，password是数据库中的密码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">        bcrypt.compare(_pass, password, (err, isMath) =&gt; &#123; <span class="comment">//compare官方方法</span></span><br><span class="line">                <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                        res(isMath); <span class="comment">// isMath返回true和false,true代表验证通过</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    rej(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userModel  = model(<span class="string">"users"</span>,usersSchema);</span><br><span class="line"><span class="built_in">module</span>.exports = userModel</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// control 控制模型文件</span></span><br><span class="line"><span class="keyword">const</span> UsersModel  = <span class="built_in">require</span>(<span class="string">'./../models/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersCtl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    query () &#123;  <span class="comment">// 用户列表查询接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            UsersModel.find(&#123;&#125;,(err,res)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(res)  <span class="comment">// res就是一个doc</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> userLogin(obj) &#123; <span class="comment">// 用户登陆的方法</span></span><br><span class="line">        <span class="keyword">let</span> &#123;username,password&#125;  = obj;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> usersDoc = <span class="keyword">await</span> UsersModel.findOne(&#123;<span class="string">"$or"</span> :  [ &#123;<span class="string">'mobile'</span>:username&#125; , &#123;<span class="string">'username'</span>:username&#125;]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!usersDoc) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">               code:<span class="number">0</span>,</span><br><span class="line">               msg:<span class="string">"该用户尚未注册"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> usersDoc.comparePassword(password, usersDoc.password).then(<span class="function">(<span class="params">isMath</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMath) &#123; <span class="comment">// 返回true账户密码存在</span></span><br><span class="line">                <span class="keyword">return</span> isMath</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则是账户存在密码错误</span></span><br><span class="line">                <span class="built_in">console</span>.log(isMath, <span class="string">"密码不存在............"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"服务器出现异常，请重启服务器......"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//console.log(result);</span></span><br><span class="line">        <span class="keyword">return</span> !result ? &#123;<span class="attr">code</span>:<span class="number">-2</span> ,<span class="attr">msg</span> :<span class="string">'密码不正确'</span>&#125; : &#123;<span class="attr">code</span>:<span class="number">200</span>, <span class="attr">_id</span>: usersDoc._id,<span class="attr">username</span>: usersDoc.username,<span class="attr">avatar</span>: usersDoc.avatar, <span class="attr">mobile</span>: usersDoc.mobile,<span class="attr">email</span>: usersDoc.email&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> userRegister(obj) &#123; <span class="comment">// 用户登陆的方法</span></span><br><span class="line">        <span class="keyword">let</span> &#123;alias_name,password,mobile,school_type&#125;  = obj;</span><br><span class="line">        <span class="keyword">const</span> usersDoc = <span class="keyword">await</span> UsersModel.findOne(&#123;mobile&#125;);</span><br><span class="line">        <span class="keyword">if</span> (usersDoc) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">               code:<span class="number">0</span>,</span><br><span class="line">               msg:<span class="string">"该用户已经注册"</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> userRegister = <span class="keyword">new</span> UsersModel(&#123;alias_name,password,mobile,school_type&#125;);</span><br><span class="line">        <span class="keyword">let</span> userInfo = <span class="keyword">await</span> userRegister.save();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            code:<span class="number">200</span>,</span><br><span class="line">            msg:<span class="string">"注册成功"</span>            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    save(obj)&#123; </span><br><span class="line">        <span class="keyword">const</span> m = <span class="keyword">new</span> UsersModel(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            m.save(<span class="function">(<span class="params">err,res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(res)</span><br><span class="line">                <span class="comment">//console.log(res)</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports =  <span class="keyword">new</span> UsersCtl()</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index .js 文件</span></span><br><span class="line"><span class="keyword">const</span> UsersCtl  =<span class="built_in">require</span>(<span class="string">'./controllers/user'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getUsers: UsersCtl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>生成token单独拿出来</p>
<p><img src="https://s1.ax1x.com/2020/09/24/wzi5qO.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createToken</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> _createToken = <span class="function">(<span class="params">userInfo</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jwt.sign(&#123;userInfo&#125;,<span class="string">'10000@qq.com'</span>,&#123;<span class="attr">expiresIn</span>:<span class="string">'60'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    _createToken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkToken</span></span><br><span class="line"><span class="keyword">const</span> jwt =<span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> _checkToken = <span class="function"><span class="keyword">function</span> (<span class="params">req,res,next</span>)</span>&#123; <span class="comment">// 获取请求头文件中的token信息</span></span><br><span class="line">    <span class="keyword">let</span> token = req.body.token || req.query.token || req.headers[<span class="string">'authorization'</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(token); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="comment">//确认token是否正确</span></span><br><span class="line">        <span class="keyword">let</span> decoded = jwt.decode(token,<span class="string">'10000@qq.com'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(decoded,<span class="number">4444</span>); <span class="comment">// 验证token是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (token &amp;&amp; decode.exp&lt;<span class="keyword">new</span> <span class="built_in">Date</span>()/<span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.json(&#123;<span class="attr">success</span>:<span class="literal">false</span>,<span class="attr">message</span>:<span class="string">'token令牌已过期'</span>&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果没有token</span></span><br><span class="line">        <span class="keyword">return</span> res.status(<span class="number">403</span>).send(&#123;</span><br><span class="line">            success:<span class="literal">false</span>,</span><br><span class="line">            message:<span class="string">'没有提供token！'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = _checkToken;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://github.com/Yuhior/vue-koa-mongo" target="_blank" rel="noopener">我的项目 github地址</a>  敬请关注</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>node</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>个人对模块化理解</title>
    <url>/2018/07/25/module/</url>
    <content><![CDATA[<blockquote>
<p>最近精神状态不是太好，晚上总也睡不好，但是学习还是不能落下滴！毕竟 逆水行舟，不进则退。没毛病！安排！！！</p>
</blockquote>
<h3 id="1-模块的写法发展"><a href="#1-模块的写法发展" class="headerlink" title="1. 模块的写法发展"></a>1. 模块的写法发展</h3><ul>
<li><strong>最开始的写法</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params"></span>) </span>&#123;..........&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span>) </span>&#123;..........&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数组成一个模块，使用时直接调用，但是这样明显污染全局环境，无法保证不与其他的模块发生变量名冲突，并且这样也看不出来各个模块之间的依赖关系。</p>
<ul>
<li><strong>写成对象的形式</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    _count: <span class="number">0</span>,</span><br><span class="line">    m1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    m2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就写module.m1(); 但是这样暴露了所有模块成员，内部代码可以被外部改写。比如外部代码可以直接改变内部计数的值  :module1._count =5;</p>
<ul>
<li><strong>使用立即执行函数可以达到不暴露私有成员变量的目的</strong> </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;　　　　</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　 <span class="comment">//...</span></span><br><span class="line">        　　　　&#125;;　　　　</span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　 <span class="comment">//...</span></span><br><span class="line">        　　　　&#125;;　　　　</span><br><span class="line">    <span class="keyword">return</span> &#123;　　　　　　</span><br><span class="line">        m1: m1,</span><br><span class="line">      　m2: m2　　　　</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>后来又有了宽放大的模式</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params">mod</span>) </span>&#123;　　　　 </span><br><span class="line">    <span class="comment">//...    　　　　</span></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module || &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-出现模块化规范，目前有-：CommonJS模块、AMD模块还有CMD模块-几种规范。"><a href="#2-出现模块化规范，目前有-：CommonJS模块、AMD模块还有CMD模块-几种规范。" class="headerlink" title="2. 出现模块化规范，目前有 ：CommonJS模块、AMD模块还有CMD模块 几种规范。"></a>2. 出现模块化规范，目前有 ：CommonJS模块、AMD模块还有CMD模块 几种规范。</h3><ul>
<li><strong>CommonJs缺点及AMD出现背景</strong></li>
</ul>
<p>CommonJS规范同步加载模块，这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AMD写法（AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块）</strong></li>
</ul>
<p>AMD异步加载模块加载采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<br>AMD也采用require加载模块 require([module], callback);第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;　　　</span><br><span class="line">    math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。==<code>requireJS</code>这个JavaScript的库实现了AMD规范==</p>
<ul>
<li><strong>CMD（CMD推崇就近依赖，只有在用到某个模块的时候再去require）</strong></li>
</ul>
<p>CMD有个浏览器的实现<code>SeaJS</code>，<code>SeaJS</code>要解决的问题和<code>requireJS</code>一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。在CMD中一个模块就是一个文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块代码</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>require</code>是可以把其他模块导入进来的一个参数;而<code>exports</code>是可以把模块内的一些属性和方法导出的;<code>module</code> 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CMD定义模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    <span class="comment">// 此处略去 100 行</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">    b.doSomething()</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 定义模块</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">    a.doSomething()</span><br><span class="line">    <span class="comment">// 此处略去 100 行</span></span><br><span class="line">    b.doSomething()</span><br><span class="line">        ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">  exports.data = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> star= my.data;</span><br><span class="line">    <span class="built_in">console</span>.log(star);  <span class="comment">//1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-对于上边AMD中requireJS用法说明"><a href="#3-对于上边AMD中requireJS用法说明" class="headerlink" title="3. 对于上边AMD中requireJS用法说明"></a>3. 对于上边AMD中<code>requireJS</code>用法说明</h3><ul>
<li>为什么用<code>requireJS</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这样的方式加载有两个缺点：加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长（解决方法在下边）；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序</p>
<ul>
<li><strong>requireJS解决依赖问题</strong><br>require.js解决了这个问题 <script src="js/require.js" defer async="true"></script><br>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。加载require.js以后就需要 加载我们自己的代码了，写一个main.js 这就相当于c语言的main（）入口；<br><script src="js/require.js" data-main="js/main"></script> data-main属性的作用是，指定网页程序的主模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB, moduleC</span>) </span>&#123;　　　　 </span><br><span class="line">    <span class="comment">// 此处省略1000行code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<br>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<ul>
<li><strong>requireJS如何自定义模块的加载行为</strong>：使用require.config()方法进行定义；写在main.js的头部。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;　　　　</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="comment">// 或者写上baseUrl: "js/lib",下边就不用写lib      　　　　　　</span></span><br><span class="line">        <span class="string">"jquery"</span>: <span class="string">"lib/jquery.min"</span>,</span><br><span class="line">        <span class="string">"underscore"</span>: <span class="string">"lib/underscore.min"</span>,</span><br><span class="line">        <span class="string">"backbone"</span>: <span class="string">"lib/backbone.min"</span>　　　　</span><br><span class="line">    &#125;　　</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>很多库的模块不符合AMD规范那么怎么进行加载？</strong></li>
</ul>
<p>那加载他们之前必须要先定义他们的特征，比如加载underscore和backbone。<br>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;　　　　</span><br><span class="line">    shim: &#123;　　　　　　</span><br><span class="line">        <span class="string">'underscore'</span>: &#123;　　　　　　　　</span><br><span class="line">            exports: <span class="string">'_'</span>　　　　　　</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'backbone'</span>: &#123;　　　　　　　　</span><br><span class="line">            deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">            exports: <span class="string">'Backbone'</span>　　　　　　</span><br><span class="line">        &#125;　　　　</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-上边的加载方式说完，那么再说一下怎么自己写模块-（使用AMD规范），写模块必须采用特定的define-函数来定义"><a href="#4-上边的加载方式说完，那么再说一下怎么自己写模块-（使用AMD规范），写模块必须采用特定的define-函数来定义" class="headerlink" title="4. 上边的加载方式说完，那么再说一下怎么自己写模块 （使用AMD规范），写模块必须采用特定的define()函数来定义"></a>4. 上边的加载方式说完，那么再说一下怎么自己写模块 （使用AMD规范），写模块必须采用特定的define()函数来定义</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js模块</span></span><br><span class="line">　　</span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;　　　　　　</span><br><span class="line">        <span class="keyword">return</span> x + y;　　　　</span><br><span class="line">    &#125;;　　　　</span><br><span class="line">    <span class="keyword">return</span> &#123;　　　　　　</span><br><span class="line">        add: add　　　　</span><br><span class="line">    &#125;;　　</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>react-redux原理</title>
    <url>/2019/03/19/react-redux/</url>
    <content><![CDATA[<blockquote>
<p>使用react-redux 怎们能不了解原理，彻底了解原理和单纯的使用，应该不是一个级别的选手吧</p>
</blockquote>
<h3 id="redux原理实现"><a href="#redux原理实现" class="headerlink" title="redux原理实现"></a>redux原理实现</h3><ul>
<li><h5 id="简单的redux"><a href="#简单的redux" class="headerlink" title="简单的redux"></a>简单的redux</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据我们使用redux的用法 ，开始是createStore然后createStore中有getState、dispatch、subscribe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createStore 有两个参数 第一个reducer 第二个参数中间件 (增强)</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState ; <span class="comment">//初始状态 可以是对象或者什么都可以，因为使用时会给出初始值</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = []; <span class="comment">//每次函数的修改都要触发组件的变化 ，所以要有监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 定义getState方法，getState()返回当前的state树，它与 store 的最后一个 reducer 返回值相同。</span></span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;  <span class="comment">//定义我们监听的时候使用的方法</span></span><br><span class="line">        currentListeners.push(listener)  <span class="comment">// 将我们需要监听的组件传递进来，push到currentListeners数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;   <span class="comment">//定义我们的dispatch方法  使用dispatch会传递一个action参数</span></span><br><span class="line">        currentState = reducer(currentState,action);  </span><br><span class="line">        <span class="comment">// reducer 中有两个参数  像这样 counterReducer = (state=0,action)=&gt;&#123; &#125; reducer返回的新的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">value</span> =&gt;</span> value()); </span><br><span class="line">        <span class="comment">// 每次dispatch都执行一下 所有 subscribe里的内容 ，比如index.js中 每一次dispatch都执行render= ()=&gt;&#123;&#125;这个方法</span></span><br><span class="line">        <span class="comment">// const render =()=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//     ReactDOM.render(</span></span><br><span class="line">        <span class="comment">//         &lt;App /&gt;,</span></span><br><span class="line">        <span class="comment">//         document.getElementById('root')</span></span><br><span class="line">        <span class="comment">//     );</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// render();</span></span><br><span class="line">        <span class="comment">// store.subscribe(render);</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@IMOOC/WONIU-REDUX'</span>&#125;);  <span class="comment">//手动先dispatch ,让它第一次dispatch命中默认初始值dispatch，不然不会有初始值</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getState,subscribe,dispatch&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><ul>
<li><p>Provider</p>
<blockquote>
<p>Provider 模块功能并不复杂 ，需要实现一下两点</p>
</blockquote>
<ul>
<li>在原应用组件上包裹一层，使原来整个应用成为Provider的子组件</li>
<li>接收Redux的store作为props，通过context对象传递给子孙组件上的connect</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;  </span><br><span class="line">//  prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型</span><br><span class="line">export class Provider extends Component&#123;</span><br><span class="line">    static childContextTypes = &#123;  // 设置childContext 状态值类型</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    getChildContext()&#123;   // 设置childContext,设置完了这样所有的子元素都能取到</span><br><span class="line">        return &#123;store:this.store&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props, context)&#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.store = props.store  </span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return this.props.children  // this.props.children是react内置在this.props上的对象，用于获取当前组件的所有子组件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Provider初始化时，获取到props中的store对象；</span><br><span class="line">// 将外部的store对象放入context对象中，使子孙组件上的connect可以直接访问到context对象中的store。</span><br><span class="line">// context可以使子孙组件直接获取父级组件中的数据或方法，而无需一层一层通过props向下传递。</span><br><span class="line">// context对象相当于一个独立的空间，父组件通过getChildContext()向该空间内写值；定义了contextTypes验证的子孙组件可以通过this.context.xxx，从context对象中读取xxx字段的值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>connect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//添加监听对象，并尝试通过 props 将状态传递给子组件</span><br><span class="line">const connect = (mapStateToProps,mapDispatchToProps)=&gt;&#123; //返回一个函数</span><br><span class="line">    return WrappedComponent=&gt;&#123;</span><br><span class="line">        return class ConnectComp extends Component&#123;</span><br><span class="line">            static contextTypes = &#123;</span><br><span class="line">                store:PropTypes.object</span><br><span class="line">            &#125;;</span><br><span class="line">            //获取context</span><br><span class="line">            constructor(props,context)&#123;</span><br><span class="line">                super(props, context)</span><br><span class="line">                this.state = &#123;</span><br><span class="line">                    props:&#123;&#125;  // 手动定义一个state</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            componentDidMount()&#123;</span><br><span class="line">                const &#123;store&#125; = this.context</span><br><span class="line">                store.subscribe(()=&gt;this.update())  // 每次dispatch(更新)都会执行一下subscribe 里边的</span><br><span class="line">                this.update()  //</span><br><span class="line">            &#125;</span><br><span class="line">            update()&#123;</span><br><span class="line">                const &#123;store&#125; = this.context;</span><br><span class="line">                const stateProps =mapStateToProps(store.getState())</span><br><span class="line">                const dispatchProps = bindActionCreators(mapDispatchToProps,store.dispatch)</span><br><span class="line">                //作用是将单个或多个ActionCreator转化为dispatch(action)的函数集合形式。</span><br><span class="line">                //将一个或多个action和dispatch组合起来生成mapDispatchToProps需要生成的内容 ，其实就是把多个action还是用dispatch调用</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    props:&#123;</span><br><span class="line">                        ...this.state.props,</span><br><span class="line">                        ...stateProps,</span><br><span class="line">                        ...dispatchProps</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return &lt;WrappedComponent &#123;...this.state.props&#125;&gt;&lt;/WrappedComponent&gt;</span><br><span class="line">                // 这个WrappedComponent也就是我们的使用的App，这样的connect(mapStateToProps,mapDispatchToProps)(App)</span><br><span class="line">                // 使用connect组件的时候 我们的state add方法等等都到了props之上，就是通过这实现的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux理解</tag>
        <tag>Redux单向数据流</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式、构造函数、原型的理解</title>
    <url>/2018/08/17/object/</url>
    <content><![CDATA[<blockquote>
<p>越来越感觉到站在巨人的肩膀上学习是多么方便，并且越来越感觉到前端内容广阔，需要学习的东西还很多，努力吧！去争取自己想要的生活，做一个合格的码农。</p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>单例模式就是起到分组的作用，比如大型项目中，好多前端人员进行开发，这个时候可以把项目分成几个功能模块，不同的人编写不同的模块，最后合起来就是模块化开发.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">var</span> person1 =&#123;</span><br><span class="line">  name:<span class="string">'张三'</span>,</span><br><span class="line">  age:<span class="number">54</span>,</span><br><span class="line">  showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  showAge:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"年纪："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 =&#123;</span><br><span class="line">  name:<span class="string">'李四'</span>,</span><br><span class="line">  age:<span class="number">20</span>,</span><br><span class="line">  showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  showAge:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"年纪："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1.showName();</span><br><span class="line">person2.showName();</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点也是显而易见的能解决分组作用，但是不能解决批量生成的问题，代码可重复性低，而且多个对象之后代码冗余程度高.</li>
</ul>
<h3 id="工厂模式-顾名思义就是批量生产东西嘛"><a href="#工厂模式-顾名思义就是批量生产东西嘛" class="headerlink" title="工厂模式 (顾名思义就是批量生产东西嘛)"></a>工厂模式 (顾名思义就是批量生产东西嘛)</h3><ul>
<li>把实现同一件事情的相同代码放到同一个函数中，想实现这个功能只要执行这个函数即可，这就是工厂模式，也叫做“函数的封装”，这也是”低耦合，高内聚“，从而达到减少页面冗余码，提高代码重复利用率的作用.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> person =<span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//创建一个新对象</span></span><br><span class="line">   <span class="comment">//原料</span></span><br><span class="line">  person.name = name;</span><br><span class="line">  person.age = age;</span><br><span class="line">   <span class="comment">//加工</span></span><br><span class="line">  person.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  person.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//出厂</span></span><br><span class="line">  <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">"张三"</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">p1.showName();</span><br><span class="line">p2.showName();</span><br><span class="line"><span class="built_in">console</span>.log(p1.showName==p2.showName); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ol>
<li>一般我们创建对象是通过new来创建，比如new Date()，这里使用的是方法创建。（var p1=createPerson(“张三”,45)）使用new来创建可以简化一些代码，也带来一些新的特性。</li>
<li>每个对象都有一套自己的方法，浪费资源   console.log(p1.showName==p2.showName); false  说明两个方法不一样  ，因为创建function()的时候其本质是通过new Function()来创建的，会诞生一个新的函数对象，造成资源浪费。</li>
</ol>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>Array、Object、Function等这些都是内置类，所有的数组都是内置类Array的实例，所以的对象都是内置类Object的实例，所以函数都是Function的实例，而构造函数就是自定义一个类。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span> (<span class="params">name,age</span>)</span>&#123;  <span class="comment">//首先构造函数 开头首字母大写</span></span><br><span class="line">  <span class="keyword">this</span>.name =name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+ <span class="keyword">this</span>.name);</span><br><span class="line">  &#125; ;</span><br><span class="line">  <span class="keyword">this</span>.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不用返回对象啦！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">"张三"</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">p1.showName();</span><br><span class="line">p2.showName();</span><br><span class="line"><span class="built_in">console</span>.log(p1.showName==p2.showName); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.我们看到这里使用了new方法来创建对象.</span></span><br><span class="line"><span class="comment">//2.但是console.log(p1.showName==p2.showName); //false 依旧是false  说明还是存在浪费资源的问题.</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数之原型"><a href="#构造函数之原型" class="headerlink" title="构造函数之原型"></a>构造函数之原型</h3><ul>
<li>JavaScript规定，每一个函数都有一个prototype属性，它指向另一个对象。这个对象的所有属性和方法，都会被函数的<label style="color:red">new出来的实例</label>继承。能够引用prototype的东西绝对是函数,prototype是函数的一个属性，是函数的原型对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span> (<span class="params">name,age</span>)</span>&#123;  <span class="comment">//首先构造函数 开头首字母大写</span></span><br><span class="line">  <span class="keyword">this</span>.name =name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">CreatePerson.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line">CreatePerson.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"年龄："</span>+<span class="keyword">this</span>.age );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreatePerson(<span class="string">"张三"</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">p1.showName();</span><br><span class="line">p2.showName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.showName == p2.showName);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.showName == Person.prototype.showName);  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//这时console.log(p1.showName==p2.showName); 结果为 true</span></span><br><span class="line"><span class="comment">//这时所有实例的方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</span></span><br><span class="line"><span class="comment">//console.log(p1.showName == Person.prototype.showName); 为true 证明都指向prototype对象</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux 、react-redux</title>
    <url>/2019/02/21/react03/</url>
    <content><![CDATA[<h3 id="Redux：如果你不知道是否需要-Redux，那就是不需要它。"><a href="#Redux：如果你不知道是否需要-Redux，那就是不需要它。" class="headerlink" title="Redux：如果你不知道是否需要 Redux，那就是不需要它。"></a>Redux：如果你不知道是否需要 Redux，那就是不需要它。</h3><blockquote>
<p>redux类似于vuejs的vuex，是react的数据管理中心。</p>
</blockquote>
<ul>
<li><h4 id="redux上手"><a href="#redux上手" class="headerlink" title="redux上手"></a>redux上手</h4><ul>
<li><p>首先我们需要安装redux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install redux --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h5><blockquote>
<p>redux 中我们首先需要理解store，这个就是帮我们管理数据的政委，Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
</blockquote>
</li>
<li><h5 id="State"><a href="#State" class="headerlink" title="State"></a>State</h5><blockquote>
<p><code>Store</code>对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过<code>store.getState()</code>拿到</p>
</blockquote>
</li>
<li><h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><blockquote>
<p>State 的变化，会导致 View 的变化。但是，用户不能够直接改变State，只能操控View所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p>
</blockquote>
</li>
<li><h5 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h5><blockquote>
<p>功能就是我们View层要发出Action，必须要通过dispatch来进行触发</p>
</blockquote>
</li>
<li><h5 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h5><blockquote>
<p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
</blockquote>
</li>
<li><h5 id="对redux通俗理解"><a href="#对redux通俗理解" class="headerlink" title="对redux通俗理解"></a>对redux通俗理解</h5><blockquote>
<p>就拿我们 <em> 东来说，发货都是从仓库发出，仓库就是redux的store，store中的state是存储数据也就是相当于仓库的货物，当我们从</em>东软件上下单 就是我们触发一个dispatch，然后 *东后台接到订单通知（action）仓库，相当我们下单买的货物的通知到达仓库（这个过程是我们和货物不能直接接触的，如果能接触货物早就偷光了哈哈哈），通知到仓库后，仓库里边有工人（reducer）来进行处理发货一系列的动作，发出货物之后，仓库货物的数据（state数据）就变了，货物到我们手里（view也就变了）</p>
</blockquote>
</li>
<li><h5 id="简单加减按钮的实现"><a href="#简单加减按钮的实现" class="headerlink" title="简单加减按钮的实现"></a>简单加减按钮的实现</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  store.js</span><br><span class="line">import &#123;createStore&#125; from &apos;redux&apos;</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;   // 一定是返回新的state 而不是像vue直接修改 </span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const store = createStore(counterReducer);</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// App.js</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">           &#123;/*getState()返回当前的state树它与 store 的最后一个 reducer 返回值相同。*/&#125;</span><br><span class="line">                &lt;p&gt;&#123;store.getState()&#125;&lt;/p&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;store.dispatch(&#123;type:&quot;add&quot;&#125;)&#125; &gt;增加+&lt;/Button&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;store.dispatch(&#123;type:&quot;minus&quot;&#125;)&#125;&gt;减少-&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js 中的render方法需要自己手动订阅监听 </span><br><span class="line">import store from &quot;./store&quot;;</span><br><span class="line">const render =()=&gt;&#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;App /&gt;,</span><br><span class="line">        document.getElementById(&apos;root&apos;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">render(); </span><br><span class="line">store.subscribe(render); // 每次 dispatch也就是state发生变化都需要render一次</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><blockquote>
<p>上边使用redux 每次都需要render麻烦且不优雅，使用react-redux更好，不用手动再去监听</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm insatll react-redux --save</span><br></pre></td></tr></table></figure>
<ul>
<li>Provider顶级组件，来提供数据，</li>
<li>connect高阶组件，提供数据和方法，把组件的状态映射到属性之上，然后只用props来进行调用</li>
<li>看看react-redux如何实现上边的功能，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js  不需要手动再去监听 ，直接使用Provider进行包裹，自动监听数据了</span><br><span class="line">import store from &quot;./store&quot;;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>Provider将数据传递进来数据任何地方想使用就用connect链接，这样App和redux就链接起来了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.js</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.num&#125;&lt;/p&gt;  // dispatch 直接写对应的方法 </span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;this.props.add()&#125;&gt;增加+&lt;/Button&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;this.props.minus()&#125;&gt;减少-&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapStateToProps = (state) =&gt;&#123; // 它把状态映射到属性之上 所以上边使用this.props</span><br><span class="line">    return &#123;</span><br><span class="line">        num:state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const mapDispatchToProps = dispatch=&gt;&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        add:()=&gt;dispatch(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;dispatch(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App = connect(mapStateToProps,mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="react-redux中的connect-使用装饰器写法"><a href="#react-redux中的connect-使用装饰器写法" class="headerlink" title="react-redux中的connect 使用装饰器写法"></a>react-redux中的connect 使用装饰器写法</h5><blockquote>
<p>上边的connect 使用的高阶组件来声明需要的state里边的数据和方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//App.js</span><br><span class="line">@connect(</span><br><span class="line">    // Es6语法</span><br><span class="line">    //state=&gt;(&#123;num:state&#125;),  </span><br><span class="line">   	// 读数据</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //除了ES6语法简写外 同步的dispatch可以进行简写</span><br><span class="line">    //写数据，要调用的dispatch 并且这些方法会传递到props中</span><br><span class="line">    // add:()=&gt;(&#123;type:&quot;add&quot;，step:2&#125;), 可以传递多个参数，但第一参数是修改数据的请求</span><br><span class="line">    &#123;</span><br><span class="line">        add:()=&gt;(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // dispatch=&gt;&#123;</span><br><span class="line">    //     return&#123;</span><br><span class="line">    //         add:()=&gt;dispatch(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">    //         minus:()=&gt;dispatch(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="redux默认都是同步的操作，这样异步任务就需要使用-中间件-来完成"><a href="#redux默认都是同步的操作，这样异步任务就需要使用-中间件-来完成" class="headerlink" title="redux默认都是同步的操作，这样异步任务就需要使用 中间件 来完成"></a>redux默认都是同步的操作，这样异步任务就需要使用 <em>中间件</em> 来完成</h5><blockquote>
<p>为什么异步任务只能通过中间件来完成？</p>
<ol>
<li>Reducer ：纯函数，只能承担计算State的功能，不适合承担其他功能，理论上纯函数不能进行读写操作</li>
<li>View:与State一一对应，可以看做State的视觉层，也不适合承担其他功能</li>
<li>Action：存放数据的对象，即消息的载体，只能被别人操控，自己并不能进行任何操作</li>
<li>实际的reducer和action store都需要独立拆分文件</li>
</ol>
<p>所以要进行异步任务的dispatch请求，到达Reducer之前都需要经过中间件的处理。</p>
<p>我们试一下redux-logger和redux-thunk（异步操作） 两个中间件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//store.js</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos; // applyMiddleware 是使用中间件</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;</span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const store = createStore(counterReducer,applyMiddleware(logger,thunk));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@connect(</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        add:()=&gt;(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;(&#123;type:&quot;minus&quot;&#125;),</span><br><span class="line">        asyncAdd:()=&gt;dispatch=&gt;&#123;   // 延时加1。模拟异步任务</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                dispatch(&#123;type:&quot;add&quot;&#125;)</span><br><span class="line">            &#125;,2000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="多个reducer"><a href="#多个reducer" class="headerlink" title="多个reducer"></a>多个reducer</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//store.js</span><br><span class="line">import &#123;createStore,applyMiddleware,combineReducers&#125; from &apos;redux&apos;</span><br><span class="line">const store = createStore(</span><br><span class="line">    combineReducers(&#123;counterReducer,numberReducer&#125;), // 假如我们还有一个numberReducer</span><br><span class="line">    applyMiddleware(logger,thunk)</span><br><span class="line">);</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><h5 id="抽离Reducer-和Action"><a href="#抽离Reducer-和Action" class="headerlink" title="抽离Reducer 和Action"></a>抽离Reducer 和Action</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 新建 reducer.redux.js</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;</span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const add= ()=&gt;(&#123;type:&quot;add&quot;&#125;);</span><br><span class="line">const minus=()=&gt;(&#123;type:&quot;minus&quot;&#125;);</span><br><span class="line">// 支持这种返回一个函数的写法，就是因为用了thunk</span><br><span class="line">const asyncAdd =()=&gt;dispatch=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        dispatch(&#123;type:&quot;add&quot;&#125;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;counterReducer,add,minus,asyncAdd&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line">import * as serviceWorker from &apos;./serviceWorker&apos;;</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">import &#123;counterReducer&#125; from &quot;./couter.redux&quot;;</span><br><span class="line">// 新建store 第一个参数reducer 第二个参数中间件</span><br><span class="line">const store = createStore(counterReducer,applyMiddleware(logger,thunk));</span><br><span class="line">//import store from &quot;./store&quot;;       store.js文件就没有什么用了</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  App.js 直接引入reducer.redux.js的方法</span><br><span class="line">import &#123;add,minus,asyncAdd&#125; from &quot;./couter.redux&quot;;</span><br><span class="line">@connect(</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;add,minus,asyncAdd&#125;  //</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufh3GV.jpg" alt></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux理解</tag>
        <tag>Redux单向数据流</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react组件化</title>
    <url>/2019/02/12/react02/</url>
    <content><![CDATA[<ol>
<li><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li><h5 id="适用ant-design组件"><a href="#适用ant-design组件" class="headerlink" title="适用ant-design组件"></a>适用ant-design组件</h5><ul>
<li><p>起步安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>试用button组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Button from &apos;antd/lib/button&apos;</span><br><span class="line">import &apos;antd/dist/antd.css&apos;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;p&gt;hello world&lt;/p&gt;</span><br><span class="line">        &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置按需加载：上边组件如果使用就需要全部引用antd.css ,引用别的组件还得import</p>
<blockquote>
<p>安装react-app-rewired取代react-script，可以对webpack的配置进行扩展，类似于vue.config.js，</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install react-app-rewired@2.0.2-next.0 babel-plugin-import --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改package.json ,使用react-app-rewired</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">    <span class="string">"eject"</span>: <span class="string">"react-app-rewired eject"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>新增config-overrids.js文件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;injectBabelPlugin&#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config,env</span>) </span>&#123;</span><br><span class="line">    config =injectBabelPlugin(</span><br><span class="line">        [<span class="string">'import'</span>,&#123;<span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="string">'css'</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考官网使用 </p>
</li>
</ul>
<p>  [ant-desgin]: <a href="https://ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener">https://ant.design/docs/react/use-with-create-react-app-cn</a>    “ant-desgin”</p>
</li>
<li><h5 id="容器组件Vs展示组件"><a href="#容器组件Vs展示组件" class="headerlink" title="容器组件Vs展示组件"></a>容器组件Vs展示组件</h5><ul>
<li><p>基本原则：容器组件负责数据的获取，展示组件负责根据props显示信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CommentList extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            comments:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;ul&gt;</span><br><span class="line">            &#123;this.props.comments.map(value =&gt; &#123;</span><br><span class="line">                return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123; // 模拟一下ajax数据获取</span><br><span class="line">       setTimeout(()=&gt;&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               comments:[&quot;哈哈&quot;,&quot;嘻嘻&quot;,&quot;嘿嘿&quot;]</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行分离，分离成容器组件和展示组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CommentList extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            comments:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;CommentDetail comments=&#123;this.state.comments&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123; // 模拟一下ajax数据获取</span><br><span class="line">       setTimeout(()=&gt;&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               comments:[&quot;哈哈&quot;,&quot;嘻嘻&quot;,&quot;嘿嘿&quot;]</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将上边的组件进行拆分 显示组件和动作组件也就是获取数据的组件</span><br><span class="line">class CommentDetail extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;ul&gt;</span><br><span class="line">            &#123;this.props.comments.map(value =&gt; &#123;</span><br><span class="line">                return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上边显示组件 写成function的组件形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function CommentDetail(&#123;comments&#125;) &#123;</span><br><span class="line">    return &lt;ul&gt;</span><br><span class="line">        &#123;comments.map(value =&gt; &#123;</span><br><span class="line">            return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行分离的优势：</p>
<ol>
<li>能清楚的看到如何工作和如何展示</li>
<li>重用性高</li>
<li>更高的可用性</li>
<li>更易于测试</li>
</ol>
</li>
</ul>
</li>
<li><h5 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h5><blockquote>
<p>定制了shouldComponentUpdate后的Component（进行浅比较）</p>
</blockquote>
<ul>
<li><p>形式 :直接使用 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Comp extends PureComponent&#123; ....&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原理：定制shouldComponentUpdate生命周期，如果props没变化，阻止渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// 如果nextProps的内容等于this.porps,nextState的内容等于this.state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 : 如果不写shouldComponentUpdate这个生命周期的对比，则不管title变不变都重新渲染，但是使用了PureComponent或者加上下边生命周期 ，title不变就不会重新渲染，其PureComponent就是通过shouldComponentUpdate定制了一个组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TitleDisplay extends Component&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;  // 通过对比</span><br><span class="line">        if (nextProps.title ===this.props.title)&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&apos;title重新渲染了&apos;);</span><br><span class="line">        return &lt;h2&gt;</span><br><span class="line">            &#123;this.props.title&#125;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点 ：只有class 形式的组件才能使用PureComponent这个功能</p>
</li>
<li><p>React16 新增一个新功能React.memo 来完美实现React组件，让函数式的组件也有PureComponent的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TitleDisplay =React.memo(props=&gt;&#123;  // 函数式组件的</span><br><span class="line">    return &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><h5 id="HOC高阶组件：高阶组件一般都是以with开头进行命名"><a href="#HOC高阶组件：高阶组件一般都是以with开头进行命名" class="headerlink" title="HOC高阶组件：高阶组件一般都是以with开头进行命名"></a>HOC高阶组件：高阶组件一般都是以with开头进行命名</h5><blockquote>
<p>提高组件的复用率，首先想到就是抽离相同的逻辑，在React里就有了Hoc的概念，高阶组件也是一个组件，但是它返回另外一个组件。产生的新的组件可以对属性进行包装也可以重写部分生命周期</p>
</blockquote>
<ul>
<li><p>简单的高阶组件实现：高阶组件增加属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import App from &apos;./App&apos;;</span><br><span class="line">import * as serviceWorker from &apos;./serviceWorker&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App  age=&quot;18&quot; /&gt;,  //这个age =18的属性后边的&#123;...props&#125;就可以接收到</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const withKaikeba = (Component)=&gt;&#123;</span><br><span class="line">    const newComp = props=&gt;&#123;    // 这个newComp是一个函数式的组件</span><br><span class="line">        console.log(props);</span><br><span class="line">        return &lt;Component &#123;...props&#125; name=&quot;开课吧高阶组件测试&quot;  /&gt;  </span><br><span class="line">// 将全部的props展开添加进属性中 比如在index.js中使用了App这个组件那么他的props就会传递进来</span><br><span class="line">    &#125;;</span><br><span class="line">    return newComp</span><br><span class="line">&#125;;</span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;XXX&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">App = withKaikeba(App);  //使用这个组件</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单的高阶组件实现：定制组件的生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const withLog = Component=&gt;&#123;</span><br><span class="line">    class NewComponent extends Component&#123;</span><br><span class="line">        componentWillMount() &#123;</span><br><span class="line">            console.time(&apos;ComponentRender&apos;);</span><br><span class="line">            console.log(`组件$&#123;Component.name&#125;准备完毕了`)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;Component &#123;...this.props&#125; /&gt;  //这也是展开props属性</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            console.timeEnd(&apos;ComponentRender&apos;)</span><br><span class="line">            console.log(`组件$&#123;Component.name&#125;渲染完毕了`)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return NewComponent;</span><br><span class="line">&#125;;</span><br><span class="line">App = withKaikeba(withLog(App)); //  高阶组价支持链式调用</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
<li><h5 id="高阶组件的装饰器写法"><a href="#高阶组件的装饰器写法" class="headerlink" title="高阶组件的装饰器写法"></a>高阶组件的装饰器写法</h5><blockquote>
<p>上边的链式操作比较繁琐 ，逻辑比较绕，ES7中有一个优秀的语法——装饰器，专门处理这种问题</p>
</blockquote>
<ul>
<li><p>安装babel插件，用于解析Babel 5中的旧装饰器行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-transform-decorators-legacy</span><br></pre></td></tr></table></figure>
</li>
<li><p>在config-overrides.js进行扩展，才能编译 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;injectBabelPlugin&#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config,env</span>) </span>&#123;</span><br><span class="line">    config =injectBabelPlugin( <span class="comment">// 这是为能够按需加载的扩展</span></span><br><span class="line">        [<span class="string">'import'</span>,&#123;<span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="string">'css'</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    config=injectBabelPlugin(   <span class="comment">// 这是为支持装饰写法的扩展</span></span><br><span class="line">        [<span class="string">'@babel/plugin-proposal-decorators'</span>,&#123;<span class="attr">legacy</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后直接使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@withKaikeba</span><br><span class="line">@withLog   </span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;XXX&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// App = withKaikeba(withLog(App));</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h5><ul>
<li><p>父组件向子组件通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Child extends Component&#123;  //  class 组件</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.props.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Child(props) &#123;    // 函数式组件</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &#123;props.name&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Child name=&#123;&quot;向子组件传递值&quot;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件向父组件通信 ——利用回调函数</p>
<blockquote>
<p>这块有必要说一下 ，在 cb={this.callback.bind(this)} ，由于cb是子组件传递过来的，msg当然应该绑定cb函数本身，不能绑定App组件的this也就是用箭头函数不能获取到传递的值</p>
<p>彻底理解可以参考</p>
<p>[彻底理解javascript中的this]: <a href="https://juejin.im/post/5c049e6de51d45471745eb98" target="_blank" rel="noopener">https://juejin.im/post/5c049e6de51d45471745eb98</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Child(props) &#123;    // 子组件</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &#123;props.name&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;props.cb(&apos;子组件传递的值&apos;)&#125;&gt;点击我传递&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">class App extends Component&#123;  //父组件</span><br><span class="line">    callback (msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Child name=&#123;&quot;向子组件传递值&quot;&#125;  cb=&#123;this.callback.bind(this)&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨级组件之间通信：使用 context 对象上下文(Context) 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性</p>
<h5 id="React-createContext：-const-Provider-Consumer-React-createContext-defaultValue"><a href="#React-createContext：-const-Provider-Consumer-React-createContext-defaultValue" class="headerlink" title="React.createContext：  const {Provider, Consumer} = React.createContext(defaultValue);"></a>React.createContext：  const {Provider, Consumer} = React.createContext(defaultValue);</h5><h5 id="Provider-提供者-lt-Provider-value-some-value-gt"><a href="#Provider-提供者-lt-Provider-value-some-value-gt" class="headerlink" title="Provider :提供者&lt;Provider value={/ some value /}&gt;"></a>Provider :提供者&lt;Provider value={/<em> some value </em>/}&gt;</h5><h5 id="Consumer-订阅者-lt-Consumer-gt-value-gt-…-lt-Consumer-gt"><a href="#Consumer-订阅者-lt-Consumer-gt-value-gt-…-lt-Consumer-gt" class="headerlink" title="Consumer:订阅者 &lt; Consumer&gt; {value =&gt; {…}} &lt; /Consumer&gt;"></a>Consumer:订阅者 &lt; Consumer&gt; {value =&gt; {…}} &lt; /Consumer&gt;</h5><blockquote>
<p>vuejs中可以使用privide&amp;inject模式来进行组件之间的通信，这个模式的来源–context</p>
<p>react中也有两个角色，Provider和Consumer，Provider在外层组件，内部需要数据，就使用Consumer来读取</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;store&#125; from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">const AppContext = React.createContext();  //新建上下文 ，Provider和Consumer可以拆分出去</span><br><span class="line">const &#123;Provider,Consumer&#125; =AppContext;  </span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line">    render() &#123;  //  下边使用Consumer来进行接收</span><br><span class="line">        return &lt;Consumer&gt;   </span><br><span class="line">            &#123;</span><br><span class="line">                //  下边这块其实就是一个函数式的组件</span><br><span class="line">                store=&gt;&#123;</span><br><span class="line">                    return &lt;Button</span><br><span class="line">                        type=&#123;&quot;primary&quot;&#125;</span><br><span class="line">                        onClick=&#123;()=&gt;store.sayHi()&#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                        &#123;store.name&#125;</span><br><span class="line">                        &lt;/Button&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/Consumer&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class App  extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        // 直接进行嵌套 ,value是固定写法</span><br><span class="line">        return &lt;Provider value=&#123;store&#125;&gt;</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">                 &lt;h1&gt;哈喽啊！小年依旧学习React&lt;/h1&gt;</span><br><span class="line">                 &lt;Demo/&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="其他多数据的组件通信就可以使用Redux进行"><a href="#其他多数据的组件通信就可以使用Redux进行" class="headerlink" title="其他多数据的组件通信就可以使用Redux进行"></a>其他多数据的组件通信就可以使用Redux进行</h5></li>
<li><h5 id="实现createContext-？-createContext就是一个高阶组件，结合用法去理解"><a href="#实现createContext-？-createContext就是一个高阶组件，结合用法去理解" class="headerlink" title="实现createContext ？ createContext就是一个高阶组件，结合用法去理解"></a>实现createContext ？ createContext就是一个高阶组件，结合用法去理解</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  createContext初始化 简单的实现原理</span><br><span class="line">import React ,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">function createContext() &#123;</span><br><span class="line">    let instance = &#123;   // 1. 先声明一个对象初始化value</span><br><span class="line">        value:null</span><br><span class="line">    &#125;;</span><br><span class="line">    class Provider extends Component&#123;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">            instance.vlaue = props.value   // 2. 赋给instance的value</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return this.props.children     // 3.这块类似于vuejs的&lt;slot&gt;&lt;/slot&gt;  扩展</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Consumer extends Component&#123;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state=&#123;</span><br><span class="line">                value:instance.vlaue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return this.props.children(this.state.value)    // 4.这块就是一个函数，将instance.value 传递进去</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;Provider,Consumer&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><h3 id="React未来"><a href="#React未来" class="headerlink" title="React未来"></a>React未来</h3><ul>
<li>Fiber：异步渲染 ,底层在实现虚拟Dom中实现了类似CPU调度的功能，</li>
<li>Suspense ：用同步的代码实现异步的操作</li>
<li>Hooks:开发者可以完全抛弃class ，拥抱函数式编程</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react组件化</tag>
        <tag>React开发模式</tag>
        <tag>高阶组件</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs文件上传及操作</title>
    <url>/2018/08/13/rename/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/UfRnbR.jpg" alt="Travel beijing shidu"></p>
<blockquote>
<p>周末公司组织出去玩，进行拓展活动，当时就意识到了团队协作的重要性，然后又去漂流打水战，哈哈哈！！！虽然现在腿儿疼胳膊疼的，但是很充实，现在仍旧精力充沛的进行搬砖。</p>
<h3 id="nodejs上传图片到服务器实现"><a href="#nodejs上传图片到服务器实现" class="headerlink" title="nodejs上传图片到服务器实现"></a>nodejs上传图片到服务器实现</h3><ol>
<li>form表单上传类型（注意：enctype=”multipart/form-data”）<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">action</span>=<span class="string">"http://localhost:8080"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    文件: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"f1"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>  <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<ol start="2">
<li>初步上传<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> pathLib = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objMulter = multer(&#123;<span class="attr">dest</span>:<span class="string">'./www/upload'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> server =express();</span><br><span class="line">server.use(objMulter.any());</span><br><span class="line">server.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/07/20/UfRmr9.jpg" alt="Travel beijing shidu"></p>
<p>3.上图我们可以发现上传的图片并没有类型 所以我们需要对文件进行操作<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> pathLib = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objMulter = multer(&#123;<span class="attr">dest</span>:<span class="string">'./www/upload'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> server =express();</span><br><span class="line">server.use(objMulter.any());</span><br><span class="line">server.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  <span class="comment">// 新的文件名 = ./www/upload/650193c2aa10b91571fafa87cc0013eb' + 'png'</span></span><br><span class="line">  <span class="comment">// res.files  是指所有的上传的文件</span></span><br><span class="line">  <span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfRKV1.jpg" alt="Travel beijing shidu"></p>
<ol start="4">
<li>我们新文件名= req.files[0].path+扩展名<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> multer = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> pathLib = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> objMulter = multer(&#123;<span class="attr">dest</span>:<span class="string">'./www/upload'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server =express();</span><br><span class="line">server.use(objMulter.any());</span><br><span class="line">server.post(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">  <span class="comment">//新的文件名 = ./www/upload/650193c2aa10b91571fafa87cc0013eb' + 'png'</span></span><br><span class="line">  <span class="comment">// res.files  是指所有的上传的文件</span></span><br><span class="line">  <span class="keyword">var</span> newName = req.files[<span class="number">0</span>].path +pathLib.parse(req.files[<span class="number">0</span>].originalname).ext;</span><br><span class="line">  <span class="built_in">console</span>.log(newName);</span><br><span class="line"><span class="comment">//-------进行重命名</span></span><br><span class="line">fs.rename(req.files[<span class="number">0</span>].path, newName, (err)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">      res.send(<span class="string">'上传失败'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      res.send(<span class="string">'上传成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/07/20/UfReKJ.jpg" alt="Travel beijing shidu"><br><img src="https://s1.ax1x.com/2020/07/20/UfRVv4.jpg" alt="Travel beijing shidu"></p>
<h4 id="打完收功，有不对之处望大牛指出。"><a href="#打完收功，有不对之处望大牛指出。" class="headerlink" title="打完收功，有不对之处望大牛指出。"></a>打完收功，有不对之处望大牛指出。</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>nodejs图片上传</tag>
      </tags>
  </entry>
  <entry>
    <title>ssr首屏渲染你懂了么？</title>
    <url>/2020/12/30/ssr/</url>
    <content><![CDATA[<blockquote>
<p>被迫营业—人间不值得，时隔两天我又来了，主要是我太爱东搞搞西搞搞啦，太爱学习也是一种负担啊，（被迫营业），这么冷的天还要努力学习看东西（人间不值得），这两天真的是冷啊。冷的冻掉了鼻子，不知道是鼻子太大还是天气太冷总有一种传了多少的裤子还是没穿一样，走在路上心里恐慌得不行，生怕哪个草丛跳出来三个壮汉一个姓德名马一个姓德名邦 一个姓德名…不对不对。蛮王不姓德。回来讲正事，一直对首屏渲染得实施方案有些好奇，因为开发成本太高所以也没有实战过一下。今天就整理一下最近对ssr的理解吧，不喜勿喷纯做个人记录。</p>
</blockquote>
<ol>
<li><h4 id="服务端渲染定义"><a href="#服务端渲染定义" class="headerlink" title="服务端渲染定义"></a>服务端渲染定义</h4><p>讲这个之前必不可少需要讲一下页面的渲染流程</p>
<ol>
<li>浏览器通过请求得到一个HTML文本</li>
<li>渲染进程解析HTML文本，构建DOM树</li>
<li>解析HTML的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到JavaScript脚本，则会下载执行脚本</li>
<li>DOM树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）</li>
<li>渲染进程开始对渲染树进行布局，生成布局树（layout tree）</li>
<li>渲染进程对布局树进行绘制，生成绘制记录</li>
<li>渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧</li>
<li>渲染进程将合成帧信息发送给GPU进程显示到页面中</li>
</ol>
<p><img src="https://s3.ax1x.com/2020/12/30/rLuY8K.png" alt></p>
<p>从图中我们可以发现，浏览器从接收到HTML到渲染成页面经历很多步骤。当前流行的前端框架都是使用了javascript进行页面渲染的也就是说在执行 JavaScript 脚本的时候，HTML页面已经开始解析并且构建DOM树了，JavaScript 脚本只是动态的改变 DOM 树的结构，使得页面成为希望成为的样子，这种渲染方式叫动态渲染，也可以叫客户端渲染。</p>
<p>服务端渲染：顾名思义，服务端渲染就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。这个服务端组装HTML的过程，叫做服务端渲染。以我的话来讲就是后端服务器返回html的字符串然后直接喂给浏览器，其实就是一个静态页面的感觉，这样浏览器干的工作是真滴少啊，这样浏览器那反应肯定哇哇快</p>
</li>
</ol>
<p>   <img src="https://s3.ax1x.com/2020/12/31/rX6P4s.png" style="zoom: 50%;"></p>
<hr>
<p>   虽然很长的文字但要耐心读完收益匪浅</p>
<ol start="2">
<li><h4 id="ssr-发展的由来（远古时代一神统领到众神争霸）"><a href="#ssr-发展的由来（远古时代一神统领到众神争霸）" class="headerlink" title="ssr 发展的由来（远古时代一神统领到众神争霸）"></a>ssr 发展的由来（远古时代一神统领到众神争霸）</h4><ol>
<li><h5 id="WEB1-0-的时代（远古圣王）"><a href="#WEB1-0-的时代（远古圣王）" class="headerlink" title="WEB1.0 的时代（远古圣王）"></a>WEB1.0 的时代（远古圣王）</h5><p>远古时代我们可能没有经历过，但是asp 、jsp这些可能都听说过吧 ，所有的应用都是服务端渲染（这时候的服务端渲染和我们现在说的服务端渲染不一样），话说那个时候页面渲染完全由服务端承担，浏览器请求页面的url ，然后服务器接受到请求之后，到数据库查询。将数据丢到后端的模版（asp、jsp）渲染成html片段组装片段 最后返回给浏览器。这个时候返回的HTML已经是完整的了包含js什么的，渲染到页面的过程中没有Javascript的参与。如图讲述</p>
<p><img src="https://s3.ax1x.com/2020/12/30/rLh8oD.png" style="zoom:50%;"></p>
<p><u>页面的F12  查看张这样</u></p>
<p><img src="https://s3.ax1x.com/2020/12/30/rL5grq.png" style="zoom: 25%;"></p>
</li>
<li><h5 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h5><p>讲一点题外话：WEB1.0时代那样的服务器渲染缺点越来越严重，每次更新页面上的一个小的地方不管是文字还是其他的小模块，都需要重新请求一次页面，重新查一遍数据库，重新组成一个HTML。javascript 代码和后端的PHP代码混在一起。越来越难搞。当然在这个时候前端职位很低 ，前端的工作经常是后端人员一把梭哈，前端人员经常被后端人员支配，支配的恐惧来袭，前后端鄙视链开始了，因为前端程序猿只是再写写js 做做页面交互，不算事真正的程序猿。</p>
<p>之后nodejs出现，前端看到了翻身的契机，为了摆脱后端的指指点点，前端开启了一场前后端分离的运动，希望可以脱离后端独立发展。前后端分离，表面上看上去是代码分离，实际上是为了前后端人员分离（到这里不得不说前端人员的心机真的是哈哈哈哈哈），也就是前后端分家，前端不再归属于后端团队。</p>
<p>前后端分离之后，网页开始被当成了独立的应用程序（SPA，Single Page Application），前端团队接管了所有页面渲染的事，后端团队只负责提供所有数据查询与处理的API</p>
<p>大体流程是这样的：首先浏览器请求URL，前端服务器直接返回一个空的静态HTML文件（不需要任何查数据库和模板组装），这个HTML文件中加载了很多渲染页面需要的 JavaScript 脚本和 CSS 样式表，浏览器拿到 HTML 文件后开始加载脚本和样式表，并且执行脚本，这个时候脚本请求后端服务提供的API，获取数据，获取完成后将数据通过JavaScript脚本动态的将数据渲染到页面中，完成页面显示。</p>
<p><img src="https://s3.ax1x.com/2020/12/30/rOPTAO.jpg" style="zoom: 50%;"></p>
<p><u>页面的F12  查看张这样</u></p>
<p><img src="https://s3.ax1x.com/2020/12/30/rLODit.png" style="zoom: 33%;"></p>
</li>
<li><h5 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h5><p>终于讲到我们的正题了，随着单页面应用的发展。人们渐渐发现了一个东西啊，诶SEO出现问题了啊，搜索引擎很难爬到东西啊。而且应用越来越复杂javaScript越来越臃肿啊，使得首屏渲染的时间要比WEB1.0慢了啊。这可是大问题啊 ，<strong>强调一下首屏并不是首页（划重点）</strong>。</p>
<p>这没得办法勒 ，总不能再回去受后台人员支配吧？支配的恐惧又来了哈哈哈哈，怎么办 自己选的路跪着也要走完，于是前端团队又开始了，我发现这前端真是能折腾啊（不过我喜欢哈哈哈）</p>
<p>于是前端团队选择了使用 nodejs 在服务器进行页面的渲染，进而再次出现了服务端渲染。大体流程与客户端渲染有些相似，</p>
<ol>
<li>首先是浏览器请求URL，前端服务器接收到URL请求之后，根据不同的URL，前端服务器向后端服务器请求数据，请求完成后，</li>
<li>前端服务器会组装一个携带了具体数据的HTML文本，并且返回给浏览器，浏览器得到HTML之后开始渲染页面</li>
<li>同时，浏览器加载并执行 JavaScript 脚本，给页面上的元素绑定事件，让页面变得可交互，当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，</li>
<li>向后端服务器请求数据，获取完数据之后再次执行 JavaScript 代码动态渲染页面。 你们知道的该上图了啊</li>
</ol>
<p><img src="https://s3.ax1x.com/2020/12/30/rOlO2t.png" style="zoom: 33%;"></p>
</li>
</ol>
</li>
<li><h4 id="服务端渲染的优缺点"><a href="#服务端渲染的优缺点" class="headerlink" title="服务端渲染的优缺点"></a>服务端渲染的优缺点</h4><p>优点有二</p>
<ol>
<li>利于SEO ，不言而喻 ，相比于一个空壳的div块来说，页面上显示更多内容更利于爬虫来爬你的页面，这样流量也就会越高搜索引擎收录也就会越多。</li>
<li>白屏时间更多，相比于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个呆数据的的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以了。而客户端需要先得到一个空的HTML页面，这几个时候页面进入了白屏状态，之后还需要经过加载并执行javascript，请求后端获取数据、Javascript渲染页面的几个过程才能看到最后的页面，时间长体验差。</li>
</ol>
<p>缺点</p>
<ol>
<li>为实现服务端渲染，代码复杂度增大，代码中的需要兼容服务端和客户端两种运行情况。</li>
<li>需要更多的负载均衡，服务器压力大</li>
<li>部署和构建的设置的要求更高需要懂Nodejs</li>
</ol>
</li>
<li><h4 id="Vue-进行剖析实践-终于要上代码啦-（-画图真的很难）"><a href="#Vue-进行剖析实践-终于要上代码啦-（-画图真的很难）" class="headerlink" title="Vue 进行剖析实践 终于要上代码啦 （ 画图真的很难）"></a>Vue 进行剖析实践 终于要上代码啦 （ 画图真的很难）</h4><p><a href="https://s3.ax1x.com/2020/12/30/rOlO2t.png" target="_blank" rel="noopener">下一篇地址</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Node</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title>react-router</title>
    <url>/2019/03/15/react-router/</url>
    <content><![CDATA[<blockquote>
<p>使用react怎么能少了router的使用</p>
</blockquote>
<h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><ul>
<li><h5 id="使用react-router-dom进行路由"><a href="#使用react-router-dom进行路由" class="headerlink" title="使用react-router-dom进行路由"></a>使用react-router-dom进行路由</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom --save</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><blockquote>
<p>相比于vuejs的模式使用react略有不同 ，vue的模式是在配置里边设置是否使用history模式，而react则是通过使用不同的组件来使用history模式还是hash模式</p>
</blockquote>
<ul>
<li>HashRouter ：哈希模式</li>
<li>BrowserRouter：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;BrowserRouter,HashRouter&#125; from &quot;react-router-dom&quot;</span><br><span class="line">//在外层再包一层HashRouter或者BrowserRouter</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;App /&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    &lt;/HashRouter&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  app.js   </span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/detail&quot;&gt;详情&lt;/Link&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Counter&#125;/&gt;  // exact 全部匹配根路径</span><br><span class="line">            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">            &lt;Route path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function About() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;关于页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">function Detail() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;这是我们的详情页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h5><blockquote>
<p>和vue路由的使用一样 ，是使用：id的形式定义参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  使用 detail </span><br><span class="line">&lt;Route path=&quot;/detail/:id&quot; component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">function Detail(props) &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Detail:&#123;props.match.params.id&#125;&lt;/p&gt;  </span><br><span class="line">        &lt;h2&gt;这是我们的详情页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="Redirect-：跳转"><a href="#Redirect-：跳转" class="headerlink" title="Redirect ：跳转"></a>Redirect ：跳转</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Redirect to=&quot;/&quot;&gt; &lt;/Redirect&gt;  // 跳转到连接</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><h5 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h5><p>redux + redux-sage + react-redux + react-router-dom = dva</p>
</li>
<li><h5 id="使用的react-router-dom"><a href="#使用的react-router-dom" class="headerlink" title="使用的react -router-dom"></a>使用的react -router-dom</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install react-router-dom --save</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h5><blockquote>
<p>使用模式相比于vuejs不同，vue里面是配置是否使用history模式，而react中是使用不同的组件进行区分</p>
</blockquote>
<p>HashRouter</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title>React 入门</title>
    <url>/2019/02/01/react01/</url>
    <content><![CDATA[<ol>
<li><h3 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h3><ul>
<li><p>安装官方脚手架 ，后边的脚手架更加好用，但由于官方推荐开始先试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化—创建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create-react-app 项目名</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="JSX-看起来是js和html的混合体，但实际上html也是由js实现"><a href="#JSX-看起来是js和html的混合体，但实际上html也是由js实现" class="headerlink" title="JSX:看起来是js和html的混合体，但实际上html也是由js实现"></a>JSX:看起来是js和html的混合体，但实际上html也是由js实现</h3><blockquote>
<p>React设计之初，就是使用JSX来描述UI，react只做逻辑层，reactDom去做渲染实际的dom，如果换到移动端，就用别的渲染库</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        Hello world！</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,      //</span><br><span class="line">    document.getElementById(&apos;root&apos;)  //这里的root元素是在index.html中的dom元素</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhWdA.jpg" alt></p>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhfII.jpg" alt></p>
</li>
<li><h3 id="组件定义"><a href="#组件定义" class="headerlink" title="组件定义"></a>组件定义</h3><blockquote>
<p>在上边的代码中我们也可以看到class类在react中就是组件 ，然后使用对应的标签<app></app></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import App from &apos;./App&apos;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        Hello world！</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="state和setState"><a href="#state和setState" class="headerlink" title="state和setState"></a>state和setState</h3><ul>
<li><p>使用{ }来渲染变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const name = &apos;你好啊&apos;;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123;name&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是如果数据需要修改，并且同时页面响应变化，就需要将数据放在state中，并且使用setState来修改数据，super（props）是调用父级的construtor，来初始化各种生命周期啊，this指向等等数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">          name:&apos;开课吧&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123; this.state.name &#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用setState来修改数据 ,使用this.state每次传的是一个<strong>新对象</strong>，这样好处就是可以做时间旅行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">          name:&apos;开课吧&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">          this.setState(&#123;</span><br><span class="line">              name:&apos;开课吧真不错&apos;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123; </span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123; this.state.name &#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="属性传递-props"><a href="#属性传递-props" class="headerlink" title="属性传递 props"></a>属性传递 props</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;App title=&quot;今天开始React&quot; /&gt;, //使用的时候</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">       return (</span><br><span class="line">           &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">               &lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="条件渲染和循环"><a href="#条件渲染和循环" class="headerlink" title="条件渲染和循环"></a>条件渲染和循环</h3><ul>
<li><p>条件渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showTitle:true</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                showTitle: false  // 2秒之后改变成隐藏 </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;          </span><br><span class="line">                &#123;this.state.showTitle?&lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;:null&#125;</span><br><span class="line">                &lt;!--其实这相当于v-if和v-else null那块是else的内容 --&gt; </span><br><span class="line">                &#123;this.state.showTitle&amp;&amp;&lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;&#125;</span><br><span class="line">                 &lt;!--直接这样写就是v-if功能 --&gt; </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">    goodlist:[</span><br><span class="line">        &#123;text:&apos;百万年薪架构师&apos;,price:100,id:1&#125;,</span><br><span class="line">        &#123;text:&apos;web全栈架构师&apos;,price:100,id:2&#125;,</span><br><span class="line">        &#123;text:&apos;Python&apos;,price:100,id:3&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line">       return (</span><br><span class="line">           &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">               &lt;ul&gt;</span><br><span class="line">                   &#123;this.state.goodlist.map(good=&gt;&#123;</span><br><span class="line">                       return &lt;li key=&#123;good.id&#125;&gt;</span><br><span class="line">                           &lt;span&gt;&#123;good.text&#125;&lt;/span&gt;</span><br><span class="line">                           &lt;span&gt;￥&#123;good.price&#125;&lt;/span&gt;</span><br><span class="line">                       &lt;/li&gt;</span><br><span class="line">                   &#125;)&#125;</span><br><span class="line">               &lt;/ul&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h3 id="数据的管理和绑定"><a href="#数据的管理和绑定" class="headerlink" title="数据的管理和绑定"></a>数据的管理和绑定</h3><ul>
<li><p>数据的绑定  </p>
<ul>
<li>在react中由于强制的单向数据流，数据绑定的input不能像vue中的那样双向数据修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(e)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            add:e.target.value //这样就是实现了input的双向绑定</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#123;/*由于value绑定了this.state react是强制的单项数据流，那么value就会被this.state数据监控，现在state的值不变value就不变*/&#125;</span><br><span class="line">&#123;/*当我们进行输入的时候会触发一个onchang事件 ，我们利用这个实现我们的双向绑定*/&#125;</span><br><span class="line">&#123;/*利用e.target.value 获得我们输入的值，然后进行对state中数据的修改,然后我们的input中value也会自动进行修改*/&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现将input中的数据，添加到上面state的goodlist数据中去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;this.handleAdd()&#125;&#125;&gt;添加&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleAdd()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        goodlist:[...this.state.goodlist,&#123;text:this.state.add,price:20&#125;],</span><br><span class="line">        add:&apos;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件绑定 </p>
<blockquote>
<p>上边的实现将input数据添加到goodlist中去的时候，那个onChange写的太繁琐对不对，我们想到把函数拿出去写，但是会<strong>报错</strong>，是因为this指向问题，因为当使用onChange={this.handleChange}这种写法时，把handleChange这个函数当成参数传递给了当前组件，组件再去调用自己的内部的this，取向值已经变了，因为这个函数的是给别人用的（谁用的这个函数，this指向谁）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; onChange=&#123;this.handleChange&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; handleChange(e)&#123;</span><br><span class="line">&gt;  this.setState(&#123;</span><br><span class="line">&gt;      add:e.target.value </span><br><span class="line">&gt;  &#125;)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>解决上边的问题有三种方案</strong></p>
<ul>
<li><p>在constructor(props) {}的时候 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);  </span><br><span class="line"><span class="comment">// 这个函数任何时候执行，this都是我们当前组件的this</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用箭头函数，解决this指向问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(e)=&gt;this.handleChange(e)&#125;  </span><br><span class="line">    /&gt;</span><br><span class="line">//但是如果传参的话 onClick=&#123;this.handleClick(i)&#125;直接这样写就直接执行了</span><br><span class="line">//onClick = &#123;this.handleClick&#125;</span><br><span class="line">//但是 这个函数 需要携带一个 i 的参数过去</span><br><span class="line">//所以 就要用一个匿名函数把i 带过去啊。。</span><br><span class="line">//onClick = &#123;()=&gt; this.handleClick(i)&#125;</span><br><span class="line">//这样闭包 让 i 对 renderSquare 的i 保持引用</span><br><span class="line"></span><br><span class="line">//-----传参数的函数需要两次箭头函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接在onChange时候使用bind(this)，并不推荐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(this.handleChange.bind(this)&#125;  //和我们上边你的添加按钮一样</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义handleChang的时候直接使用箭头函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleChange=(e)=&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        add:e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="函数组件-："><a href="#函数组件-：" class="headerlink" title="函数组件 ："></a>函数组件 ：</h4><blockquote>
<p>如果一个组件只根据props进行渲染，没有内部的state，我们完全可以使用函数式组件的形式来实现</p>
<p>其实认真观察  函数式组件和class 组件的 props 是有区别的函数式props是通过参数传递就没有this</p>
<p>class的组件是有this的一般都是this.props</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数式组件</span><br><span class="line">function Title(props) &#123;   // React的函数式组件props就是传递的值props.title也能直接取到</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;hr/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Title title=&#123;this.props.title&#125; /&gt;  //使用的时候和组件一样</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><blockquote>
<p>通过props进行通信</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function Totol(&#123;cart&#125;)&#123;</span><br><span class="line">    return &lt;span&gt;</span><br><span class="line">        总价:&#123;cart.reduce((sum,a)=&gt;&#123;</span><br><span class="line">            return sum += a.price*a.count</span><br><span class="line">    &#125;,0)&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&#125;</span><br><span class="line">class Cart extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;商品名&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;总价&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &#123;this.props.data.map(good=&gt;&#123;</span><br><span class="line">                        return&lt;tr key=&#123;good.text&#125;&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.text&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.price&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.count&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.count*good.price&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                    &#125;)&#125;</span><br><span class="line">                    &#123;/*使用组件做一个总价*/&#125;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td colSpan=&quot;4&quot; align=&quot;right&quot;&gt;</span><br><span class="line">                            &lt;Totol cart=&#123;this.props.data&#125; /&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Cart</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AddCart(good)&#123;</span><br><span class="line">    let cartIndex;</span><br><span class="line">    const cartGood = this.state.cart.find((value,index) =&gt; &#123;</span><br><span class="line">        if (good.text === value.text) &#123;</span><br><span class="line">            cartIndex = index;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (cartGood)&#123;</span><br><span class="line">        // 我们要知道我们找到的是第几个,因为我们不能直接修改</span><br><span class="line">        let newCart = [...this.state.cart];</span><br><span class="line">        newCart[cartIndex].count+=1;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            cart:newCart</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            cart:[...this.state.cart,&#123;</span><br><span class="line">                text:good.text,</span><br><span class="line">                price:good.price,</span><br><span class="line">                count:1</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Cart data=&#123;this.state.cart&#125;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="10">
<li><h4 id="利用react的每一次都需要setState使用一个新的对象-实现类似时间旅行功能"><a href="#利用react的每一次都需要setState使用一个新的对象-实现类似时间旅行功能" class="headerlink" title="利用react的每一次都需要setState使用一个新的对象{实现类似时间旅行功能"></a>利用react的每一次都需要setState使用一个新的对象{实现类似时间旅行功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//新加一个state的cartHistory:[]来记录</span><br><span class="line">在每次操作都将操作的数据记录，然后点击返回对应步骤的cartHistory</span><br><span class="line">this.setState(&#123;</span><br><span class="line">	cartHistory:[...this.state.cartHistory,this.state.cart]</span><br><span class="line">&#125;)</span><br><span class="line">resetCart(i)&#123;  //点击的事件处理</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">    	cart:this.state.cartHistory[i]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><blockquote>
<p>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</p>
<p>在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。</p>
<p>虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。</p>
</blockquote>
<ul>
<li>传统APP：</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhgqH.jpg" alt></p>
<ul>
<li>React App:</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/20/UfhRZd.jpg" alt></p>
<ul>
<li>innerHTML：render html字符串 + 重新创建所有的DOM元素</li>
<li>虚拟DOM：render 虚拟DOM + diff + 更新必要的DOM元素</li>
<li>原理：React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</li>
</ul>
</li>
<li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/07/20/Ufh4it.jpg" alt></p>
<ul>
<li><p>初始化</p>
<ol>
<li><p>getDefaultProps()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置默认的props，也可以用defaultProps设置组件的默认属性</span><br><span class="line">这个方法只会调用一次，该组件类的所有后续应用，getDefaultPops 将不会再被调用，其返回的对象可以用于设置默认的 props(properties的缩写) 值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>getInitialState()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个方法的调用有且只有一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props。每一个React组件都有自己的 state，其与 props 的区别在于 state只存在组件的内部，props 在所有实例中共享。</span><br><span class="line">getInitialState 和 getDefaultPops 的调用是有区别的，getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用，而 getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</span><br></pre></td></tr></table></figure>
</li>
<li><p>componentWillMount()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该方法在  首次(也就是只调用一次) 渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</span><br></pre></td></tr></table></figure>
</li>
<li><p>render()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点：</span><br><span class="line">1.只能通过 this.props 和 this.state 访问数据（不能修改）</span><br><span class="line">2.可以返回 null,false 或者任何React组件</span><br><span class="line">3.只能出现一个顶级组件，不能返回一组元素</span><br><span class="line">4.不能改变组件的状态</span><br><span class="line">5.不能修改DOM的输出</span><br><span class="line">render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。react之所以效率高，就是这个原因。</span><br></pre></td></tr></table></figure>
</li>
<li><p>componentDidMount()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件渲染之后调用，只调用一次</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code>- 更新 ：

  &gt; 此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用

  1. componentWillReceiveProps(nextProps)

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。</span><br></pre></td></tr></table></figure>

  2. shouldComponentUpdate(nextProps, nextState)

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候</span><br><span class="line">该方法是非必须的，并且大多数情况下没有在开发中使用。</span><br></pre></td></tr></table></figure>

  3. componentWillUpdata(nextProps, nextState)

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个方法和 componentWillMount 类似，在组件接收到了新的 props 或者 state 即将进行重新渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。</span><br></pre></td></tr></table></figure>

  4. render()

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新之后再次进行组件渲染</span><br></pre></td></tr></table></figure>

  5. componentDidUpdate()

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个方法和 componentDidMount 类似，在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM</span><br></pre></td></tr></table></figure>

- 销毁

  1. componentWillUnmount()

     <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行，完成所有的清理和销毁工作，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React入门</tag>
        <tag>create-react-app</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂this指向问题</title>
    <url>/2019/03/08/this/</url>
    <content><![CDATA[<blockquote>
<p>this问题几乎是老生常谈的问题了 ，其实真正问起来自己也是很模糊，今天趁着女神节的日子彻底弄懂这个问题，永绝后患。</p>
</blockquote>
<p>在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该活动对象的属性和值；将该函数体内显示声明的变量和函数，也添加为该活动的的属性（在刚进入该函数执行环境时，未赋值，所以值为undefined，这个是JS的提前声明机制）。</p>
<ol>
<li><h4 id="this四种场景逐一击破"><a href="#this四种场景逐一击破" class="headerlink" title="this四种场景逐一击破"></a>this四种场景逐一击破</h4><blockquote>
<p>打仗之前我先来两个锦囊</p>
<ul>
<li>函数被调用时（运行时）才会确定该函数内的this指向。因为在函数中this与arguments是两个特殊的变量，只有在函数被调用时才能获取到它们，而且搜索这两个变量时之后会在活动对象范围里面去搜</li>
<li>要确定函数中this的指向，必须先找到该函数被调用的位置。</li>
</ul>
</blockquote>
<ul>
<li><h5 id="第一种：作为对象的方法调用时，-this-指向该对象-javascript-void-0"><a href="#第一种：作为对象的方法调用时，-this-指向该对象-javascript-void-0" class="headerlink" title="第一种：作为对象的方法调用时， this 指向该对象(javascript:void(0);)"></a>第一种：作为对象的方法调用时， this 指向该对象(javascript:void(0);)</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>===obj)  <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a: <span class="number">2</span>,</span><br><span class="line">        test</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> obj0 = &#123;</span><br><span class="line">        a: <span class="number">3</span>,</span><br><span class="line">        obj</span><br><span class="line">    &#125;</span><br><span class="line">obj0.obj.test() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>即使是这种串串烧的形式，结果也是一样的， <code>test()</code>中的this只对直属上司（直接调用者obj）负责。再来看一个综合点的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy()    <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<p>你可能觉得换了名字其实还是obj.test(),但是却不是这样的 ，this永远指向的是最后调用它的对象　　　</p>
</li>
<li><h5 id="第二种：作为普通函数调用，this-总是指向全局对象-window"><a href="#第二种：作为普通函数调用，this-总是指向全局对象-window" class="headerlink" title="第二种：作为普通函数调用，this 总是指向全局对象 window"></a>第二种：作为普通函数调用，this 总是指向全局对象 window</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// window</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">"globalName"</span> </span><br><span class="line"><span class="keyword">var</span> getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName());   <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象"><a href="#第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象" class="headerlink" title="第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象"></a>第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象</h5><blockquote>
<p>函数被作为构造器调用时有以下特点：</p>
<p>一个新的对象被创建出来；这个新的对象被传递给这个构造器作为this参数，也就是说这个新的对象是构造器函数的上下文；如果没有显性的return语句，这个新的对象会被隐式的return（就是悄咪咪的被return了），并成为这个构造器的值</p>
</blockquote>
<ul>
<li><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a =a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> test(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.a)</span><br></pre></td></tr></table></figure>
<p>其中的new运算，先产生一个空对象，然后生成一个this指针，这个指针指向这个对象 ；运行构造函数时，这个对象传递导函数中作为this存在 ，就相当于“{}.a=a”  为这个对象添加了属性 ，然后再付给b</p>
</li>
<li><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"class"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">"other"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// other</span></span><br></pre></td></tr></table></figure>
<p>上边咱们说如果没有显性的return语句，这个新的对象会被隐式的return，但是如果 构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我么之前期待的 this</p>
</li>
</ul>
</li>
<li><h5 id="第四种：Function-prototype-call-或-Function-prototype-apply和Function-prototype-bind调用-可以动态地改变出入函数的-this"><a href="#第四种：Function-prototype-call-或-Function-prototype-apply和Function-prototype-bind调用-可以动态地改变出入函数的-this" class="headerlink" title="第四种：Function.prototype.call 或 Function.prototype.apply和Function.prototype.bind调用, 可以动态地改变出入函数的 this"></a>第四种：Function.prototype.call 或 Function.prototype.apply和Function.prototype.bind调用, 可以动态地改变出入函数的 this</h5><blockquote>
<p>看到上边几种形式的，你可能回想我很讨厌这些乱七八遭的东西 这个调用那个调用的，我想自己指定，我的人生我做主 ，我的代码我做主 。当然可以没问题！！！</p>
</blockquote>
<ul>
<li><p>call和apply的作用一样，区别仅在于传入的参数形式不同而已。</p>
<blockquote>
<ul>
<li>apply接收两个参数，第一个参数指定了函数体内this对象的指向，第二个参数是一个带下标的集合，这个集合可以是数组，也可以是类数组，apply方法把这个集合中的元素作为参数传入被调用的函数。</li>
<li>call传入的参数不固定，跟apply相同的是，第一个参数也代表函数体内的this指向，从第二个参数开始往后，每个参数依次传入函数</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test =<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window</span></span><br><span class="line">test.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// [1,2,3]</span></span><br><span class="line">test.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>call和apply改变this指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"obj1"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"obj2"</span>&#125;;</span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">"window"</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">getName();   <span class="comment">// window</span></span><br><span class="line">getName.call(obj1); <span class="comment">//obj1</span></span><br><span class="line">getName.call(obj2)  <span class="comment">// obj2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>apply 和call的常用方法</p>
<ul>
<li><p>验证是否是数组（前提是toString()没有被重写）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让类数组具有数组的方法 ，比如arguments对象，获取到的文档节点等，并没有数组的那些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].slice.apply(<span class="built_in">arguments</span>); </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply（argument）;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。</p>
</li>
<li><p><code>foo.bind({a:1})</code>却并不如此，执行该条语句仅仅得到了一个新的函数，新函数的this被绑定到了后面的第一个参数，亦即新的函数并没有执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=foo.call(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);     </span><br><span class="line"><span class="keyword">var</span> f2=foo.apply(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;);    </span><br><span class="line"><span class="keyword">var</span> f3=foo.bind(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1);        <span class="comment">//&#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f2);        <span class="comment">//&#123;a:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f3);        <span class="comment">//function foo()&#123;</span></span><br><span class="line">                        <span class="comment">//  return this;</span></span><br><span class="line">                        <span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo());     <span class="comment">//window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(f3());      <span class="comment">//&#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>bind与apply和call最大的区别就是bind不会立即调用，其他 两个会立即调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tempFn = fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">tempFn();</span><br></pre></td></tr></table></figure>
<p>第一行代码只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数给执行，执行bind会有一个返回值，这个返回值tempFn就是把fn的this改变后的那个结果。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="One-more"><a href="#One-more" class="headerlink" title="One more"></a>One more</h4><blockquote>
<p>还有一种大家别忘了Es6箭头函数，猜猜下边的 结果是几</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a: <span class="number">2</span>,</span><br><span class="line">        test</span><br><span class="line">    &#125;</span><br><span class="line">obj.test() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>来，往上翻一下我们的第一个锦囊，“函数<strong>被调用时（即运行时）</strong>才会确定该函数内this的指向。”现在函数这两个字要加个词修饰一下，变成普通函数（非箭头函数）才能区别于箭头函数。箭头函数中的this在<strong>函数定义的时候</strong>就已经确定，它this指向的是它的外层作用域this的指向。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题之排序</title>
    <url>/2018/09/10/sort/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/20/Uf2oDA.jpg" alt="Autumn Is Coming"></p>
<blockquote>
<p>有时候当你没有坚定下决心做某件事情的时候，任何理由都可能成为阻挡你的原因，我觉得那是因为生活逼得你还是不太紧，当你坚定的要去发生改变时，你会发现的开始成果就会是很大的。不得不说改变对一个人有多重要。</p>
</blockquote>
<p>排序有几种方法，这里主要说快速排序和冒泡排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>冒泡排序就是将最大数的冒泡到最后 </li>
<li>实现思路：将从头开始将相邻的两项相比，每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置，持续直到数据结束。最大的数将会在最后。再重复前边的操作。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">90</span>,<span class="number">0</span>,<span class="number">-10</span>,<span class="number">88</span>,<span class="number">999</span>,<span class="number">100</span>,<span class="number">102</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">var</span> temp =arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"第"</span>+(++count)+<span class="string">"次排序后："</span>+ arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortArr(arr));</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfgYWD.jpg" alt="images 1"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>先找到一个基准点(一般都是数组中部)，然后数组被该基准点分为两部分，依次依次与该基准点比较，如果比基准点小则放在左边，反之放在右边，分别用两个空数组去存储比较后的数据，最后然后在重复这个步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">90</span>,<span class="number">0</span>,<span class="number">-10</span>,<span class="number">88</span>,<span class="number">999</span>,<span class="number">100</span>,<span class="number">102</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>];</span><br><span class="line"><span class="keyword">var</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> centerIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>); <span class="comment">//取到数组中间的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> centerVal = arr.splice(centerIndex, <span class="number">1</span>);<span class="comment">//获取基准点的值splice(index,1)函数可以返回数组中被删除的那个数arr[index+1]  </span></span><br><span class="line">    <span class="keyword">let</span> left = [];  <span class="comment">//用来存放左边的数</span></span><br><span class="line">    <span class="keyword">let</span> right = []; <span class="comment">//用来存放右边的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;centerVal)&#123;  </span><br><span class="line">            left.push(arr[i]);<span class="comment">//比基准点小的放在左边数组  </span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是left："</span>+left);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            right.push(arr[i]);<span class="comment">//比基准点大的放在右边数组  </span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"这是right："</span>+right);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第"</span>+(++times)+<span class="string">"次排序后："</span>+arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归执行以上操作,对左右两个数组进行以上操作，直到数组长度为&lt;=1；  </span></span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(centerVal,quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfgJJO.jpg" alt="images 2"></p>
<ul>
<li>直接利用数组的排序方法sort来实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">90</span>,<span class="number">0</span>,<span class="number">-10</span>,<span class="number">88</span>,<span class="number">999</span>,<span class="number">100</span>,<span class="number">102</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.sort(compare);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/07/20/UfgGFK.jpg" alt="images 3"></p>
]]></content>
      <categories>
        <category>求职</category>
      </categories>
      <tags>
        <tag>求职、面试</tag>
      </tags>
  </entry>
  <entry>
    <title>截流和防抖</title>
    <url>/2020/07/15/throttle/</url>
    <content><![CDATA[<blockquote>
<p>最近身体疲惫，每天感觉脑子跟不上，并且很容易犯困，还好有人一直给充电，本来不太精神但是瞬间就充满能量。经过一番思想斗争之后，终于决定昨天鸽了一下，哇，真的好爽，今天早上来了还被嘲讽提前过上了公园大爷的生活，哈哈哈，不过休班一时爽，一直休班一直爽啊 ，不不不，说错了，一直休班木有qian啊，最近怎么话这么多，步入正题吧，今天来研究一下截流和防抖原理。（接着奏乐，接着舞）</p>
</blockquote>
<ol>
<li><h3 id="什么情况出现的截流和防抖"><a href="#什么情况出现的截流和防抖" class="headerlink" title="什么情况出现的截流和防抖"></a>什么情况出现的截流和防抖</h3><ul>
<li>当我们在鼠标移动和页面滚动的时候频繁的触犯一个函数</li>
<li>当属一个输入框中，输入进行查询的时候</li>
<li>屏幕尺寸发生改变的时候（一直在缩小放大浏览器）</li>
</ul>
<p>以上情况都会高频的触发函数，这个时候浏览器就容易卡死，难道这样就放任不管么？兄弟你不是在开玩笑吧？怎么可能不管呢。这属于前端的性能优化之一啊。</p>
</li>
<li><h3 id="防抖原理和实现"><a href="#防抖原理和实现" class="headerlink" title="防抖原理和实现"></a>防抖原理和实现</h3><ul>
<li><p>原理：什么是防抖呢？顾名思义那就是防止抖动啊，在你一直抖啊抖的过程，不在你抖动的时候进行操作，而是再你稳定之后进行函数的执行，也就是说，当你频繁的进行一个动作（下拉滚动条），不会一直执行所触发的函数而是在停下来之后多长时间进行触发。再来举个栗子，哎！每天举栗子也很沉的好嘛，咱们那种大厦的感应的门了解吧？比如现在有10个人一直进门（好比你一直在滚动页面），这个感应门不可能进一个人关一次门吧？这样门早就被砸了好么（浏览器奔溃了），感应门肯定是等10个人进去了，等几（比如10秒）秒，这10秒内没有人进了，就执行关门这个操作（触发的函数），10内有人进，就重新再记10秒重新计算。这就是防抖</p>
</li>
<li><p>实现思路 ：主要有两点 1.事件发生后，清除旧的计时器  2.设置行的计时器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>);</span></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">handler,time</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> timer = <span class="literal">null</span> ;         </span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                clearTimeout(timer);    <span class="comment">// 触发就清0 触发就清0 ； 直到不触发之后，几秒钟 </span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">                timer  = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 把box对象的这个this传给它</span></span></span><br><span class="line">                    handler.apply(_this,args);</span><br><span class="line">                &#125;,time);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 要执行的动作 </span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"这里做点什么"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.innerHTML = e.clientX;  </span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> testDebounce  = debounce(handle,<span class="number">2000</span>); </span></span><br><span class="line">  box.onmousemove = testDebounce;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我觉得你肯定你开始的时候一定和我一样，为什么debounce函数要return 一个函数，那我们来写一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">box.onmousemove = reTime();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reTime</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer  = setTimeout(handle,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// todo somethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reTime函数需要操作来自父级作用域的变量timer，而debounce函数就是为了创建这样一个作用域，使得每次执行reTimer函数时timer变量都是存在的。但是后边这种相对于前边就不那么优雅了，第一个timer只在函数内部进行使用，不必在全局变量中，显然闭包更符合方案。</p>
</li>
</ul>
</li>
<li><h3 id="截流原理和实现"><a href="#截流原理和实现" class="headerlink" title="截流原理和实现"></a>截流原理和实现</h3><ul>
<li><p>原理：知道了防抖，截流就是更简单了，在一个瀑布中，定时抽断一下，俗话讲抽刀断水水更流，不形容我们做程序哈。再来举一个吧，光举着也没人吃。比如我们正在做一个输入框，要求每输入一个字符都调用一个API来查询数据，从而实现联想、自动补全等功能，然而我们的输入速度是很快的，可能还没等第一个字符的查询结果出来，第二个字符就已经敲进去了，所以我们需要让查询频率小一点，具体做法就是在输入的过程中，每隔N秒才查询一次。</p>
</li>
<li><p>实现思路 ：确保一个计时器停止时再重新计时</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">".box"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> timer = <span class="literal">null</span> ; </span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">throttler</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (timer===<span class="literal">null</span>) &#123;  <span class="comment">// 只要时间不是null 就触发 。也就是说这个事件触发之后就从头算时间，到时间了也就再次触发</span></span></span><br><span class="line"><span class="javascript">                    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                        fn();</span><br><span class="line"><span class="javascript">                        timer = <span class="literal">null</span>;</span></span><br><span class="line">                    &#125;,delay)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'--todoSomethings---'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">        box.onmousemove = throttle(handle,2000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖</tag>
        <tag>截流</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2.5+ 之基础入门</title>
    <url>/2019/01/01/vue01/</url>
    <content><![CDATA[<blockquote>
<p>简单的记录一下最近重学vue的过程</p>
</blockquote>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ol>
<li><p>安装vue-cli3   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install - g @vue/cli </span><br><span class="line">npm install - g @vue/cli-service-global</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create vue-buy   vue-buy是项目名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><ol>
<li><p>vue单文件组件 .vue文件 </p>
<ul>
<li><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>   <span class="comment">&lt;!--模板里边只能有一个root 也就是一个根--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">export default &#123;</span><br><span class="line">	name:"app"  //这个是组件的名字</span><br><span class="line">	data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ol>
<li><p>开始使用</p>
<ul>
<li><p>引入组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Cart from &apos;./components/Cart&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册组件 ，使用components进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cart&gt; &lt;/Cart&gt;  使用Cart来引用组件</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组件数据传递</p>
<ul>
<li><p>父子关系的组件的数据传递</p>
<ul>
<li><p>父组件:     使用:name这种形式进行数据的传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot;&gt;&lt;/Cart&gt; &lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件：使用props进行接收 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">        props:&#123;</span><br><span class="line">            name:&#123;   </span><br><span class="line">                type:String,  //类型是string类型</span><br><span class="line">                required:true //数据必须传递</span><br><span class="line">            &#125;,</span><br><span class="line">            cart:&#123;</span><br><span class="line">                type: Array  //数组类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>任意两个组件，使用总线机制进行传递</p>
<blockquote>
<p>vue每个实例都有订阅/发布模式的实现，使用$on和￥emit来传递数据</p>
</blockquote>
<ul>
<li><p>父组件进行广播数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	 &lt;li class=&quot;cart-list&quot; v-for=&quot;(item, index) in goods&quot; :key=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;addCart(index)&quot; &gt;添加购物车&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    	methods: &#123;</span><br><span class="line">            addCart(i)&#123;</span><br><span class="line">                const good = this.goods[i];</span><br><span class="line">                // 触发一个事件  发送</span><br><span class="line">                this.$bus.$emit(&apos;addCart&apos;, good) </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件监听时间进行接收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    	 data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.$bus.$on(&apos;addCart&apos;, good=&gt;&#123; //接收到数据</span><br><span class="line">                const ret = this.cart.find(v=&gt;v.text===good.text);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="样式和class"><a href="#样式和class" class="headerlink" title="样式和class"></a>样式和class</h3><ol>
<li><p>样式 ：内联样式 v-bind:style ,可以简写为:style</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :style=&quot;&#123;color:c.active?&apos;red&apos;:&apos;black&apos;&#125;&quot;&gt;</span><br><span class="line">	&#123;&#123;i&#125;&#125;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :class=&quot;&#123;yellow_active:c.active&#125;&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    tr.yellow_active&#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol>
<li><p>使用computed字段，可以进行富足逻辑的计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;td colspan=&quot;2&quot;&gt;&#123;&#123;activeCount&#125;&#125;/&#123;&#123;count&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;total&#125;&#125;&lt;/td&gt;  &lt;!-- 直接用 不用写total（）--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;    //虽然 也可以使用methods的方法实现 ，但是毕竟computed有它的价值，且再使用时不用写方法之后的括号（）</span><br><span class="line">    	data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">       computed: &#123;</span><br><span class="line">            total() &#123;</span><br><span class="line">                return this.cart.reduce((sum,v)=&gt;&#123;</span><br><span class="line">                    if (v.active)&#123;</span><br><span class="line">                        return sum+v.price*v.count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return sum</span><br><span class="line">                &#125;,0)</span><br><span class="line">                // let num= 0;</span><br><span class="line">                // this.cart.forEach(v=&gt;&#123;</span><br><span class="line">                //     if (v.active)&#123;</span><br><span class="line">                //         num += v.price * v.count</span><br><span class="line">                //     &#125;</span><br><span class="line">                // &#125;);</span><br><span class="line">                // return num</span><br><span class="line">            &#125;,</span><br><span class="line">            count() &#123;  //购物车的所有商品条数</span><br><span class="line">                return this.cart.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            activeCount()&#123;  //选中的商品条数</span><br><span class="line">                return this.cart.filter(v=&gt;v.active).length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>脚手架安装</tag>
        <tag>组件间的数据传递</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue简单数据传递、模拟数据、数据持久化</title>
    <url>/2019/01/02/vue-begin/</url>
    <content><![CDATA[<blockquote>
<p>最近的大事应该就是尤雨溪要推出vue3.0了，2.0还没学完3.0又出来了。真的技术更新速度太快了，感觉跟不上了，不过话又说回来了不学怎么能体现出自己的价值，学吧！，先分享一下vue2.5+的基础。</p>
</blockquote>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ol>
<li><p>开始使用</p>
<ul>
<li><p>引入组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Cart from &apos;./components/Cart&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册组件 ，使用components进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cart&gt; &lt;/Cart&gt;  使用Cart来引用组件</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>组件数据传递</p>
<ul>
<li><p>父子关系之父传子</p>
<ul>
<li><p>父组件:     使用:name这种形式进行数据的传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot;&gt;&lt;/Cart&gt; &lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件：使用props进行接收 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">        props:&#123;</span><br><span class="line">            name:&#123;   </span><br><span class="line">                type:String,  //类型是string类型</span><br><span class="line">                required:true //数据必须传递</span><br><span class="line">            &#125;,</span><br><span class="line">            cart:&#123;</span><br><span class="line">                type: Array  //数组类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>父子关系之子传父</p>
<ul>
<li><p>子组件：我们可以调用内建的 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener"><strong>$emit</strong> 方法</a>并传入事件的名字，来向父级组件触发一个事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;!--进行传出一个值--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;, 0.1)&quot;&gt; </span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件: 监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;!--或者如果这个事件处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法--&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-on:enlarge-text=&quot;onEnlargeText&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">            this.postFontSize += enlargeAmount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>不相关的两个组件的数据传递</p>
<blockquote>
<p>vue每个实例都有订阅/发布模式的实现，使用$on和￥emit来传递数据</p>
</blockquote>
<ul>
<li><p>父组件进行广播数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	 &lt;li class=&quot;cart-list&quot; v-for=&quot;(item, index) in goods&quot; :key=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;addCart(index)&quot; &gt;添加购物车&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    	methods: &#123;</span><br><span class="line">            addCart(i)&#123;</span><br><span class="line">                const good = this.goods[i];</span><br><span class="line">                // 触发一个事件  发送</span><br><span class="line">                this.$bus.$emit(&apos;addCart&apos;, good) </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子组件监听时间进行接收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    	 data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.$bus.$on(&apos;addCart&apos;, good=&gt;&#123; //接收到数据</span><br><span class="line">                const ret = this.cart.find(v=&gt;v.text===good.text);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="样式和class"><a href="#样式和class" class="headerlink" title="样式和class"></a>样式和class</h3><ol>
<li><p>样式 ：内联样式 v-bind:style ,可以简写为:style</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :style=&quot;&#123;color:c.active?&apos;red&apos;:&apos;black&apos;&#125;&quot;&gt;</span><br><span class="line">	&#123;&#123;i&#125;&#125;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :class=&quot;&#123;yellow_active:c.active&#125;&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    tr.yellow_active&#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol>
<li><p>使用computed字段，可以进行富足逻辑的计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;td colspan=&quot;2&quot;&gt;&#123;&#123;activeCount&#125;&#125;/&#123;&#123;count&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;total&#125;&#125;&lt;/td&gt;  &lt;!-- 直接用 不用写total（）--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;    //虽然 也可以使用methods的方法实现 ，但是毕竟computed有它的价值，且再使用时不用写方法之后的括号（）</span><br><span class="line">    	data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">       computed: &#123;</span><br><span class="line">            total() &#123;</span><br><span class="line">                return this.cart.reduce((sum,v)=&gt;&#123;</span><br><span class="line">                    if (v.active)&#123;</span><br><span class="line">                        return sum+v.price*v.count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return sum</span><br><span class="line">                &#125;,0)</span><br><span class="line">                // let num= 0;</span><br><span class="line">                // this.cart.forEach(v=&gt;&#123;</span><br><span class="line">                //     if (v.active)&#123;</span><br><span class="line">                //         num += v.price * v.count</span><br><span class="line">                //     &#125;</span><br><span class="line">                // &#125;);</span><br><span class="line">                // return num</span><br><span class="line">            &#125;,</span><br><span class="line">            count() &#123;  //购物车的所有商品条数</span><br><span class="line">                return this.cart.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            activeCount()&#123;  //选中的商品条数</span><br><span class="line">                return this.cart.filter(v=&gt;v.active).length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h3><blockquote>
<p>mock数据也就是模拟数据，进行前后端分离</p>
<p>简单的mock，使用自带的webpack-dev-serve即可实现，新建vue.config.js扩展webpack设置</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">      devServer:&#123;</span><br><span class="line">          before(app) &#123;</span><br><span class="line">              app.get(<span class="string">'/api/goods'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">                  res.json(&#123;</span><br><span class="line">                      list:[</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"百万年薪架构师"</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"web全栈架构师"</span>,<span class="attr">price</span>:<span class="number">80</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"Python爬虫"</span>,<span class="attr">price</span>:<span class="number">70</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"Java架构师"</span>,<span class="attr">price</span>:<span class="number">90</span>&#125;</span><br><span class="line">                      ]</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用axios进行请求</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;  <span class="comment">//需要下载axios模块</span></span><br><span class="line">created() &#123;</span><br><span class="line">    axios.get(<span class="string">'/api/goods'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goods = res.data.list;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><blockquote>
<p>对于我们来说购物车的数据不能每次刷新都消失，所以我们需要对数据进行数据的缓存，也就是数据的持久化</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义方法 setLocal方法</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    setLocal()&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">'cart'</span>,<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.cart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听数据变化</span></span><br><span class="line">watch:&#123;</span><br><span class="line">    cart:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setLocal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//创建完成后获取本地存储的数据</span></span><br><span class="line">created()&#123;</span><br><span class="line">    <span class="keyword">this</span>.cart = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'cart'</span>))||[];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 循环监听</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    cart:&#123;</span><br><span class="line">        handler() &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLocal();</span><br><span class="line">        &#125;,</span><br><span class="line">            deep:<span class="literal">true</span>, <span class="comment">//深度监听</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>父子组件数据传递</tag>
        <tag>Vue模拟数据</tag>
        <tag>简单数据的持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件化设计思想</title>
    <url>/2019/01/08/vue02/</url>
    <content><![CDATA[<blockquote>
<p>现在很多UI库都有很多的好用的组件库，那这写组件的设计原理也必须知道，今天实现一下自定义form表单组件</p>
</blockquote>
<p>组件设计思想 :3个点</p>
<ol>
<li>属性 ：设计任何组件都需要传递一个属性</li>
<li>事件：组件内部对外通知的机制</li>
<li>组件可以扩展：组件内部不能写死，比如弹窗，不能只放按钮和文本，应该是用户想放什么放什么  ，slot插槽，需要分层  。</li>
</ol>
<h3 id="组件化设计思想实现"><a href="#组件化设计思想实现" class="headerlink" title="组件化设计思想实现"></a>组件化设计思想实现</h3><ol>
<li><h5 id="采坑-："><a href="#采坑-：" class="headerlink" title="采坑  ："></a>采坑  ：</h5><ul>
<li><p>v-model 双向绑定表单元素的数据：实质是绑定了value、checked、selected属性</p>
</li>
<li><p>父组件向子组件传递数据 ， 可以使用 :name 进行传递 ，也可以直接绑定属性  target=”yuhior”,那么这样传递的就是yuhior的值   不是变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot; target=&quot;yuhior&quot; &gt;&lt;/Cart&gt; </span><br><span class="line">&lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父组件是使用这个子组件的组件 ，而不是template里嵌套子元素的是父组件，比如说这里KInput、FormItem、KForm的父组件都是App.vue   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--App.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;k-form :model=&quot;ruleForm&quot; :rules=&quot; rules&quot;&gt;</span><br><span class="line">      &lt;form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;   //父组件这是   *****理解错误 </span><br><span class="line">        &lt;k-input v-model=&quot;ruleForm.name&quot; name=&quot;name&quot;&gt;&lt;/k-input&gt;  //开始我以为子组件</span><br><span class="line">      &lt;/form-item&gt;</span><br><span class="line">      &lt;form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;</span><br><span class="line">        &lt;k-input v-model=&quot;ruleForm.age&quot; name=&quot;age&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">      &lt;/form-item&gt;</span><br><span class="line">    &lt;/k-form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import KForm from &apos;./components/Form&apos;;</span><br><span class="line">  import FormItem from &apos;./components/FormItem&apos;;</span><br><span class="line">  import KInput from &apos;./components/KInput&apos;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;app&apos;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      KForm,</span><br><span class="line">      FormItem,</span><br><span class="line">      KInput</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>v-model 是一个特殊的属性绑定，相当于绑定了:value和@input两件事情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</span><br><span class="line">&lt;custom-input </span><br><span class="line">        :value=&quot;searchText&quot;</span><br><span class="line">        @input=&quot;searchTex=$event&quot;</span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="form表单验证的设计实现"><a href="#form表单验证的设计实现" class="headerlink" title="form表单验证的设计实现"></a>form表单验证的设计实现</h5><blockquote>
<p>表单组件进行分层：</p>
<p>​    KForm组件：负责接收自定义的规则</p>
<p>​    KFormItem：负责显示错误信息也就是规则的验证</p>
<p>​    KFromInput：负责数据的双向绑定</p>
</blockquote>
<ul>
<li><p>子组件向父组件传递数据，通知父组件组件内部变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;</span><br><span class="line">        开课吧</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                this.$emit(&apos;toMessage&apos;,event);</span><br><span class="line">            &#125;,   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 父组件接收</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> 	&lt;k-input v-on:toMessage=&quot;toFuzhi&quot;&gt;&lt;/k-input&gt;  //toMessage 是子组件那个出发事件</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">             toFuzhi(msg)&#123;</span><br><span class="line">				 this.msg = msg  //进行父组件的复制</span><br><span class="line">            &#125;,  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先看看平常使用:  和lelement类似 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;k-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">        &lt;k-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">            &lt;k-input v-model=&quot;ruleForm.name&quot; name=&quot;name&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">        &lt;/k-form-item&gt;</span><br><span class="line">        &lt;k-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;</span><br><span class="line">            &lt;k-input v-model=&quot;ruleForm.age&quot; name=&quot;age&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">        &lt;/k-form-item&gt;</span><br><span class="line">    &lt;/k-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import KForm from &apos;./components/KForm&apos;;</span><br><span class="line">    import KFormItem from &apos;./components/KFromItem&apos;;</span><br><span class="line">    import KInput from &apos;./components/KInput&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &apos;app&apos;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            KForm,</span><br><span class="line">            KFormItem,</span><br><span class="line">            KInput</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ruleForm:&#123;</span><br><span class="line">                    name:&apos;&apos;,</span><br><span class="line">                    age:&apos;&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                rules: &#123;</span><br><span class="line">                    name:&#123;required: true, message: &apos;用户名不能为空！&apos;&#125;,</span><br><span class="line">                    age: &#123;required: true, message: &apos;年龄不能为空！&apos;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KFormInput  实现： 需要注意 理解 this.$emit 传值的时候，因为 父组件 v-model 绑定了:value和@input两件事情  ，所以 使用的时候直接 v-model =“ruleForm.age”  就相当于  @input = ‘’ ’‘ 所以也就接收到了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!--实现v-model--&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            :value=&quot;inputText&quot;</span><br><span class="line">            @input=&quot;handleInput&quot;</span><br><span class="line">            @blur=&quot;handleBlur&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;KInput&quot;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            value:&#123;</span><br><span class="line">                type:String,</span><br><span class="line">                default:&apos;&apos;,</span><br><span class="line">                require: true</span><br><span class="line">            &#125;,</span><br><span class="line">            name:&#123;</span><br><span class="line">                type:String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                inputText:this.value  // * 双向输入的输入-&gt;父元素传递过来的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleInput(e) &#123;</span><br><span class="line">                let value = e.target.value;  // props 是单向数据流传递数据，所以修改值之后，props的值不变，父元素的值不改变</span><br><span class="line">                this.inputText = value;   // 当输入框输入值的时候，获取输入框的值</span><br><span class="line">                // * 双向数据的输出-&gt; 通知父元素进行回流绑定</span><br><span class="line">                this.$emit(&apos;input&apos;,value);  // 子组件向父组件传递数据 使用this.$emit(&apos;input&apos;) input事件触发  父组件使用@input接收</span><br><span class="line">                this.$bus.$emit(&apos;KFormItem&apos;, value); //将值通过总线机制，实现KInput和KFormItem不相关的组件的数据传递，传递给KFromItem值，它进行验证</span><br><span class="line">            &#125;,</span><br><span class="line">            handleBlur()&#123; //失去焦点是进行验证</span><br><span class="line">                let value = this.inputText;</span><br><span class="line">                this.$bus.$emit(&apos;KFormItem&apos;,value,);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KFormItem 实现  ：</p>
<ol>
<li><p>我们接收到KInput发送过来的数据 ， 然后进行 验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//----------KFromItem接收</span></span><br><span class="line">created() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$bus.$on(<span class="string">'KFormItem'</span>, (value) =&gt; &#123;  <span class="comment">//接收KInput组件传递过来的值 进行调用validate方法进行验证</span></span><br><span class="line">          <span class="keyword">this</span>.validate(value);  </span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要验证 就需要 获取验证的规则 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------KForm发送数据实例  </span></span><br><span class="line">provide()&#123;  </span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">     	kform:<span class="keyword">this</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"><span class="comment">//-----------KFormItem接收</span></span><br><span class="line">inject:[<span class="string">'kform'</span>],  <span class="comment">//  2.接收KForm车通过  provide传递过来的 组件实例 这样才能获取到规则</span></span><br><span class="line"><span class="comment">//-----------获取规则</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    getRules()&#123; <span class="comment">//获取规则的方法</span></span><br><span class="line">        <span class="keyword">let</span> formRules = <span class="keyword">this</span>.kform.rules[<span class="keyword">this</span>.prop];  <span class="comment">//找到对应的 rules.prop的值</span></span><br><span class="line">        <span class="keyword">return</span> formRules;</span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取了规则 就需要写 校验方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">validate(obj)&#123;</span><br><span class="line">    <span class="comment">//1.验证我需要获取验证规则 ,也就是使用组件使用时传递进来的规则</span></span><br><span class="line">    <span class="keyword">const</span> rule = <span class="keyword">this</span>.getRules(); <span class="comment">//3.调用获取rules</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.kform.model[<span class="keyword">this</span>.prop]; <span class="comment">//4.由于在KInput组件中我们已经将输入框的变化值使用this.$bus.$emit通知给父组件了，所以这样获取输入框的值</span></span><br><span class="line">    <span class="keyword">if</span> (rule.required&amp;&amp;!value)&#123;  <span class="comment">//5.进行验证 ，require为true ，!value为真(value的值为空)就说明验证未通过</span></span><br><span class="line">        <span class="keyword">this</span>.validateStatus = <span class="string">'error'</span>;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = rule.message</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                       <span class="comment">//6.验证通过</span></span><br><span class="line">        <span class="keyword">this</span>.validateStatus = <span class="string">'stating'</span>  <span class="comment">//验证状态为通过状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>KForm实现就简单了：给一个槽口 让KFormItem来占用就行了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;!--子元素的插口--&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;KForm&quot;,</span><br><span class="line">        provide()&#123;   //给KFromItem传递规则 数据</span><br><span class="line">            return &#123;</span><br><span class="line">                kform:this</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // provide:&#123;</span><br><span class="line">        //     kform:this ;   也可以使用这种方式进行数据传递  ，但是我们现在需要返回this实例 所以需要使用provide:function()&#123;&#125;形式 但是如果返回变量就可以直接返回</span><br><span class="line">        // &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            model:&#123;</span><br><span class="line">                type:Object</span><br><span class="line">            &#125;,</span><br><span class="line">            rules:&#123;</span><br><span class="line">                type:Object</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>完成之后发现 不管输入哪一个输入框 都验证所有的验证框都响应，进行验证  </p>
<blockquote>
<p>这是由于 我们再KInput.vue中使用 的$emit 和$.on都是全局的，所以父组件接收也就是@input =“ ”的时候都接收到了变化，也就是多个KForm监听@input事件  ，所以多个验证都响应 ，</p>
<p>那么我们就判断一下</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --------在KFormInput的$bus.$emit 发送值的时候不仅仅发送一个value ，我们发送一个对象  </span></span><br><span class="line">	<span class="keyword">this</span>.$bus.$emit(<span class="string">'KFormItem'</span>,&#123;</span><br><span class="line">        value,</span><br><span class="line">        name:<span class="keyword">this</span>.name</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// --------在KFormItem验证中判断一下，如果发送过来的name和这个prop不相等，说明不是当前输入的input</span></span><br><span class="line">    <span class="keyword">if</span> (obj.name!==<span class="keyword">this</span>.prop) &#123;  </span><br><span class="line">        <span class="keyword">return</span>    <span class="comment">//别的prop的 如果不是这个name则直接返回</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>规则扩展</p>
<ul>
<li><p>但是如果我们想有多个验证规则怎么办 ？如下 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">     name: [  <span class="comment">//如果有多个校验项 ,则验证需要修改</span></span><br><span class="line">         &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'用户名不能为空！'</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">minLength</span>: <span class="number">3</span>, <span class="attr">message</span>: <span class="string">"用户名长度要大于3"</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">maxLength</span>: <span class="number">10</span>, <span class="attr">message</span>: <span class="string">"用户名长度要小于10"</span>&#125;,</span><br><span class="line">     ],</span><br><span class="line">         age: &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'年龄不能为空！'</span>&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>那就在验证里边加判断被！！！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.如果验证规则有多个，那就需要判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">    value.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rule.required &amp;&amp; !value)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rule.mixLength &amp;&amp; value.length&lt;rule.mixLength)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>[源码]: </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>自定义form表单验证组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router单页面</title>
    <url>/2019/01/18/vue03/</url>
    <content><![CDATA[<blockquote>
<p>vue路由绝对是vue中的一大块，基本上路由都有两大模式history模式和hash模式，而我们常用的则是history模式</p>
</blockquote>
<ol>
<li><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h5 id="默认的路由使用的hash模式-http-localhost-8080-page1"><a href="#默认的路由使用的hash模式-http-localhost-8080-page1" class="headerlink" title="默认的路由使用的hash模式 (http://localhost:8080/#/page1)"></a>默认的路由使用的hash模式 (<a href="http://localhost:8080/#/page1" target="_blank" rel="noopener">http://localhost:8080/#/page1</a>)</h5><ul>
<li><p>起步 ：安装vue-router模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建router.js进行路由配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Page1 <span class="keyword">from</span> <span class="string">'./components/Page1'</span>;</span><br><span class="line"><span class="keyword">import</span> Page2 <span class="keyword">from</span>  <span class="string">'./components/Page2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js中进行使用插件，赋予vue控制路由的能力</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line">Vue.use(VueRouter); <span class="comment">//将this.$router 挂载到原型链上，使得vue具有处理路由的能力</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在App.vue中使用 ，使用router-view 标签进行占位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--路由占位符--&gt;</span><br><span class="line">&lt;router-view&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按钮导航，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/page1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"page1"</span>&gt;页面<span class="number">1</span>&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link to="/</span>page2<span class="string">" class="</span>page2<span class="string">"&gt;页面2&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="history模式："><a href="#history模式：" class="headerlink" title="history模式："></a>history模式：</h5><blockquote>
<p>默认是hash 模式的路由，url 使用#后面定位路由，对SEO不利，设置history模式可以使用普通的url</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接在routes.js中配置 mode：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h5><blockquote>
<p>在配置路由的使用：id占位符，和angualar类似  ，一些参数可以使用this.$route.XX进行获取</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">component</span>:Page3&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ---------进行获取</span></span><br><span class="line">computed:&#123;</span><br><span class="line">    name()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$route.params.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种获取路由参数比较麻烦，更优雅的方式获取，使用属性传递的方式进行获取</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">props</span>:<span class="literal">true</span>,<span class="attr">component</span>:Page3&#125;, <span class="comment">// 使用props 表示属性传递</span></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//-------在进行或去就比较优雅 ，直接使用props接收</span></span><br><span class="line">   props:[<span class="string">'id'</span>],</span><br></pre></td></tr></table></figure>
<h5 id="子路由嵌套"><a href="#子路由嵌套" class="headerlink" title="子路由嵌套"></a>子路由嵌套</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:Login&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/dashboard'</span>,</span><br><span class="line">            component:DashBoard,</span><br><span class="line">            children:[      <span class="comment">//---------子路由的嵌套</span></span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">props</span>:<span class="literal">true</span>,<span class="attr">component</span>:Page3&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//-------------第一层使用</span></span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h1&gt;<span class="number">2019</span>年，新的一天你好！！！&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;hr&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/路由占位符</span></span><br><span class="line"><span class="regexp">    &lt;router-view&gt;&lt;/</span>router-view&gt;   &lt;!--第一层，包含login和dashboard两个路由--&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/------------dashboard里边的嵌套</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="navbar"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;router-link to="/</span>page1<span class="string">" class="</span>page1<span class="string">"&gt;页面1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">            &lt;router-link to="</span>/page2<span class="string">" class="</span>page2<span class="string">"&gt;页面2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">            &lt;router-link to="</span>/page3/vuejs<span class="string">" class="</span>page2<span class="string">"&gt;Vue&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt; &lt;!--这是第二层，子路由嵌套在这里--&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="路由的重定向：使用redirect进行重定向"><a href="#路由的重定向：使用redirect进行重定向" class="headerlink" title="路由的重定向：使用redirect进行重定向"></a>路由的重定向：使用redirect进行重定向</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/login'</span>&#125;,</span><br></pre></td></tr></table></figure>
<h5 id="路由守卫-：（在路由跳转之前或者路由跳转之后hooks）钩子"><a href="#路由守卫-：（在路由跳转之前或者路由跳转之后hooks）钩子" class="headerlink" title="路由守卫 ：（在路由跳转之前或者路由跳转之后hooks）钩子"></a>路由守卫 ：（在路由跳转之前或者路由跳转之后hooks）<strong>钩子</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">let</span> routes = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;）</span><br><span class="line">routes.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeEach'</span>,to); <span class="comment">//  to 是和那个路由里的所有东西</span></span><br><span class="line">    <span class="keyword">if</span> (to.path!==<span class="string">'/login'</span>)&#123;   <span class="comment">//逻辑是如果不是login页面则随便跳转 ，但是如果是login页面则需要两秒之后跳转</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">routes.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'afterEach'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes</span><br></pre></td></tr></table></figure>
<h5 id="组件内部生命周期：上边的路由守卫是全局的-，我们组件内部也有一些内部生命周期"><a href="#组件内部生命周期：上边的路由守卫是全局的-，我们组件内部也有一些内部生命周期" class="headerlink" title="组件内部生命周期：上边的路由守卫是全局的  ，我们组件内部也有一些内部生命周期"></a>组件内部生命周期：上边的路由守卫是全局的  ，我们组件内部也有一些内部生命周期</h5><blockquote>
<p>需要一些组件内部的守卫 ，有两种方法  </p>
</blockquote>
<ul>
<li><p>在routes配置path的时候进行，<strong>不推荐</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>再组件内部 执行  <strong>推荐</strong></p>
<blockquote>
<p>注意顺序是  ，路由守卫beforeEach -&gt;beforeRouteEnter -&gt;beforeRouteLeave-&gt;afterEach的顺序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        beforeRouteEnter(to,from,next)&#123;</span><br><span class="line">          console.log(&apos;page3进来了&apos;);</span><br><span class="line">          next();</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">          console.log(&apos;page3准备退出了&apos;);</span><br><span class="line">          if (window.confirm(&apos;您真的要退出么？&apos;))&#123;</span><br><span class="line">              next();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当路由组件没有变但是路由的参数变了时，比如 由  page3/vuejs变为 page3/react </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate(to,form,next)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'page3路由，但是参数变化了'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="整个路由的操作逻辑-，我理解是执行顺序"><a href="#整个路由的操作逻辑-，我理解是执行顺序" class="headerlink" title="整个路由的操作逻辑 ，我理解是执行顺序"></a>整个路由的操作逻辑 ，我理解是执行顺序</h5><ol>
<li>导航被触发</li>
<li>调用全局的beforeEach守卫</li>
<li>在重用的组件里调用beforeRouteUpdate守卫</li>
<li>在路由配置里边调用beforeEnter    这个和组件里的beforeRouteEnter类似</li>
<li>在被激活的组件⾥调⽤ beforeRouteEnter。</li>
<li>调⽤全局的 beforeResolve 守卫 (2.5+)。  这个比全局的beforeEach守卫晚一点点</li>
<li>导航被确认。</li>
<li>组件的beforeRouteLeave</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
</ol>
<h5 id="异步组件-，懒加载"><a href="#异步组件-，懒加载" class="headerlink" title="异步组件 ，懒加载"></a>异步组件 ，懒加载</h5><blockquote>
<p>路由懒加载vue中配合webpack非常简单 ,在需要懒加载的组件的路由配置中直接import（）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如让login组件实现懒加载</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./components/Login'</span>)&#125;</span><br><span class="line"><span class="comment">//&#123;path:'/login',component:Login&#125;,</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue路由</tag>
      </tags>
  </entry>
  <entry>
    <title>webapck手动配置（一）</title>
    <url>/2019/04/02/webapck-learn1/</url>
    <content><![CDATA[<blockquote>
<p>前几天去面试了，但是学习还是不应该落下的，面试的过程中碰见了超级nice的云龙哥（偶像），其中聊到webpack，意识到还是很需要懂得webpack的配置信息的，于是学习一下webpack的手动配置，但是用的比较新的的node版本，不知道很多步骤是不是和webpack2.0的一致，所以肯定有很多不足 。</p>
</blockquote>
<ul>
<li><h4 id="入门级"><a href="#入门级" class="headerlink" title="入门级"></a>入门级</h4><ul>
<li><p>项目初始化，在你的项目目录里边初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建项目结构src，里边index.js 和模块a.js </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是a.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建index.html，用于引用 index.js </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是入口文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./src/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是现在我们打开index.html 文件发现浏览器并不能console出我们想要的，因为浏览器并不能支持我们的require语法，于是我们的男猪脚终于上线了，webpack主角光环，哈哈哈当然人家很强不用光环的哈，安装我们的webpack和webpack-cli模块吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webapck webapck-cli -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行打包bulid ，npx就是从本地的node_modules找命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
</li>
<li><p>多了dist 文件夹 ，里面生成了main.js文件  ,现在再引用就ok了吧 ，console也出来了 ，看来主角光环就是厉害，哈哈哈</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是入口文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种 跑npx 的方式  ，在package.json 的script 中添加命令,现在直接使用 npm run bulid</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webapck"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><ul>
<li><p>新建webapck.config.js，webpack 默认的配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    mode:<span class="string">'development'</span>,  <span class="comment">// 开发模式 不压缩代码</span></span><br><span class="line">    entry : <span class="string">'./src/index.js'</span>, <span class="comment">// 入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        filename: <span class="string">'pack.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./kkb'</span>) <span class="comment">//需要使用绝对路径，需要引用path  打包文件夹是kkb ，文件名是 pack.js</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h4><ul>
<li><p>目前我们每次更新完，需要重新跑build ，然后再打开html 比较繁琐 ，webpack 专门安装了一个套件，webpack-dev-server</p>
</li>
<li><p>安装 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webapck",</span><br><span class="line">    "dev": "webpack-dev-server"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置webapck.config.js，当然0配置也是可以的</p>
</li>
</ul>
</li>
<li><h4 id="build完之后加hash过程"><a href="#build完之后加hash过程" class="headerlink" title="build完之后加hash过程"></a>build完之后加hash过程</h4><ul>
<li><p>在webapck.config.js 的配置中进行hash配置 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">	filename: &apos;pack.[hash:6].js&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="自动加载html"><a href="#自动加载html" class="headerlink" title="自动加载html"></a>自动加载html</h4><ul>
<li><p>当然我们build之后出现， pack.6420d5.js文件  ，那么我们html中的引用就也需要更改了，那么我们不可能没次都手动修改吧，那好我们再来进行配置</p>
</li>
<li><p>新建public文件夹，新建index.html作为我们的模板</p>
</li>
<li><p>使用html-webpack-plugin，并配置webpack-config.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebapckPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"> plugins: [</span><br><span class="line">     <span class="keyword">new</span> htmlWebapckPlugin(&#123;</span><br><span class="line">         template: <span class="string">'./public/index.html'</span>,  <span class="comment">//模板文件</span></span><br><span class="line">         filename: <span class="string">'index.html'</span> <span class="comment">// 输出文件的名字</span></span><br><span class="line">     &#125;)</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>再执行 npm run dev  我们修改a.js 浏览器就随之修改了。跑的还是外边的index.html</p>
</li>
</ul>
</li>
<li><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ul>
<li>现在npm run build 就会生成一个带hash 的js和一个index.html 并且引用了这个带hash的js文件</li>
</ul>
</li>
<li><h4 id="支持css"><a href="#支持css" class="headerlink" title="支持css"></a>支持css</h4><ul>
<li><p>webpack 中所有的东西都是模块，默认require的就是js，但是css 什么的解析成js ，那是不可执行的，那就需要loader来支持配置module，但是<strong>注意</strong> use 的顺序是从右向左执行</p>
</li>
<li><p>安装css -loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置webpack-config，和plugin 平级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">//以css结尾</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] <span class="comment">// 先把css解析出来,并不能直接在js文件执行，我们需要将解析出来的放进style里边，那就需要安装style-loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装style-loader</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install style-loader -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽离css  ，当我们要进行单独抽离一个css 文件时，显然上边的插件并不足以满足要求，那肯定有解决的方案啊，不然说它干嘛， mini-css-extract-plugin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件里配置被，盘它就完了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebapckPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,  <span class="comment">//模板文件</span></span><br><span class="line">        filename: <span class="string">'index.html'</span> <span class="comment">// 输出文件的名字</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'kkb.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">//以css结尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.css$/</span>,</span><br><span class="line">            use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]  <span class="comment">// 现在我们就不需要把css 塞到style里css解析完就用MiniCssExtractPlugin.loader</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>npm run build 就能看见效果了</li>
</ul>
<ul>
<li><h4 id="支持css预编译stylus（less、sass类似）"><a href="#支持css预编译stylus（less、sass类似）" class="headerlink" title="支持css预编译stylus（less、sass类似）"></a>支持css预编译stylus（less、sass类似）</h4><ul>
<li><p>stylus-loader stylus安装就完了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install stylus-loader stylus -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>一样 来配置吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        ......</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.styl$/</span>,</span><br><span class="line">            use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>,<span class="string">'stylus-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
</li>
<li><h4 id="post-css-兼容性css"><a href="#post-css-兼容性css" class="headerlink" title="post-css 兼容性css"></a>post-css 兼容性css</h4><ul>
<li><p>安装postcss-loader 和autoprefixer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置config文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">//以css结尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.css$/</span>,</span><br><span class="line">            <span class="comment">//use: ['style-loader','css-loader']  </span></span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="string">'postcss-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.styl$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="string">'postcss-loader'</span>,</span><br><span class="line">                <span class="string">'stylus-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还需要vue.config.js同级目录下新建一个postcss.config.js 对postcss进行配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="ES6-使用大名鼎鼎的babel来把ES6转换成ES5"><a href="#ES6-使用大名鼎鼎的babel来把ES6转换成ES5" class="headerlink" title="ES6 :使用大名鼎鼎的babel来把ES6转换成ES5"></a>ES6 :使用大名鼎鼎的babel来把ES6转换成ES5</h4><ul>
<li><p>使用babel-loader和@babel/core @babel/preset-env</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env -D</span><br><span class="line">// babel-loader是处理js转换的loader </span><br><span class="line">//@babel/core babel核心</span><br><span class="line">//@babel/preset-env 是转换成那个级别的</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kkb</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'yuhior'</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈喽'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kkb  = <span class="keyword">new</span> Kkb()</span><br><span class="line">kkb.sayHi()  <span class="comment">//写的ES6</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul>
<li><p>js中使用图片，显然这样直接npm run dev 肯定识别不出来啊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./img/logo.png'</span></span><br><span class="line"><span class="keyword">let</span> image =<span class="keyword">new</span> Image()</span><br><span class="line">image.src = Logo</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(image)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用file-loader ，这样js、css 和background都支持图片了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure>
</li>
<li><p>不用说了你肯定知道了 ，配置嘛谁不会说啊哈哈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="底层：npm-run-build-做了什么事情"><a href="#底层：npm-run-build-做了什么事情" class="headerlink" title="底层：npm run build  做了什么事情"></a>底层：npm run build  做了什么事情</h4><ul>
<li>build  首先去找modules 的webpack模块里边有个bin 目录，下边有个webpack.js ,里边有个installedClis函数，这里回去寻找我们装了什么，如果安装了webpack-cli 就会执行webpakc-cli下面的bin目录文件，如果安装了webapck-command就会执行这个  </li>
<li>webapck-cli下面有个cli.js 实际执行的是这个 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>手动配置，入门</tag>
      </tags>
  </entry>
  <entry>
    <title>在一起观后感</title>
    <url>/2020/11/03/yougan/</url>
    <content><![CDATA[<blockquote>
<p>有一段时间没有更新博客了，今天真的趁着昨天去写观后感，然后把字码一下，这次不记录技术记录一次观后感，因为上次做的demo一直在完善中，所以之后再进行相关的更新，一直想做一个成型的站点，算是自己摸索mongodb的第一次尝试吧，前后台自己做，前后台分离，毕竟学到就要用到，就是这么的有执行力，因为成果就是这么在一次一次的尝试中开花结果的，我相信坚持就有收获。</p>
</blockquote>
<h2 id="上天无亲，常与善人"><a href="#上天无亲，常与善人" class="headerlink" title="上天无亲，常与善人"></a>上天无亲，常与善人</h2><p>没想到自己会在曾经当作任务完成的事情，现在居然用下班时间来完成。可能这是被这部剧深深的感染了吧。初见这部剧还是在微博中刷到，看到了一个片段就被深深的吸引。于是用下班坐车时间和上个周日刷完了这部剧。初见它，就被它表达的责任感和痛苦感所俘虏。十个短小的单元剧，却演绎着十个不同的故事，但却表达了一个情感，国家兴亡，匹夫有责。</p>
<p>​    生命的拐点——人类不能让时间暂停，但人类可以创造拐点。</p>
<p>​    映入眼帘的是张嘉译路上骑车的镜头，本来在春节定好飞机票陪家人的他，被一个电话急召回医院，只后凭借自己多年的从医经验，在年轻院长还在抱有轻视的状态下，准确的判断出事态的严重性，和时间赛跑，这里我并不是在吹捧个人的英雄主义，只是他给我留下的印象最深，身患渐冻症的他，上楼梯的那一幕触碰到我内心的泪点。然后作为武汉最早接收新冠病毒感染着的定点医院，出现了一幕幕感人的镜头，有救治病人被感染的谭松林和刘芸，有一个个争分夺秒不顾辛劳的只睡几小时的医生护士，千万大众中最普通的人，同时也是最伟大的人。这所医院所有的医生护士在疫情汹涌而来的时刻，却站在了最前面。他们是最美的逆行者，可以说在疫情来到时，这里记录的并不是一座医院，一群人，而是一种精神，一座里程碑。</p>
<p>​    摆渡人——是烂掉的口罩还是穿在身上的垃圾袋呢？</p>
<p>​    从来没什么盖世英雄，有的只是不平凡的“摆渡人”，默默的付出，这一章节中表现出了太多的情感，雷佳音饰演的外卖小哥，就是所有“摆渡人”的缩影，从开始在医院给别人口罩，到接送医生护士回酒店，再到给小女孩送药送饭安慰小女孩，最后到为妻子的安全不接触妻子。无不体现着一个平凡人的不平凡。一句只要“只要您点就一直送”，就是喂到了所有人心里的一颗定心丸。印象最深的还是第一次接护士回家的那个桥段，说实话当在看到中途因为内心的恐惧而中间想撤出战斗的护士时，我内心也产生了一样的情感，有些鄙视这个护士，但是随后的一系列对话“我们保护病人，那谁来保护我们呢？是烂掉的口罩还是穿在身上的垃圾袋呢？我就是想活着，我有错么？”直击我心，是啊！我有什么资格去评判人家呢？反应真实又透露着残酷，这时不也不得不佩服广电这么大尺度的表现现实的残酷。害怕并不是贬义词，生而为人肯定会产生恐惧，果然后来继续战斗的她，更加彰显出心怀恐惧却必须迎难而上的的珍贵。寒风虽刺骨，但终于春暖花开的一天。</p>
<p>​    同行——同行又同行</p>
<p>​    两个本无所交集的医生和护士，在大年欢庆的时刻，毅然踏上了赴汉的路程，他们不是飞机接送，不是客车接送，一个不惧百里，一辆单车硬是骑出了一条宽广大路，女孩步行穿过大桥的场景很是震撼，无数人竖起了大拇指，为她加油。另一个火车转汽车再到步行，终于在一个义字当头的村庄碰到一起，同行又是同行，为双方鼓足了勇气，这个村庄下我看到了并不是人人畏惧病毒，他们所表现出来的义是小义也是大义。之后就是他们骑电车进入武汉城的那一刻，震惊了我，镜头下的武汉城是灰蒙蒙的，路上没有一个人，这一刻我感觉到的窒息，像是电影中表现的*城一样，真真切切的用一个镜头然后感受到什么叫做空城一般，也许这就是疫情下的残酷吧。两人各自奔赴战场，我去完成自己的使命，最终为完成对路途中遇见的小男孩的承诺，再次并肩作战，带去桃子核 的同时，为两位病人带来了坚持下去的勇气。义无反顾，同行向前。</p>
<p>​    搜索：24小时——防控防疫第二道战线</p>
<p>​    这个单元剧很特别取景并不在武汉，一个从小因为非典失去父母的小孩，长大后毅然做起了流调，主要是反映了在疫情期间流调时间紧任务重，迷雾重重的情况下查找病毒来源的故事，虽说剧情一直扑朔迷离，我们也能眼见的联防联控，但是可能真实的情况并没有表达出来，一直是两个流调员和一个片警在进行各处跑。但是还是给我们上了一课，可能平常的流调工作并不受人重视，但是在这种疫情之下的重要的性就体现出来了，追根溯源是必要且坚决的。还有就是这里边表现的老年人群体儿女终日忙碌疏于陪伴，导致后来的被骗，还是有值得深思的点的。再有就是希望我们不要像那个带着病毒还逃跑的人吧，有一点责任心也不会费那么大的人力物力去搞这个事了。</p>
<p>​    武汉人——搭把手就过了</p>
<p>​    首先先道一声武汉人向你们致敬，该单元包含的情节和内容非常密集，首先反应武汉基层初期防疫物资严重不足，基本上所有人员身着雨衣，用着厨房的橡胶手套，桶装水改造的防护面罩，但他们依然坚守在一线，他们就像一颗钉子一样死死的钉在那里，守护住了武汉，守护住了武汉人民，后期虽然资源得到了补充，但依旧消毒之后多次循环使用。即使这些条件仍旧不能阻挡他们防疫防控、送米送面、代买药品等等，平凡小事中流露着伟大。还表现了初期时间平凡人面对未知的病毒，他们内心真实的恐惧和担忧，男主发烧后在桥上那整段的剧情真的让人很揪心。还有婆媳两人从开始的关系不和到后来相互谦让住院到婆婆给儿媳带上玉镯，才体现人间真情的时刻。大难面前，他们不顾安危彰显出了常人最普通人的真情，才应该是一撇一捺的基本情感吧！反而这最平常最基本的人“情”才是整篇剧情的点睛之笔。</p>
<p>​    在一起没有提到的几个篇章，包含不远万里的“救护者”，最快速度的火神山，一方之舱的真情陪伴，赤子之心的我叫大连，生产口罩的抗疫事业，这些无一不包含着疫情之下的每一份努力。在我看来虽然只讲述了十个故事，但是却表达着中国各行各业在疫情下的奉献。我没有看过原型，但我通过它看到了你们的艰难，你们的付出，什么是真正的英雄，应该就是这些无私忘我，不辞艰辛的人们，他们的举动包罗万象，他们的选择铸就了他们的钢铁形象。你的美好生活，是有人替你负重前行，你们是最美的逆行者，在一起就能众志成城，就能战无不胜。上天无亲，常与善人。</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>看剧</tag>
        <tag>有感</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex使用及理解</title>
    <url>/2019/01/14/vue04/</url>
    <content><![CDATA[<h3 id="Vuex数据管理"><a href="#Vuex数据管理" class="headerlink" title="Vuex数据管理"></a>Vuex数据管理</h3><blockquote>
<p>如何理解数据管理?</p>
<p>这个Vuex就是vue中的数据管理中心 ，相信看过亮剑的大家都知道 ，本来独立团老李管理独立团那是想喝酒喝酒想吃肉吃肉 ，想打仗打仗，但这样的独立团就是比较混乱啊，就是和我们的vue一样 如果数据，都在data里边随取随用，那也一样很混乱，所以我们就需要一个单独的数据中心。也就是赵刚赵政委来了，管独立团的生活了，政委管生活，团长管打仗 ，这样分工也就比较明确。Vuex就是我们的政委。  来吧我们的资料数据管理，任何的管理都不能直接操作，而通过Vuex来统一的调配和转发。</p>
</blockquote>
<p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。– 摘自《 Redux 中文文档 》</p>
<ol>
<li><h4 id="起步安装"><a href="#起步安装" class="headerlink" title="起步安装"></a>起步安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul>
<li>store : 我们的数据管理中心 ，任何的操作都需要通过store  ，也就是我们的赵政委</li>
<li>state ：就是我们存储数据的地方</li>
<li>mutations ： 我们修改数据都需要通过 mutations 来进行操作</li>
</ul>
</li>
<li><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>新建store.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">Vue.use(Vuex);  <span class="comment">// 虽然和我们的router使用类似但我们不能在main.js中use</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>main.js中使用  将我们的store.js 挂载到我们的原型链之上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.use(VueRouter); <span class="comment">//将this.$router 挂载到原型链上，使得vue具有处理路由的能力</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store, <span class="comment">// 相当于把我们的store挂载到原型链之上</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据使用   在.vue中使用this.$store来获取  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Page2"</span>,</span><br><span class="line">        computed:&#123;</span><br><span class="line">            count()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="当我们在对state的数据进行修改的时候-你一定想这样-—直接修改"><a href="#当我们在对state的数据进行修改的时候-你一定想这样-—直接修改" class="headerlink" title="当我们在对state的数据进行修改的时候,你一定想这样 —直接修改"></a>当我们在对state的数据进行修改的时候,你一定想这样 —直接修改</h4><blockquote>
<p>仔细想想这样修改的话不是又回到了我们原来那种 更改state 其他组件也相应，最后你想找到问题来源或者添加新功能时变得困难那种状态了么？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Page2"</span>,</span><br><span class="line">        created()&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.$store.state.count++</span><br><span class="line">            &#125;,<span class="number">2000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>—解决使用vuex的严格模式使用，使用 mutations修改数据 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------store.js中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    strict:<span class="literal">true</span>  <span class="comment">//使用严格模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="使用mutations修改数据"><a href="#使用mutations修改数据" class="headerlink" title="使用mutations修改数据"></a>使用mutations修改数据</h4><p>在vuex中，关于修改state的方式，需要commit提交mutation。官方文档中有这么一句话：</p>
<blockquote>
<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      increment(state)&#123;</span><br><span class="line">          state.count++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    strict:true  //使用严格模式</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于我们现在不能直接去获取物资了，得去政委那等级一下子才能获取物资 </span></span><br><span class="line">created()&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// this.$store.state.count++</span></span><br><span class="line">         <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)          </span><br><span class="line">     &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="上边其实是两种修改state的方式"><a href="#上边其实是两种修改state的方式" class="headerlink" title="上边其实是两种修改state的方式"></a>上边其实是两种修改state的方式</h4><ul>
<li><p>在vuex官方文档上看到了关于严格模式的描述</p>
<blockquote>
<p>开启严格模式，仅需在创建 store 的时候传入 strict: true；<br>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
</blockquote>
</li>
<li><p>于是，将vuex设置成了严格模式。 </p>
<p>直接修改state发现控制台确实是报出了错误，但是state修改成功，并且依然是响应式的。错误提示：</p>
<blockquote>
<p>Do not mutate vuex store state outside mutation handlers.</p>
</blockquote>
<ul>
<li>通过commit 提交 mutation 的方式来修改 state 时，vue的调试工具能够记录每一次state的变化，这样方便调试。但是如果是直接修改state，则没有这个记录。</li>
</ul>
</li>
<li><p>分析源码</p>
<ul>
<li><p>mutation通过commit修改state ，可以看到通过this._withCommit函数处理</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Uf6Iun.jpg" alt></p>
</li>
<li><p>看_ withCommit   ，_ withCommit函数的参数是fn  也就是我们上边的更改state的函数，在执行fn之前 ，将this.comiting =true ,等fn执行完 ，再将this. _commiting = commiting</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Uf6f3Q.jpg" alt></p>
</li>
<li><p>那么这个commiting和 严格模式的strict:true 设置有什么关系</p>
<p><img src="https://s1.ax1x.com/2020/07/20/Uf6W9g.jpg" alt></p>
</li>
<li><p>enableStrictMode() 干了什么  ?   </p>
<blockquote>
<p>在 enableStrictMode 函数内部，调用了 $watch 函数来观察 state的变化。当state变化时，就会调用 assert 函数，判断 store. _commiting( 上边的 this.committing） 的值，如果不为 true，就会报出异常： </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/07/20/Uf6hcj.jpg" alt></p>
</li>
<li><p>所以通过外部直接修改state，则没有执行 commit 函数，也就没有执行 <em>withCommit 函数，进而 this.</em> _ withCommitting 的值 不为 true，故当执行 enableStrictMode 时，则会执行 assert 函数，因为_withCommitting不为true，则报出异常了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="getters-：Vuex内部也需要-computed这个功能-，比如将数据格式化"><a href="#getters-：Vuex内部也需要-computed这个功能-，比如将数据格式化" class="headerlink" title="getters  ：Vuex内部也需要 computed这个功能 ，比如将数据格式化"></a>getters  ：Vuex内部也需要 computed这个功能 ，比如将数据格式化</h4><blockquote>
<p>有时候我们需要从store中的state中派生出一些状态  ，可以理解为vuex中数据的computed功能</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------store.js</span></span><br><span class="line">getters:&#123;</span><br><span class="line">    money:<span class="function"><span class="params">state</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;state.count*<span class="number">1000</span>&#125;</span>`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------.vue 文件中 </span></span><br><span class="line">computed:&#123;</span><br><span class="line">    money()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.money</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="Action-修改数据"><a href="#Action-修改数据" class="headerlink" title="Action :修改数据"></a>Action :修改数据</h4><blockquote>
<p>但是Mutations必须是同步的，Action是异步的Mutation，配合dispatch使用，定义上是一个异步的任务 ，大部分的任务 包括网络请求，网络数据的获取、文件的读取全部是异步的使用dispatch</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------.vue文件中 </span></span><br><span class="line"> created()&#123;</span><br><span class="line"> <span class="comment">// setTimeout(()=&gt;&#123;</span></span><br><span class="line"> <span class="comment">//     // this.$store.state.count++</span></span><br><span class="line"> <span class="comment">// &#125;,2000)</span></span><br><span class="line">     <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>)  <span class="comment">//在incrementAsync内部我们再去执行我们的异步操作</span></span><br><span class="line">     <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>,&#123; <span class="comment">//还可以加参数</span></span><br><span class="line">         num:<span class="number">10</span></span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------store.js</span></span><br><span class="line">mutations:&#123;</span><br><span class="line">    increment(state,args)&#123;</span><br><span class="line">        state.count+= args.num || <span class="number">1</span>  <span class="comment">//加参数后的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions:&#123;</span><br><span class="line">    incrementAsync(store,args)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            store.commit(<span class="string">'increment'</span>,args);<span class="comment">//在去执行Mutations的任务，args参数</span></span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><blockquote>
<p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会使得代码冗余和重复</p>
<p>为了解决这个问题使用mapState辅助函数帮助我们生成计算属性 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    ...  <span class="comment">//还有一堆的属性  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        count:<span class="function"><span class="params">state</span>=&gt;</span>state.count</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// count()&#123;</span></span><br><span class="line">    <span class="comment">//     return this.$store.state.count</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><blockquote>
<p>和mapState类似 ，把actions方法映射进来</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="comment">// this.$store.dispatch('incrementAsync',&#123; //还可以加参数</span></span><br><span class="line">    <span class="comment">//     num:10</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="keyword">this</span>.incrementAsync(&#123;  <span class="comment">//直接使用这个更优雅 、更像组件内部的代码</span></span><br><span class="line">        num:<span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">     ...mapActions([<span class="string">"incrementAsync"</span>])</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h4><blockquote>
<p>聪明的你也一定和我一样想到了mapMutations</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.increment(&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"> methods:&#123;</span><br><span class="line">     ...mapMutations([<span class="string">"increment"</span>])</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>State：用来存状态。在根实例中注册了store 后，用 <code>this.$store.state</code> 来访问。</p>
<p>Getters：从 state 上派生出来的状态。可以理解为基于 State 的计算属性。很多时候，不需要 Getters，直接用 State 即可。</p>
<p>Mutations：用来改变状态。需要注意的是，Mutations 里的修改状态的操作必须是同步的。在根实例中注册了 store 后， 可以用 <code>this.$store.commit(&#39;xxx&#39;, data)</code> 来通知 Mutations 来改状态。</p>
<p>Actions：通过调用 Mutations 来改状态。Actions 可以包含异步操作。在根实例中注册了 store 后， 可以用 <code>this.$store.dispatch(&#39;xxx&#39;, data)</code> 来存触发 Action。</p>
</li>
<li><h4 id="Vuex完整数据流程"><a href="#Vuex完整数据流程" class="headerlink" title="Vuex完整数据流程"></a>Vuex完整数据流程</h4><p><img src="https://s1.ax1x.com/2020/07/20/Uf64js.jpg" alt></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vuex数据流</tag>
      </tags>
  </entry>
</search>
