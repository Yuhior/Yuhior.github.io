<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuhior&#39;s Blog</title>
  
  <subtitle>生活不止于眼前的苟且</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-22T08:50:07.243Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yuhior</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说说正则的那些事</title>
    <link href="http://yoursite.com/2020/05/22/RegExp/"/>
    <id>http://yoursite.com/2020/05/22/RegExp/</id>
    <published>2020-05-22T03:31:03.000Z</published>
    <updated>2020-05-22T08:50:07.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我胡汉三终于又又又回来了，哈哈哈哈……什么？你说我不着调？不可能的我堂堂Yuhior 怎么可能干不着调的事呢？回顾一下最近的生活和学习，越发觉得每天光用框架啊，什么Vue啊，什么React啊，当然这些我都不会啊，哈哈哈，学习这些感觉力不从心，决心重新学习js，打好自己的基础能力，深知自己这座小平房地基不稳，哪能期盼盖出高楼啊，那最后塌了，不得害死自己啊，所以最近在看书，看红宝书（超级推荐），今天看到正则表达式觉得自己原来哪会什么正则啊，都是临到用了去搜一搜，虽说造轮子和吹飞机有一定区别，但是自己还是应该去深入学习，毕竟自己的才是财富。废话不多说，来看看我对正则的理解，如有不到之处，求大佬们请勿嫌弃我这个小渣渣。开始吧</p></blockquote><ul><li><h3 id="招式一：元字符匹配"><a href="#招式一：元字符匹配" class="headerlink" title="招式一：元字符匹配"></a>招式一：元字符匹配</h3><p>正则表达式也就是匹配的模式，要么是要去匹配想要的字符，要么是匹配位置 ，但是有木有感觉元字符太多记不住？第一我们先知道匹配模式有3个标志 ：</p><p>g:表示全局模式，将被应用于所有的字符串。而非发现第一个匹配项时立即停止；</p><p>i:表示不区分大小写，即在确定匹配项时忽略模式与字符串的大小写；</p><p>m：表示多行模式，即在到达一行的文本末时，继续向下一行进行查找；</p><ol><li><p>有两种模糊匹配（如果精准匹配，没多大意义，那还不如用直接indexof）</p><ul><li><p>横向模糊（长度不固定） {2，5}</p><p>/ab{2，5}c/  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,5&#125;c/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abc abbc abbbc abbbbc abbbbbc abbbbbbc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex))</span><br><span class="line"><span class="comment">//  ["abbc", "abbbc", "abbbbc", "abbbbbc"]</span></span><br></pre></td></tr></table></figure></li><li><p>纵向模糊（配到某个字符不确定是特定的字符）[abc]</p><p>/a[123]b/</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex  =  <span class="regexp">/a[bcd]b/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"abb acb adb afb agb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line">[<span class="string">"abb"</span>, <span class="string">"acb"</span>, <span class="string">"adb"</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符组 （很想数组把？ 也就是 [ ] 中有一些字符 ）</p><ul><li><p>范围表示</p><p>[abc]很短还好说，但是要很长怎么办？不能一个个写把? 那范围表示法就来了</p><p>[123456abcdefgHIJKLMN]    =&gt; [1-6a-gH-N]    用 连字符 -来省略和简写</p><p>但是要匹配 “a” “-“  “z” 任意一个字符怎么办？  可以写成[-az]或者[az-]或者[a-z]</p></li><li><p>排除字符组</p><p>有一种情况就是纵向模糊匹配，某位字符可以是任何东西，但是就是不能是某个字符，也就是求反</p><p>[^abc]</p><p>当然后边的也有相应的范围表示表示法  [ ^abcdefghijkl]  =&gt;[ ^a-l]</p></li><li><p>常见的简写形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d =&gt;[<span class="number">0</span><span class="number">-9</span>]  表示一位数字  也就是digit</span><br><span class="line">\D =&gt;[^<span class="number">0</span><span class="number">-9</span>] 表示除数字外的任意字符</span><br><span class="line">\w =&gt;[<span class="number">0</span><span class="number">-9</span>a-zA-Z]  表示数字、大小写字母和下划线。word </span><br><span class="line">\W =&gt;[^<span class="number">0</span><span class="number">-9</span>a-zA-Z]  表示非单词字符</span><br><span class="line">\s =&gt;[\t\v\n\r\f] 表示空白符  记忆也就是 space</span><br><span class="line">\S =&gt;[^\t\v\n\r\f]  非空白符</span><br><span class="line">. 通配符  除换行符、回车符、行分隔符、段分隔符除外的所有</span><br><span class="line">匹配任意字符 [^]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>量词 {2，5}</p><ul><li><p>简写形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;m,&#125; =&gt; 至少出现m次</span><br><span class="line">&#123;m&#125; =&gt; 表示出现m次</span><br><span class="line">? =&gt;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,表示出现或者不出现 。记忆： 有么？</span><br><span class="line">+ =&gt;&#123;<span class="number">1</span>,&#125; 表示出现至少一次 。 记忆：加号是追加的意思，得先有一个，然后才考虑从追加</span><br><span class="line">* =&gt;&#123;<span class="number">0</span>,&#125; 表示出现任意次，有可能不出现，记忆：看天上星星，黑天啊没有，可能是零星几颗，也可能是数不过来</span><br></pre></td></tr></table></figure></li><li><p>贪婪匹配和惰性匹配</p><p>贪婪匹配：他会尽可能多的匹配，反正在能力范围之内，越多越好</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;/g</span>;   <span class="comment">// 表示数字连续出现2-5次</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">//["123", "1234", "12345", "12345"]</span></span><br></pre></td></tr></table></figure><p>惰性匹配：很懒啊 像我一样，能匹配到俩个就绝不多匹配，量词后面加个问号就能实现惰性匹配，记忆方法：问一问你知足了吗，你很贪婪吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;2,5&#125;?/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"123 1234 12345 123456"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">//["12", "12", "34", "12", "34", "12", "34", "56"]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>多选分支 （或者也可以叫 “或”  ）</p><p>多选模式：展现形式（p1 | p2 | p3 ),其中得p1,p2,p3都是子模式，表示其中任何之一都可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|nice/g</span>;</span><br><span class="line"><span class="keyword">var</span> string =<span class="string">"good idea, nice try."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regex));</span><br><span class="line"><span class="comment">//  ["good", "nice"]</span></span><br></pre></td></tr></table></figure><p>*<em>注意 当我们用 /good|goodbye/ ，去匹配“goodbye”时，结果只是good</em>，说明分支结构是惰性得，也就是前边的上了，后边就不会再去尝试了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// ["good"]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/goodbye|good/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// ["goodbye"]</span></span><br></pre></td></tr></table></figure></li></ol></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我胡汉三终于又又又回来了，哈哈哈哈……什么？你说我不着调？不可能的我堂堂Yuhior 怎么可能干不着调的事呢？回顾一下最近的生活和学习，越发觉得每天光用框架啊，什么Vue啊，什么React啊，当然这些我都不会啊，哈哈哈，学习这些感觉力不从心，决心重
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="RegExp" scheme="http://yoursite.com/tags/RegExp/"/>
    
  </entry>
  
  <entry>
    <title>git小记</title>
    <link href="http://yoursite.com/2020/05/07/git/"/>
    <id>http://yoursite.com/2020/05/07/git/</id>
    <published>2020-05-07T08:21:39.000Z</published>
    <updated>2020-05-07T09:46:23.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近看了好多公众号的推送，基本都是给同行打气的，还有诉说当前互联网大环境的，疫情之下充满了挑战，很多的程序员都面临降薪被辞退的可能，但是挑战伴随着机遇，（是不是很官方哈哈哈哈），其实不管环境怎样，你改变不了环境只能改变自己，当然不是让你随波逐流，不要曲解我的意思哦，改变自己是硬道理，提升自己不管在什么样的环境下都会比较吃香，毕竟优胜略汰，有着它一定的法则，是金子总会发光的，是吧？老铁们。哈哈哈哈听懂的请扣1。</p></blockquote><ol><li><p>项目初始化</p><ul><li><p>先要有个项目库  github上创建一个</p><p>会有一个https连接产生 ，也就是项目库地址</p></li><li><p>连接项目库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init   // 项目初始化产生.git文件夹，如果是脚手架则省略这步</span><br><span class="line">git remote add origin &lt;刚才产生的https地址&gt;</span><br><span class="line">git remote -v     // 查询是否连接到项目库</span><br><span class="line">git add .     // 工作区中所有未跟踪或者修改的文件添加到暂存区</span><br><span class="line">git commit -m  "信息" // 提交了啊</span><br><span class="line">git push origin master   //上传本地当前分支代码到master分支</span><br></pre></td></tr></table></figure></li><li><p>输入用户名和密码，每次push都要输入是不是很麻烦？ 采用修改git配置文件的方法</p><p>在用户文件夹下找到 <code>.gitconfig</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = xxx</span><br><span class="line">    email = xxx@xxxxx.com</span><br></pre></td></tr></table></figure><p>后边追加一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">     helper=store</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>2. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近看了好多公众号的推送，基本都是给同行打气的，还有诉说当前互联网大环境的，疫情之下充满了挑战，很多的程序员都面临降薪被辞退的可能，但是挑战伴随着机遇，（是不是很官方哈哈哈哈），其实不管环境怎样，你改变不了环境只能改变自己，当然不是让你随波逐流，不
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="git入门" scheme="http://yoursite.com/tags/git%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://yoursite.com/2020/04/30/deep-copy/"/>
    <id>http://yoursite.com/2020/04/30/deep-copy/</id>
    <published>2020-04-30T08:53:10.000Z</published>
    <updated>2020-05-07T06:28:44.689Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wx2.sinaimg.cn/mw690/005N9IKrly1gebwclecvbj31d10u0dhq.jpg" alt="黑松、蓝天、白雪"></p><blockquote><p>上一篇文章还是沉浸再要过年的喜庆气氛当中，但怎么都没有想到疫情是如此的严重，还是希望各位珍爱生命远离病毒吧！，回顾一下过去的几个月，还好像再眼前，不禁感叹道时间过得实在太快，最近也在持续关注各大厂的招聘情况，感觉疫情之下，机会更少了，要求更多了，但是话又说回来，上天对每个人都是公平的，机会是对等的，只有不断地充实自己才是王道。所以我又来给各位灌毒鸡汤来了，干了这碗，咱们开始讲今天的主题，也就是我最近再啃得原生js。</p></blockquote><ol><li><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型分为两种，基本数据类型和引用数据类型，基本数据类型存储直接存储在栈内存中，而对于引用类型来说，它在栈内存中仅仅存了一个引用，而真正得数据存储在堆内存中。看一下示例图</p><p><img src="https://wx2.sinaimg.cn/mw690/005N9IKrly1gebwo6fy7hj30ql0ewta3.jpg" alt></p><p>引用类型就是存在堆内存中，两个对象是在用指针指向同一个堆内存得地址 </p><p><img src="https://wx4.sinaimg.cn/mw690/005N9IKrly1gebwofq125j30rx0fbju5.jpg" alt></p></li></ol><ol start="2"><li><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>既然要说深拷贝，那估计大家都知道肯定有浅拷贝啊，那什么是浅拷贝呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型得的浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span> ; </span><br><span class="line"><span class="keyword">var</span> b = a ;</span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 5 </span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的浅拷贝</span></span><br><span class="line"><span class="keyword">var</span>  obj = &#123;</span><br><span class="line">    name:<span class="string">'yuhior'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    class:'三年二班'</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj ;</span><br><span class="line">obj2.name = <span class="string">'张三了'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// 张三了</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name)  <span class="comment">// 张三了</span></span><br></pre></td></tr></table></figure><p>上边我们发现 基本类型由于存储在栈内存中，是两个相对独立的数据，所以更改一个另一个并不会改变，但是引用类型的obj 改变的name ，将 obj 赋予 obj2 的时候，我们其实仅仅只是将 obj 存储在栈堆中的的引用赋予了 obj2 ，而两个对象此时指向的是在堆内存中的同一个数据，所以当我们修改任意一个值的时候，修改的都是堆内存中的数据。我称 这种 = 只拷贝对象的引用，而不深层次的拷贝对象的值叫浅拷贝</p></li><li><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>在实际项目中，尤其是使用vue ，数据双向绑定的框架时，尤其明显的能感知到每个对象指向一个堆内存，一个改变另一些全部改变，根本不便于操作 。所以我们要深拷贝，我们要自由 哈哈哈哈哈。深拷贝就不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一下，形成一个全新的堆内存存储。    </p></li><li><h3 id="深拷贝的实现方法"><a href="#深拷贝的实现方法" class="headerlink" title="深拷贝的实现方法"></a>深拷贝的实现方法</h3><ul><li><p>低配版 JSON.stringify()和JSON.parse() </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  obj = &#123;</span><br><span class="line">    name:<span class="string">'yuhior'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    class:'三年二班'</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj2.name = <span class="string">'张三了'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// yuhior</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name)  <span class="comment">// 张三了</span></span><br></pre></td></tr></table></figure><p>缺点：不可以拷贝undefined 、function 、RegExp类型 的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// 直接报错  </span></span><br><span class="line"><span class="comment">// VM4562:1 Uncaught SyntaxError: Unexpected token u in JSON at position 0</span></span><br><span class="line"><span class="comment">//     at JSON.parse (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:1:17</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assign (target,source)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>缺点：可以看到对于一层对象来说是没有任何问题的，但是如果对象的属性对应的是其它的引用类型的话，还是只拷贝了引用，修改的话还是会有问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;    <span class="comment">// 来一个多层的</span></span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">11</span>,</span><br><span class="line">    c: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.c[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.c); <span class="comment">// ["a", 6, "c"]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.c); <span class="comment">// ["a", 6, "c"] </span></span><br><span class="line"><span class="comment">// 两个都改变了说明还是引用了</span></span><br></pre></td></tr></table></figure></li><li><p>递归拷贝 ，也是面试官常考的 ，我们还是先来举个栗子，毕竟学习了，还能吃栗子还是很爽的把 ，哈哈哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  写一个深拷贝的方法把</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">depClone</span>(<span class="params">tar</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// tar如果是一个对象的话</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(tar)===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="comment">// typeof(Array) ==='object';  如果是一个数组</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(tar))&#123;</span><br><span class="line">            result = []; <span class="comment">// 将result 设定为数组 并执行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tar)&#123;</span><br><span class="line">                <span class="comment">//进行克隆数组中的每一项</span></span><br><span class="line">                result.push(deepClone(tar[i])); </span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//  如果是null的话，那就直接赋值null</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar === <span class="literal">null</span>)&#123; </span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tar.constructor===<span class="built_in">RegExp</span>)&#123;</span><br><span class="line">             result = tar;</span><br><span class="line">         <span class="comment">//最后就是普通的对象了，直接进行循环，递归赋值所有的值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = &#123;&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> tar)&#123;</span><br><span class="line">                result[i] = deepClone(tar[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果不是对象的话，那就是一个基本类型了，那就直接赋值被</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = tar ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终于到回归结果的时候啦</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锅都准备好啦，那就赶紧做个饭试一下把！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个对象 多层嵌套，还含有undefined  </span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        b:<span class="regexp">/a/</span>,</span><br><span class="line">        c:<span class="literal">undefined</span>,</span><br><span class="line">        d:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,</span><br><span class="line">    c:[</span><br><span class="line">        &#123;</span><br><span class="line">            b:<span class="regexp">/a/</span>,</span><br><span class="line">            c:<span class="literal">undefined</span>,</span><br><span class="line">            d:<span class="literal">null</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'a'</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = deepClone(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">//  相信你勤快的小手，自己打印一下看看把</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/005N9IKrly1gebwclecvbj31d10u0dhq.jpg&quot; alt=&quot;黑松、蓝天、白雪&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇文章还是沉浸再要过年的喜庆气氛当中，但怎么
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="深拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>初识Linux之二</title>
    <link href="http://yoursite.com/2020/01/15/linux-publish2/"/>
    <id>http://yoursite.com/2020/01/15/linux-publish2/</id>
    <published>2020-01-15T09:20:15.000Z</published>
    <updated>2020-01-15T10:43:24.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020年了，这是今年的第一篇，希望新的一年有新的开始，并希望你们像我一样越来越优秀哈哈哈，临近新年过年的气息也越来越浓郁，自己也期盼过年回家呀，临近年底项目还是无情的一如既往的压榨着我们，忙的手忙脚乱的（菜鸟专属毕竟大佬们可都是临危不乱的），某人鼓励我坚持写博客，我也重拾起写博客的习惯，坚持学习，坚持记录，毕竟这是一个记录成长的过程。2020少皱眉多微笑。</p></blockquote><p><img src="https://wx2.sinaimg.cn/mw690/005N9IKrly1gaxe8hislkj30to0jejxf.jpg" alt="GUOMAO Night"></p><p>上回书说道，张飞张翼德驾马来到曹操营前，大声骂道，曹操…..,停停停不好意思走错频道了，一看就不是个正经写记录的哈哈哈，上篇文章我们讲了Linux下的FTP安装配置还有Linux下安装node.js ，那今天我们就说Linux下使用Express搭建web服务把，如果你想用koa或者egg，不好意思哈，你问下度娘告不告诉你哈。开始吧。</p><ul><li><p>Linux下用Express搭建web服务器（其实和本地搭建没什么区别）</p><ol><li><p>先连接上我们的服务器把，启动xshell，输入用户名和密码连接上服务器。</p></li><li><p>cd到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/</span><br></pre></td></tr></table></figure></li><li><p>创建web服务项目文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo</span><br></pre></td></tr></table></figure></li><li><p>进入项目目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br></pre></td></tr></table></figure></li><li><p>本地下的项目安装express模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -g express express-generator</span><br><span class="line">express ***（项目名）--hbs （模板引擎）</span><br><span class="line">#cd 项目文件下</span><br><span class="line">#安装依赖</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></li><li><p>项目打包，将打包好的如vue的dist文件放进var/www/demo文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用FTP进行上传</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>你会发现你访问你的服务器ip加端口时会访问的到，但是关闭了，服务器这个也关闭了。下面将应对方法</p></li></ol></li><li><p>安装PM2托管Node Web服务程序</p><ol><li><p>安装pm2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure></li><li><p>创建软连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/nodejs/bin/pm2 /usr/local/bin/pm2</span><br></pre></td></tr></table></figure></li><li><p>启动托管命令，输入下面的命令启动托管任务，<code>abc</code>为托管项目定义的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js --name abc</span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2020年了，这是今年的第一篇，希望新的一年有新的开始，并希望你们像我一样越来越优秀哈哈哈，临近新年过年的气息也越来越浓郁，自己也期盼过年回家呀，临近年底项目还是无情的一如既往的压榨着我们，忙的手忙脚乱的（菜鸟专属毕竟大佬们可都是临危不乱的），某人
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="node项目部署" scheme="http://yoursite.com/tags/node%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>初识Linux之一</title>
    <link href="http://yoursite.com/2019/12/25/linux-publish/"/>
    <id>http://yoursite.com/2019/12/25/linux-publish/</id>
    <published>2019-12-25T07:49:50.000Z</published>
    <updated>2020-01-14T08:26:50.577Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://wx3.sinaimg.cn/mw690/005N9IKrly1gaw2pbj2fhj30tm0gkdjp.jpg" alt=" 2020第一场雪 "></p><blockquote><p>好久没有更新自己的博客了，也说明自己在这几个月的时间没有怎么学习，主要吧事情真的很多(强行狡辩)，不过虽然技术没有增长太多，但是还是有很多的收获的，今年好像对新年没有太多的概念，但是深切的感觉到这一年又过去了，所以啊，想抓住这一年的尾巴，抽一下自己哈哈哈哈。</p></blockquote><h4 id="一、Linux服务器介绍及购买"><a href="#一、Linux服务器介绍及购买" class="headerlink" title="一、Linux服务器介绍及购买"></a>一、Linux服务器介绍及购买</h4><ul><li><p>​    linux服务器介绍</p><p>对于linux服务器本人也知之甚少，作为一个前端菜鸟贼喜欢折腾的我，自己的服务器到期了，然后就续费被，然后就续了个linux，至于为什么要买linux系统呢？哈哈哈，我也不知道。只是听朋友说好，就这么简单。不过还是简单说一下相对于window服务器的可视化界面，linux命令行好像更符合程序员，毕竟大多程序员都喜欢带你装*带你飞（开玩笑别打我哈！！！），linux系统应该是通过一系列命令行来进行操作，这就是我对它最表面的看法。</p><ol><li>最稳定：使用Linux服务器是有意义的，因为它被认为是当今市场上最稳定的平台。您不必担心重新启动系统或不断下载更新。</li><li>性能佳：Linux也因其目前可用的任何服务器的最佳性能而闻名。使用Linux，您可以让大量用户在同一服务器上工作而不会出现任何问题。它也是用于网络目的的理想服务器。</li><li>多任务处理能力：使用Linux服务器时，您还可以执行多任务。众所周知，Linux能够处理同时运行的许多不同程序。对于其他操作系统，当您打开其他内容时，他们可能会将某些程序置于“睡眠模式”。</li><li>灵活性高：在Linux的平台被称为是非常灵活，适用于多种不同的情况。由于它来自开源程序，程序员可以根据您的需要进行自定义。凭借这种灵活性，它还使平台更加安全。</li></ol></li><li><p>购买</p><p>本人是购买的阿里云的服务器，其他服务器自行查询购买，直接进阿里云官方，直接选云服务器ECS，看需要进行购买，我的是CPU：两核，内存 4G，操作系统： CentOS 7.7 64位，然后买就完事了。</p></li></ul><h4 id="二、部署web网站"><a href="#二、部署web网站" class="headerlink" title="二、部署web网站"></a>二、部署web网站</h4><ul><li><p>部署FTP</p><p>有了Linux服务器是不是感觉不知所措不知道干什么，停下来想一想，在我们平常工作的时候网站运行的时候都需要什么？这其实就好比你在做饭之前，需要想好都需要什么食材，虽然我做的饭很难吃（还被某人说过菜的长相贼丑，黑乎乎啥也看不出……..）,回到正题是不是需要MySQL、web服务环境、FTP等各种工具。</p><hr><ol><li><p>Centos7 FTP安装与部署</p><ul><li><p>FTP安装包下载及安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install -y vsftpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl start vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">systemctl stop vsftpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">systemctl status vsftpd.service</span><br></pre></td></tr></table></figure></li><li><p>配置FTP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置 12 行</span></span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置 33 行</span></span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置48行</span></span><br><span class="line">chown_uploads=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置72行</span></span><br><span class="line">async_abor_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置82行</span></span><br><span class="line">ascii_upload_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置83行</span></span><br><span class="line">ascii_download_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置86行</span></span><br><span class="line">ftpd_banner=Welcome to blah FTP service.</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置100行</span></span><br><span class="line">chroot_local_user=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加下列内容到vsftpd.conf末尾</span></span><br><span class="line">use_localtime=YES</span><br><span class="line">listen_port=21</span><br><span class="line">idle_session_timeout=300</span><br><span class="line">guest_enable=YES</span><br><span class="line">guest_username=vsftpd</span><br><span class="line">user_config_dir=/etc/vsftpd/vconf</span><br><span class="line">data_connection_timeout=1</span><br><span class="line">virtual_use_local_privs=YES</span><br><span class="line">pasv_min_port=40000</span><br><span class="line">pasv_max_port=40010</span><br><span class="line">accept_timeout=5</span><br><span class="line">connect_timeout=1</span><br><span class="line">allow_writeable_chroot=YES</span><br></pre></td></tr></table></figure></li><li><p>建立用户文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建编辑用户文件</span></span><br><span class="line">vim /etc/vsftpd/virtusers</span><br><span class="line"><span class="comment">#第一行为用户名，第二行为密码。不能使用root作为用户名 </span></span><br><span class="line"></span><br><span class="line">admin</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></li><li><p>生成用户数据文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db_load -T -t <span class="built_in">hash</span> -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定PAM验证文件，并指定对虚拟用户数据库文件进行读取</span></span><br><span class="line"></span><br><span class="line">chmod 600 /etc/vsftpd/virtusers.db</span><br></pre></td></tr></table></figure></li><li><p>修改/ect/pam.d/vsftpd  文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前先备份 </span></span><br><span class="line"></span><br><span class="line">cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak</span><br><span class="line"></span><br><span class="line">vi /etc/pam.d/vsftpd</span><br><span class="line"><span class="comment">#先将配置文件中原有的 auth 及 account 的所有配置行均注释掉</span></span><br><span class="line">auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers </span><br><span class="line">account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果系统为32位，上面改为lib</span></span><br></pre></td></tr></table></figure></li><li><p>新建系统用户vsftpd，用户目录为/home/vsftpd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用户登录终端设为/bin/false(即：使之不能登录系统)</span></span><br><span class="line">useradd vsftpd -d /home/vsftpd -s /bin/<span class="literal">false</span></span><br><span class="line">chown -R vsftpd:vsftpd /home/vsftpd</span><br></pre></td></tr></table></figure></li><li><p>建立虚拟用户个人配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/vsftpd/vconf</span><br><span class="line"><span class="built_in">cd</span> /etc/vsftpd/vconf</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里建立虚拟用户leo配置文件</span></span><br><span class="line">touch admin</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑leo用户配置文件，内容如下，其他用户类似</span></span><br><span class="line">vi admin</span><br><span class="line"></span><br><span class="line">local_root=/home/vsftpd/leo/</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立leo用户根目录</span></span><br><span class="line">mkdir -p /home/vsftpd/leo/</span><br></pre></td></tr></table></figure></li><li><p>防火墙设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IPtables 的设置方式：</span><br><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line"><span class="comment">#编辑iptables文件，添加如下内容，开启21端口</span></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 40000:40010 -j ACCEPT</span><br><span class="line"></span><br><span class="line">firewall 的设置方式：</span><br><span class="line">firewall-cmd --zone=public --add-service=ftp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=public --add-port=21/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=40000-40010/tcp --permanent</span><br></pre></td></tr></table></figure></li><li><p>重启vsftpd服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart vsftpd.service</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Centos7 FTP连接</p><ul><li><p>这个时候，使用ftp的工具连接时，我们发现是可以连接的。传输文件的时候，会发现文件上传和下载都会出现500、503 、200等问题。这个时候，可以进行以下三种操作：</p><ul><li><p>关闭SELINUX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开SELINUX配置文件</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置参数</span></span><br><span class="line"><span class="comment">#注释  </span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加  </span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改完成后，需要重启！</span></span><br></pre></td></tr></table></figure></li><li><p>修改SELINUX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0 <span class="comment">#暂时让SELinux进入Permissive模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#列出与ftp相关的设置</span></span><br><span class="line">getsebool -a|grep ftp</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下是显示出来的权限，off是关闭权限，on是打开权限。不同的机器显示的可能不一样。我看了我的显示的，和网上其他教程就不太一样</span></span><br><span class="line">ftp_home_dir --&gt; off</span><br><span class="line">ftpd_anon_write --&gt; off</span><br><span class="line">ftpd_connect_all_unreserved --&gt; off</span><br><span class="line">ftpd_connect_db --&gt; off</span><br><span class="line">ftpd_full_access --&gt; off</span><br><span class="line">ftpd_use_cifs --&gt; off</span><br><span class="line">ftpd_use_fusefs --&gt; off</span><br><span class="line">ftpd_use_nfs --&gt; off</span><br><span class="line">ftpd_use_passive_mode --&gt; off</span><br><span class="line">httpd_can_connect_ftp --&gt; off</span><br><span class="line">httpd_enable_ftp_server --&gt; off</span><br><span class="line">sftpd_anon_write --&gt; off</span><br><span class="line">sftpd_enable_homedirs --&gt; off</span><br><span class="line">sftpd_full_access --&gt; off</span><br><span class="line">sftpd_write_ssh_home --&gt; off</span><br><span class="line">tftp_anon_write --&gt; off</span><br><span class="line">tftp_home_dir --&gt; off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将包含有 ftp_home_dir 和 ftpd_full_access 相关的都设置为 1</span></span><br><span class="line"></span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line">setsebool -P allow_ftpd_anon_write 1</span><br><span class="line">setsebool -P ftp_home_dir 1</span><br><span class="line"></span><br><span class="line">setenforce 1 <span class="comment">#进入Enforcing模式</span></span><br></pre></td></tr></table></figure></li><li><p>SELINUX不对vsftp不做任何限制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsebool -P ftpd_connect_all_unreserved 1</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol></li><li><p>Node.js安装</p><ol><li><p>去官网复制安装包信息</p><p>[<a href="http://nodejs.cn/download/]" target="_blank" rel="noopener">http://nodejs.cn/download/]</a>: </p><p><img src="https://wx3.sinaimg.cn/mw690/005N9IKrly1gaw4n0mti7j310r0jodjv.jpg" alt></p></li><li><p>使用xshell（推荐）或者putty连接你的Linux，在xshell里cd到安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure></li><li><p>输入命令连接开始下载node.js安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://npm.taobao.org/mirrors/node/v12.14.1/node-v12.14.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d node-v10.16.0-linux-x64.tar.xz</span><br><span class="line">tar -xvf node-v10.16.0-linux-x64.tar</span><br></pre></td></tr></table></figure></li><li><p>重命名解压文件夹名称为nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv node-v10.16.0-linux-x64 nodejs</span><br></pre></td></tr></table></figure></li><li><p>进入解压目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nodejs</span><br></pre></td></tr></table></figure></li><li><p>创建软连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s  /usr/local/nodejs/bin/node /usr/local/bin/node</span><br><span class="line">ln -s  /usr/local/nodejs/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></li><li><p>测试node是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm淘宝镜像并创建软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment">#检查安装成功是否通过</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用express或者koa或egg搭建web服务环境请见《初识Linux之二》</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/mw690/005N9IKrly1gaw2pbj2fhj30tm0gkdjp.jpg&quot; alt=&quot; 2020第一场雪 &quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好久没有更新自己的博客了，也说明自己在这几个
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="node项目部署" scheme="http://yoursite.com/tags/node%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>webapck手动配置（一）</title>
    <link href="http://yoursite.com/2019/04/02/webapck-learn1/"/>
    <id>http://yoursite.com/2019/04/02/webapck-learn1/</id>
    <published>2019-04-02T14:49:11.000Z</published>
    <updated>2019-04-02T15:01:27.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前几天去面试了，但是学习还是不应该落下的，面试的过程中碰见了超级nice的云龙哥（偶像），其中聊到webpack，意识到还是很需要懂得webpack的配置信息的，于是学习一下webpack的手动配置，但是用的比较新的的node版本，不知道很多步骤是不是和webpack2.0的一致，所以肯定有很多不足 。</p></blockquote><ul><li><h4 id="入门级"><a href="#入门级" class="headerlink" title="入门级"></a>入门级</h4><ul><li><p>项目初始化，在你的项目目录里边初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li><p>新建项目结构src，里边index.js 和模块a.js </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是a.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure></li><li><p>新建index.html，用于引用 index.js </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是入口文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./src/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>但是现在我们打开index.html 文件发现浏览器并不能console出我们想要的，因为浏览器并不能支持我们的require语法，于是我们的男猪脚终于上线了，webpack主角光环，哈哈哈当然人家很强不用光环的哈，安装我们的webpack和webpack-cli模块吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webapck webapck-cli -D</span><br></pre></td></tr></table></figure></li><li><p>进行打包bulid ，npx就是从本地的node_modules找命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li><li><p>多了dist 文件夹 ，里面生成了main.js文件  ,现在再引用就ok了吧 ，console也出来了 ，看来主角光环就是厉害，哈哈哈</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这是入口文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>另一种 跑npx 的方式  ，在package.json 的script 中添加命令,现在直接使用 npm run bulid</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webapck"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><ul><li><p>新建webapck.config.js，webpack 默认的配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  </span><br><span class="line">    mode:<span class="string">'development'</span>,  <span class="comment">// 开发模式 不压缩代码</span></span><br><span class="line">    entry : <span class="string">'./src/index.js'</span>, <span class="comment">// 入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        filename: <span class="string">'pack.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'./kkb'</span>) <span class="comment">//需要使用绝对路径，需要引用path  打包文件夹是kkb ，文件名是 pack.js</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="配置webpack-dev-server"><a href="#配置webpack-dev-server" class="headerlink" title="配置webpack-dev-server"></a>配置webpack-dev-server</h4><ul><li><p>目前我们每次更新完，需要重新跑build ，然后再打开html 比较繁琐 ，webpack 专门安装了一个套件，webpack-dev-server</p></li><li><p>安装 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure></li><li><p>配置package.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "build": "webapck",</span><br><span class="line">    "dev": "webpack-dev-server"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>配置webapck.config.js，当然0配置也是可以的</p></li></ul></li><li><h4 id="build完之后加hash过程"><a href="#build完之后加hash过程" class="headerlink" title="build完之后加hash过程"></a>build完之后加hash过程</h4><ul><li><p>在webapck.config.js 的配置中进行hash配置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">filename: &apos;pack.[hash:6].js&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="自动加载html"><a href="#自动加载html" class="headerlink" title="自动加载html"></a>自动加载html</h4><ul><li><p>当然我们build之后出现， pack.6420d5.js文件  ，那么我们html中的引用就也需要更改了，那么我们不可能没次都手动修改吧，那好我们再来进行配置</p></li><li><p>新建public文件夹，新建index.html作为我们的模板</p></li><li><p>使用html-webpack-plugin，并配置webpack-config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebapckPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"> plugins: [</span><br><span class="line">     <span class="keyword">new</span> htmlWebapckPlugin(&#123;</span><br><span class="line">         template: <span class="string">'./public/index.html'</span>,  <span class="comment">//模板文件</span></span><br><span class="line">         filename: <span class="string">'index.html'</span> <span class="comment">// 输出文件的名字</span></span><br><span class="line">     &#125;)</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></li><li><p>再执行 npm run dev  我们修改a.js 浏览器就随之修改了。跑的还是外边的index.html</p></li></ul></li><li><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><ul><li>现在npm run build 就会生成一个带hash 的js和一个index.html 并且引用了这个带hash的js文件</li></ul></li><li><h4 id="支持css"><a href="#支持css" class="headerlink" title="支持css"></a>支持css</h4><ul><li><p>webpack 中所有的东西都是模块，默认require的就是js，但是css 什么的解析成js ，那是不可执行的，那就需要loader来支持配置module，但是<strong>注意</strong> use 的顺序是从右向左执行</p></li><li><p>安装css -loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure></li><li><p>配置webpack-config，和plugin 平级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">//以css结尾</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>] <span class="comment">// 先把css解析出来,并不能直接在js文件执行，我们需要将解析出来的放进style里边，那就需要安装style-loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>安装style-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader -D</span><br></pre></td></tr></table></figure></li><li><p>抽离css  ，当我们要进行单独抽离一个css 文件时，显然上边的插件并不足以满足要求，那肯定有解决的方案啊，不然说它干嘛， mini-css-extract-plugin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>配置文件里配置被，盘它就完了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> htmlWebapckPlugin(&#123;</span><br><span class="line">        template: <span class="string">'./public/index.html'</span>,  <span class="comment">//模板文件</span></span><br><span class="line">        filename: <span class="string">'index.html'</span> <span class="comment">// 输出文件的名字</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'kkb.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">//以css结尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.css$/</span>,</span><br><span class="line">            use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>]  <span class="comment">// 现在我们就不需要把css 塞到style里css解析完就用MiniCssExtractPlugin.loader</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>npm run build 就能看见效果了</li></ul><ul><li><h4 id="支持css预编译stylus（less、sass类似）"><a href="#支持css预编译stylus（less、sass类似）" class="headerlink" title="支持css预编译stylus（less、sass类似）"></a>支持css预编译stylus（less、sass类似）</h4><ul><li><p>stylus-loader stylus安装就完了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install stylus-loader stylus -D</span><br></pre></td></tr></table></figure></li><li><p>一样 来配置吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        ......</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.styl$/</span>,</span><br><span class="line">            use: [MiniCssExtractPlugin.loader,<span class="string">'css-loader'</span>,<span class="string">'stylus-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><h4 id="post-css-兼容性css"><a href="#post-css-兼容性css" class="headerlink" title="post-css 兼容性css"></a>post-css 兼容性css</h4><ul><li><p>安装postcss-loader 和autoprefixer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure></li><li><p>配置config文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        <span class="comment">//以css结尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.css$/</span>,</span><br><span class="line">            <span class="comment">//use: ['style-loader','css-loader']  </span></span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="string">'postcss-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/.styl$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span>,</span><br><span class="line">                <span class="string">'postcss-loader'</span>,</span><br><span class="line">                <span class="string">'stylus-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还需要vue.config.js同级目录下新建一个postcss.config.js 对postcss进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h4 id="ES6-使用大名鼎鼎的babel来把ES6转换成ES5"><a href="#ES6-使用大名鼎鼎的babel来把ES6转换成ES5" class="headerlink" title="ES6 :使用大名鼎鼎的babel来把ES6转换成ES5"></a>ES6 :使用大名鼎鼎的babel来把ES6转换成ES5</h4><ul><li><p>使用babel-loader和@babel/core @babel/preset-env</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core @babel/preset-env -D</span><br><span class="line">// babel-loader是处理js转换的loader </span><br><span class="line">//@babel/core babel核心</span><br><span class="line">//@babel/preset-env 是转换成那个级别的</span><br></pre></td></tr></table></figure></li><li><p>配置吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kkb</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'yuhior'</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈喽'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kkb  = <span class="keyword">new</span> Kkb()</span><br><span class="line">kkb.sayHi()  <span class="comment">//写的ES6</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul><li><p>js中使用图片，显然这样直接npm run dev 肯定识别不出来啊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Logo <span class="keyword">from</span> <span class="string">'./img/logo.png'</span></span><br><span class="line"><span class="keyword">let</span> image =<span class="keyword">new</span> Image()</span><br><span class="line">image.src = Logo</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(image)</span><br></pre></td></tr></table></figure></li><li><p>使用file-loader ，这样js、css 和background都支持图片了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure></li><li><p>不用说了你肯定知道了 ，配置嘛谁不会说啊哈哈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">        use: [<span class="string">'file-loader'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h4 id="底层：npm-run-build-做了什么事情"><a href="#底层：npm-run-build-做了什么事情" class="headerlink" title="底层：npm run build  做了什么事情"></a>底层：npm run build  做了什么事情</h4><ul><li>build  首先去找modules 的webpack模块里边有个bin 目录，下边有个webpack.js ,里边有个installedClis函数，这里回去寻找我们装了什么，如果安装了webpack-cli 就会执行webpakc-cli下面的bin目录文件，如果安装了webapck-command就会执行这个  </li><li>webapck-cli下面有个cli.js 实际执行的是这个 </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前几天去面试了，但是学习还是不应该落下的，面试的过程中碰见了超级nice的云龙哥（偶像），其中聊到webpack，意识到还是很需要懂得webpack的配置信息的，于是学习一下webpack的手动配置，但是用的比较新的的node版本，不知道很多步骤是
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="手动配置，入门" scheme="http://yoursite.com/tags/%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>react-redux原理</title>
    <link href="http://yoursite.com/2019/03/19/react-redux/"/>
    <id>http://yoursite.com/2019/03/19/react-redux/</id>
    <published>2019-03-19T14:38:11.000Z</published>
    <updated>2020-05-22T03:46:10.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用react-redux 怎们能不了解原理，彻底了解原理和单纯的使用，应该不是一个级别的选手吧</p></blockquote><h3 id="redux原理实现"><a href="#redux原理实现" class="headerlink" title="redux原理实现"></a>redux原理实现</h3><ul><li><h5 id="简单的redux"><a href="#简单的redux" class="headerlink" title="简单的redux"></a>简单的redux</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据我们使用redux的用法 ，开始是createStore然后createStore中有getState、dispatch、subscribe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createStore 有两个参数 第一个reducer 第二个参数中间件 (增强)</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState ; <span class="comment">//初始状态 可以是对象或者什么都可以，因为使用时会给出初始值</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = []; <span class="comment">//每次函数的修改都要触发组件的变化 ，所以要有监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 定义getState方法，getState()返回当前的state树，它与 store 的最后一个 reducer 返回值相同。</span></span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;  <span class="comment">//定义我们监听的时候使用的方法</span></span><br><span class="line">        currentListeners.push(listener)  <span class="comment">// 将我们需要监听的组件传递进来，push到currentListeners数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;   <span class="comment">//定义我们的dispatch方法  使用dispatch会传递一个action参数</span></span><br><span class="line">        currentState = reducer(currentState,action);  </span><br><span class="line">        <span class="comment">// reducer 中有两个参数  像这样 counterReducer = (state=0,action)=&gt;&#123; &#125; reducer返回的新的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">value</span> =&gt;</span> value()); </span><br><span class="line">        <span class="comment">// 每次dispatch都执行一下 所有 subscribe里的内容 ，比如index.js中 每一次dispatch都执行render= ()=&gt;&#123;&#125;这个方法</span></span><br><span class="line">        <span class="comment">// const render =()=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//     ReactDOM.render(</span></span><br><span class="line">        <span class="comment">//         &lt;App /&gt;,</span></span><br><span class="line">        <span class="comment">//         document.getElementById('root')</span></span><br><span class="line">        <span class="comment">//     );</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// render();</span></span><br><span class="line">        <span class="comment">// store.subscribe(render);</span></span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>:<span class="string">'@IMOOC/WONIU-REDUX'</span>&#125;);  <span class="comment">//手动先dispatch ,让它第一次dispatch命中默认初始值dispatch，不然不会有初始值</span></span><br><span class="line">    <span class="keyword">return</span> &#123;getState,subscribe,dispatch&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><ul><li><p>Provider</p><blockquote><p>Provider 模块功能并不复杂 ，需要实现一下两点</p></blockquote><ul><li>在原应用组件上包裹一层，使原来整个应用成为Provider的子组件</li><li>接收Redux的store作为props，通过context对象传递给子孙组件上的connect</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;  </span><br><span class="line">//  prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型</span><br><span class="line">export class Provider extends Component&#123;</span><br><span class="line">    static childContextTypes = &#123;  // 设置childContext 状态值类型</span><br><span class="line">        store: PropTypes.object</span><br><span class="line">    &#125;;</span><br><span class="line">    getChildContext()&#123;   // 设置childContext,设置完了这样所有的子元素都能取到</span><br><span class="line">        return &#123;store:this.store&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(props, context)&#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.store = props.store  </span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return this.props.children  // this.props.children是react内置在this.props上的对象，用于获取当前组件的所有子组件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Provider初始化时，获取到props中的store对象；</span><br><span class="line">// 将外部的store对象放入context对象中，使子孙组件上的connect可以直接访问到context对象中的store。</span><br><span class="line">// context可以使子孙组件直接获取父级组件中的数据或方法，而无需一层一层通过props向下传递。</span><br><span class="line">// context对象相当于一个独立的空间，父组件通过getChildContext()向该空间内写值；定义了contextTypes验证的子孙组件可以通过this.context.xxx，从context对象中读取xxx字段的值。</span><br></pre></td></tr></table></figure></li><li><p>connect</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//添加监听对象，并尝试通过 props 将状态传递给子组件</span><br><span class="line">const connect = (mapStateToProps,mapDispatchToProps)=&gt;&#123; //返回一个函数</span><br><span class="line">    return WrappedComponent=&gt;&#123;</span><br><span class="line">        return class ConnectComp extends Component&#123;</span><br><span class="line">            static contextTypes = &#123;</span><br><span class="line">                store:PropTypes.object</span><br><span class="line">            &#125;;</span><br><span class="line">            //获取context</span><br><span class="line">            constructor(props,context)&#123;</span><br><span class="line">                super(props, context)</span><br><span class="line">                this.state = &#123;</span><br><span class="line">                    props:&#123;&#125;  // 手动定义一个state</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            componentDidMount()&#123;</span><br><span class="line">                const &#123;store&#125; = this.context</span><br><span class="line">                store.subscribe(()=&gt;this.update())  // 每次dispatch(更新)都会执行一下subscribe 里边的</span><br><span class="line">                this.update()  //</span><br><span class="line">            &#125;</span><br><span class="line">            update()&#123;</span><br><span class="line">                const &#123;store&#125; = this.context;</span><br><span class="line">                const stateProps =mapStateToProps(store.getState())</span><br><span class="line">                const dispatchProps = bindActionCreators(mapDispatchToProps,store.dispatch)</span><br><span class="line">                //作用是将单个或多个ActionCreator转化为dispatch(action)的函数集合形式。</span><br><span class="line">                //将一个或多个action和dispatch组合起来生成mapDispatchToProps需要生成的内容 ，其实就是把多个action还是用dispatch调用</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    props:&#123;</span><br><span class="line">                        ...this.state.props,</span><br><span class="line">                        ...stateProps,</span><br><span class="line">                        ...dispatchProps</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                return &lt;WrappedComponent &#123;...this.state.props&#125;&gt;&lt;/WrappedComponent&gt;</span><br><span class="line">                // 这个WrappedComponent也就是我们的使用的App，这样的connect(mapStateToProps,mapDispatchToProps)(App)</span><br><span class="line">                // 使用connect组件的时候 我们的state add方法等等都到了props之上，就是通过这实现的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;使用react-redux 怎们能不了解原理，彻底了解原理和单纯的使用，应该不是一个级别的选手吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;redux原理实现&quot;&gt;&lt;a href=&quot;#redux原理实现&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="Redux理解" scheme="http://yoursite.com/tags/Redux%E7%90%86%E8%A7%A3/"/>
    
      <category term="Redux单向数据流" scheme="http://yoursite.com/tags/Redux%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="react-redux" scheme="http://yoursite.com/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="http://yoursite.com/2019/03/15/react-router/"/>
    <id>http://yoursite.com/2019/03/15/react-router/</id>
    <published>2019-03-15T14:37:19.000Z</published>
    <updated>2020-05-22T03:46:15.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用react怎么能少了router的使用</p></blockquote><h3 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h3><ul><li><h5 id="使用react-router-dom进行路由"><a href="#使用react-router-dom进行路由" class="headerlink" title="使用react-router-dom进行路由"></a>使用react-router-dom进行路由</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom --save</span><br></pre></td></tr></table></figure></li><li><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><blockquote><p>相比于vuejs的模式使用react略有不同 ，vue的模式是在配置里边设置是否使用history模式，而react则是通过使用不同的组件来使用history模式还是hash模式</p></blockquote><ul><li>HashRouter ：哈希模式</li><li>BrowserRouter：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123;BrowserRouter,HashRouter&#125; from &quot;react-router-dom&quot;</span><br><span class="line">//在外层再包一层HashRouter或者BrowserRouter</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;HashRouter&gt;</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;App /&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    &lt;/HashRouter&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//  app.js   </span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line">                &lt;Link to=&quot;/detail&quot;&gt;详情&lt;/Link&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;Route exact path=&quot;/&quot; component=&#123;Counter&#125;/&gt;  // exact 全部匹配根路径</span><br><span class="line">            &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">            &lt;Route path=&quot;/detail&quot; component=&#123;Detail&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function About() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;关于页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">function Detail() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;这是我们的详情页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h5><blockquote><p>和vue路由的使用一样 ，是使用：id的形式定义参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  使用 detail </span><br><span class="line">&lt;Route path=&quot;/detail/:id&quot; component=&#123;Detail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">function Detail(props) &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;p&gt;Detail:&#123;props.match.params.id&#125;&lt;/p&gt;  </span><br><span class="line">        &lt;h2&gt;这是我们的详情页面&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="Redirect-：跳转"><a href="#Redirect-：跳转" class="headerlink" title="Redirect ：跳转"></a>Redirect ：跳转</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to=&quot;/&quot;&gt; &lt;/Redirect&gt;  // 跳转到连接</span><br></pre></td></tr></table></figure></li></ul><ul><li><h5 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h5><p>redux + redux-sage + react-redux + react-router-dom = dva</p></li><li><h5 id="使用的react-router-dom"><a href="#使用的react-router-dom" class="headerlink" title="使用的react -router-dom"></a>使用的react -router-dom</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install react-router-dom --save</span><br></pre></td></tr></table></figure></li><li><h5 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h5><blockquote><p>使用模式相比于vuejs不同，vue里面是配置是否使用history模式，而react中是使用不同的组件进行区分</p></blockquote><p>HashRouter</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;使用react怎么能少了router的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;react-router&quot;&gt;&lt;a href=&quot;#react-router&quot; class=&quot;headerlink&quot; title=&quot;react-router
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="react-router" scheme="http://yoursite.com/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>彻底弄懂this指向问题</title>
    <link href="http://yoursite.com/2019/03/08/this/"/>
    <id>http://yoursite.com/2019/03/08/this/</id>
    <published>2019-03-08T03:23:23.000Z</published>
    <updated>2020-05-22T03:37:41.510Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>this问题几乎是老生常谈的问题了 ，其实真正问起来自己也是很模糊，今天趁着女神节的日子彻底弄懂这个问题，永绝后患。</p></blockquote><p>在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该活动对象的属性和值；将该函数体内显示声明的变量和函数，也添加为该活动的的属性（在刚进入该函数执行环境时，未赋值，所以值为undefined，这个是JS的提前声明机制）。</p><ol><li><h4 id="this四种场景逐一击破"><a href="#this四种场景逐一击破" class="headerlink" title="this四种场景逐一击破"></a>this四种场景逐一击破</h4><blockquote><p>打仗之前我先来两个锦囊</p><ul><li>函数被调用时（运行时）才会确定该函数内的this指向。因为在函数中this与arguments是两个特殊的变量，只有在函数被调用时才能获取到它们，而且搜索这两个变量时之后会在活动对象范围里面去搜</li><li>要确定函数中this的指向，必须先找到该函数被调用的位置。</li></ul></blockquote><ul><li><h5 id="第一种：作为对象的方法调用时，-this-指向该对象-javascript-void-0"><a href="#第一种：作为对象的方法调用时，-this-指向该对象-javascript-void-0" class="headerlink" title="第一种：作为对象的方法调用时， this 指向该对象(javascript:void(0);)"></a>第一种：作为对象的方法调用时， this 指向该对象(javascript:void(0);)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>===obj)  <span class="comment">// true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a: <span class="number">2</span>,</span><br><span class="line">        test</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> obj0 = &#123;</span><br><span class="line">        a: <span class="number">3</span>,</span><br><span class="line">        obj</span><br><span class="line">    &#125;</span><br><span class="line">obj0.obj.test() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>即使是这种串串烧的形式，结果也是一样的， <code>test()</code>中的this只对直属上司（直接调用者obj）负责。再来看一个综合点的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy()    <span class="comment">//  1</span></span><br></pre></td></tr></table></figure><p>你可能觉得换了名字其实还是obj.test(),但是却不是这样的 ，this永远指向的是最后调用它的对象　　　</p></li><li><h5 id="第二种：作为普通函数调用，this-总是指向全局对象-window"><a href="#第二种：作为普通函数调用，this-总是指向全局对象-window" class="headerlink" title="第二种：作为普通函数调用，this 总是指向全局对象 window"></a>第二种：作为普通函数调用，this 总是指向全局对象 window</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">// window</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">"globalName"</span> </span><br><span class="line"><span class="keyword">var</span> getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName());   <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure></li><li><h5 id="第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象"><a href="#第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象" class="headerlink" title="第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象"></a>第三种：构造器调用，当用new运算符调用函数是，该函数总是会返回一个对象，通常情况下，构造函数里的this就指向返回的这个对象</h5><blockquote><p>函数被作为构造器调用时有以下特点：</p><p>一个新的对象被创建出来；这个新的对象被传递给这个构造器作为this参数，也就是说这个新的对象是构造器函数的上下文；如果没有显性的return语句，这个新的对象会被隐式的return（就是悄咪咪的被return了），并成为这个构造器的值</p></blockquote><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a =a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> test(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.a)</span><br></pre></td></tr></table></figure><p>其中的new运算，先产生一个空对象，然后生成一个this指针，这个指针指向这个对象 ；运行构造函数时，这个对象传递导函数中作为this存在 ，就相当于“{}.a=a”  为这个对象添加了属性 ，然后再付给b</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"class"</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">"other"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// other</span></span><br></pre></td></tr></table></figure><p>上边咱们说如果没有显性的return语句，这个新的对象会被隐式的return，但是如果 构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我么之前期待的 this</p></li></ul></li><li><h5 id="第四种：Function-prototype-call-或-Function-prototype-apply和Function-prototype-bind调用-可以动态地改变出入函数的-this"><a href="#第四种：Function-prototype-call-或-Function-prototype-apply和Function-prototype-bind调用-可以动态地改变出入函数的-this" class="headerlink" title="第四种：Function.prototype.call 或 Function.prototype.apply和Function.prototype.bind调用, 可以动态地改变出入函数的 this"></a>第四种：Function.prototype.call 或 Function.prototype.apply和Function.prototype.bind调用, 可以动态地改变出入函数的 this</h5><blockquote><p>看到上边几种形式的，你可能回想我很讨厌这些乱七八遭的东西 这个调用那个调用的，我想自己指定，我的人生我做主 ，我的代码我做主 。当然可以没问题！！！</p></blockquote><ul><li><p>call和apply的作用一样，区别仅在于传入的参数形式不同而已。</p><blockquote><ul><li>apply接收两个参数，第一个参数指定了函数体内this对象的指向，第二个参数是一个带下标的集合，这个集合可以是数组，也可以是类数组，apply方法把这个集合中的元素作为参数传入被调用的函数。</li><li>call传入的参数不固定，跟apply相同的是，第一个参数也代表函数体内的this指向，从第二个参数开始往后，每个参数依次传入函数</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test =<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a,b,c])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window</span></span><br><span class="line">test.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// [1,2,3]</span></span><br><span class="line">test.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></li><li><p>call和apply改变this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"obj1"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"obj2"</span>&#125;;</span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">"window"</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">getName();   <span class="comment">// window</span></span><br><span class="line">getName.call(obj1); <span class="comment">//obj1</span></span><br><span class="line">getName.call(obj2)  <span class="comment">// obj2</span></span><br></pre></td></tr></table></figure></li><li><p>apply 和call的常用方法</p><ul><li><p>验证是否是数组（前提是toString()没有被重写）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让类数组具有数组的方法 ，比如arguments对象，获取到的文档节点等，并没有数组的那些方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].slice.apply(<span class="built_in">arguments</span>); </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply（argument）;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bind方法是事先把fn的this改变为我们要想要的结果，并且把对应的参数值准备好，以后要用到了，直接的执行即可，也就是说bind同样可以改变this的指向，但和apply、call不同就是不会马上的执行。</p></li><li><p><code>foo.bind({a:1})</code>却并不如此，执行该条语句仅仅得到了一个新的函数，新函数的this被绑定到了后面的第一个参数，亦即新的函数并没有执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=foo.call(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);     </span><br><span class="line"><span class="keyword">var</span> f2=foo.apply(&#123;<span class="attr">a</span>:<span class="number">2</span>&#125;);    </span><br><span class="line"><span class="keyword">var</span> f3=foo.bind(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1);        <span class="comment">//&#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f2);        <span class="comment">//&#123;a:2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f3);        <span class="comment">//function foo()&#123;</span></span><br><span class="line">                        <span class="comment">//  return this;</span></span><br><span class="line">                        <span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo());     <span class="comment">//window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(f3());      <span class="comment">//&#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>bind与apply和call最大的区别就是bind不会立即调用，其他 两个会立即调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempFn = fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">tempFn();</span><br></pre></td></tr></table></figure><p>第一行代码只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，但是此时并没有把fn这个函数给执行，执行bind会有一个返回值，这个返回值tempFn就是把fn的this改变后的那个结果。</p></li></ul></li></ul></li><li><h4 id="One-more"><a href="#One-more" class="headerlink" title="One more"></a>One more</h4><blockquote><p>还有一种大家别忘了Es6箭头函数，猜猜下边的 结果是几</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        a: <span class="number">2</span>,</span><br><span class="line">        test</span><br><span class="line">    &#125;</span><br><span class="line">obj.test() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>来，往上翻一下我们的第一个锦囊，“函数<strong>被调用时（即运行时）</strong>才会确定该函数内this的指向。”现在函数这两个字要加个词修饰一下，变成普通函数（非箭头函数）才能区别于箭头函数。箭头函数中的this在<strong>函数定义的时候</strong>就已经确定，它this指向的是它的外层作用域this的指向。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;this问题几乎是老生常谈的问题了 ，其实真正问起来自己也是很模糊，今天趁着女神节的日子彻底弄懂这个问题，永绝后患。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一个函数对象被调用的时候，会创建一个活动对象，首先将该函数的每个形参和实参，都添加为该
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="this指向" scheme="http://yoursite.com/tags/this%E6%8C%87%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Redux 、react-redux</title>
    <link href="http://yoursite.com/2019/02/21/react03/"/>
    <id>http://yoursite.com/2019/02/21/react03/</id>
    <published>2019-02-21T06:39:01.000Z</published>
    <updated>2019-03-06T06:44:08.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redux：如果你不知道是否需要-Redux，那就是不需要它。"><a href="#Redux：如果你不知道是否需要-Redux，那就是不需要它。" class="headerlink" title="Redux：如果你不知道是否需要 Redux，那就是不需要它。"></a>Redux：如果你不知道是否需要 Redux，那就是不需要它。</h3><blockquote><p>redux类似于vuejs的vuex，是react的数据管理中心。</p></blockquote><ul><li><h4 id="redux上手"><a href="#redux上手" class="headerlink" title="redux上手"></a>redux上手</h4><ul><li><p>首先我们需要安装redux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h5><blockquote><p>redux 中我们首先需要理解store，这个就是帮我们管理数据的政委，Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p></blockquote></li><li><h5 id="State"><a href="#State" class="headerlink" title="State"></a>State</h5><blockquote><p><code>Store</code>对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过<code>store.getState()</code>拿到</p></blockquote></li><li><h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><blockquote><p>State 的变化，会导致 View 的变化。但是，用户不能够直接改变State，只能操控View所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p><p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。</p></blockquote></li><li><h5 id="Dispatch"><a href="#Dispatch" class="headerlink" title="Dispatch"></a>Dispatch</h5><blockquote><p>功能就是我们View层要发出Action，必须要通过dispatch来进行触发</p></blockquote></li><li><h5 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h5><blockquote><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p></blockquote></li><li><h5 id="对redux通俗理解"><a href="#对redux通俗理解" class="headerlink" title="对redux通俗理解"></a>对redux通俗理解</h5><blockquote><p>就拿我们 <em> 东来说，发货都是从仓库发出，仓库就是redux的store，store中的state是存储数据也就是相当于仓库的货物，当我们从</em>东软件上下单 就是我们触发一个dispatch，然后 *东后台接到订单通知（action）仓库，相当我们下单买的货物的通知到达仓库（这个过程是我们和货物不能直接接触的，如果能接触货物早就偷光了哈哈哈），通知到仓库后，仓库里边有工人（reducer）来进行处理发货一系列的动作，发出货物之后，仓库货物的数据（state数据）就变了，货物到我们手里（view也就变了）</p></blockquote></li><li><h5 id="简单加减按钮的实现"><a href="#简单加减按钮的实现" class="headerlink" title="简单加减按钮的实现"></a>简单加减按钮的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  store.js</span><br><span class="line">import &#123;createStore&#125; from &apos;redux&apos;</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;   // 一定是返回新的state 而不是像vue直接修改 </span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const store = createStore(counterReducer);</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// App.js</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">           &#123;/*getState()返回当前的state树它与 store 的最后一个 reducer 返回值相同。*/&#125;</span><br><span class="line">                &lt;p&gt;&#123;store.getState()&#125;&lt;/p&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;store.dispatch(&#123;type:&quot;add&quot;&#125;)&#125; &gt;增加+&lt;/Button&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;store.dispatch(&#123;type:&quot;minus&quot;&#125;)&#125;&gt;减少-&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// index.js 中的render方法需要自己手动订阅监听 </span><br><span class="line">import store from &quot;./store&quot;;</span><br><span class="line">const render =()=&gt;&#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;App /&gt;,</span><br><span class="line">        document.getElementById(&apos;root&apos;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">render(); </span><br><span class="line">store.subscribe(render); // 每次 dispatch也就是state发生变化都需要render一次</span><br></pre></td></tr></table></figure></li><li><h5 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h5><blockquote><p>上边使用redux 每次都需要render麻烦且不优雅，使用react-redux更好，不用手动再去监听</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm insatll react-redux --save</span><br></pre></td></tr></table></figure><ul><li>Provider顶级组件，来提供数据，</li><li>connect高阶组件，提供数据和方法，把组件的状态映射到属性之上，然后只用props来进行调用</li><li>看看react-redux如何实现上边的功能，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// index.js  不需要手动再去监听 ，直接使用Provider进行包裹，自动监听数据了</span><br><span class="line">import store from &quot;./store&quot;;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Provider将数据传递进来数据任何地方想使用就用connect链接，这样App和redux就链接起来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.num&#125;&lt;/p&gt;  // dispatch 直接写对应的方法 </span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;this.props.add()&#125;&gt;增加+&lt;/Button&gt;</span><br><span class="line">                &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;this.props.minus()&#125;&gt;减少-&lt;/Button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mapStateToProps = (state) =&gt;&#123; // 它把状态映射到属性之上 所以上边使用this.props</span><br><span class="line">    return &#123;</span><br><span class="line">        num:state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const mapDispatchToProps = dispatch=&gt;&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        add:()=&gt;dispatch(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;dispatch(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App = connect(mapStateToProps,mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure></li><li><h5 id="react-redux中的connect-使用装饰器写法"><a href="#react-redux中的connect-使用装饰器写法" class="headerlink" title="react-redux中的connect 使用装饰器写法"></a>react-redux中的connect 使用装饰器写法</h5><blockquote><p>上边的connect 使用的高阶组件来声明需要的state里边的数据和方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//App.js</span><br><span class="line">@connect(</span><br><span class="line">    // Es6语法</span><br><span class="line">    //state=&gt;(&#123;num:state&#125;),  </span><br><span class="line">   // 读数据</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //除了ES6语法简写外 同步的dispatch可以进行简写</span><br><span class="line">    //写数据，要调用的dispatch 并且这些方法会传递到props中</span><br><span class="line">    // add:()=&gt;(&#123;type:&quot;add&quot;，step:2&#125;), 可以传递多个参数，但第一参数是修改数据的请求</span><br><span class="line">    &#123;</span><br><span class="line">        add:()=&gt;(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // dispatch=&gt;&#123;</span><br><span class="line">    //     return&#123;</span><br><span class="line">    //         add:()=&gt;dispatch(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">    //         minus:()=&gt;dispatch(&#123;type:&quot;minus&quot;&#125;)</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><h5 id="redux默认都是同步的操作，这样异步任务就需要使用-中间件-来完成"><a href="#redux默认都是同步的操作，这样异步任务就需要使用-中间件-来完成" class="headerlink" title="redux默认都是同步的操作，这样异步任务就需要使用 中间件 来完成"></a>redux默认都是同步的操作，这样异步任务就需要使用 <em>中间件</em> 来完成</h5><blockquote><p>为什么异步任务只能通过中间件来完成？</p><ol><li>Reducer ：纯函数，只能承担计算State的功能，不适合承担其他功能，理论上纯函数不能进行读写操作</li><li>View:与State一一对应，可以看做State的视觉层，也不适合承担其他功能</li><li>Action：存放数据的对象，即消息的载体，只能被别人操控，自己并不能进行任何操作</li><li>实际的reducer和action store都需要独立拆分文件</li></ol><p>所以要进行异步任务的dispatch请求，到达Reducer之前都需要经过中间件的处理。</p><p>我们试一下redux-logger和redux-thunk（异步操作） 两个中间件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos; // applyMiddleware 是使用中间件</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;</span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const store = createStore(counterReducer,applyMiddleware(logger,thunk));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@connect(</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        add:()=&gt;(&#123;type:&quot;add&quot;&#125;),</span><br><span class="line">        minus:()=&gt;(&#123;type:&quot;minus&quot;&#125;),</span><br><span class="line">        asyncAdd:()=&gt;dispatch=&gt;&#123;   // 延时加1。模拟异步任务</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">                dispatch(&#123;type:&quot;add&quot;&#125;)</span><br><span class="line">            &#125;,2000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><h5 id="多个reducer"><a href="#多个reducer" class="headerlink" title="多个reducer"></a>多个reducer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//store.js</span><br><span class="line">import &#123;createStore,applyMiddleware,combineReducers&#125; from &apos;redux&apos;</span><br><span class="line">const store = createStore(</span><br><span class="line">    combineReducers(&#123;counterReducer,numberReducer&#125;), // 假如我们还有一个numberReducer</span><br><span class="line">    applyMiddleware(logger,thunk)</span><br><span class="line">);</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure></li></ul><ul><li><h5 id="抽离Reducer-和Action"><a href="#抽离Reducer-和Action" class="headerlink" title="抽离Reducer 和Action"></a>抽离Reducer 和Action</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 新建 reducer.redux.js</span><br><span class="line">const counterReducer = (state=0,action)=&gt;&#123; // 设置默认值</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;add&apos;:</span><br><span class="line">            return state+1 ;</span><br><span class="line">        case &apos;minus&apos;:</span><br><span class="line">            return state-1 ;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const add= ()=&gt;(&#123;type:&quot;add&quot;&#125;);</span><br><span class="line">const minus=()=&gt;(&#123;type:&quot;minus&quot;&#125;);</span><br><span class="line">// 支持这种返回一个函数的写法，就是因为用了thunk</span><br><span class="line">const asyncAdd =()=&gt;dispatch=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        dispatch(&#123;type:&quot;add&quot;&#125;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;;</span><br><span class="line">export &#123;counterReducer,add,minus,asyncAdd&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;</span><br><span class="line">import * as serviceWorker from &apos;./serviceWorker&apos;;</span><br><span class="line">import &#123;createStore,applyMiddleware&#125; from &apos;redux&apos;</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">import &#123;counterReducer&#125; from &quot;./couter.redux&quot;;</span><br><span class="line">// 新建store 第一个参数reducer 第二个参数中间件</span><br><span class="line">const store = createStore(counterReducer,applyMiddleware(logger,thunk));</span><br><span class="line">//import store from &quot;./store&quot;;       store.js文件就没有什么用了</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    // 外层包一层Provider ，提供数据和组件间的数据传递一样</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//  App.js 直接引入reducer.redux.js的方法</span><br><span class="line">import &#123;add,minus,asyncAdd&#125; from &quot;./couter.redux&quot;;</span><br><span class="line">@connect(</span><br><span class="line">    state=&gt;&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            num:state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;add,minus,asyncAdd&#125;  //</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li></li></ul><p><img src="http://wx4.sinaimg.cn/mw690/005N9IKrly1fzmoangyh1j30hq0db0te.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redux：如果你不知道是否需要-Redux，那就是不需要它。&quot;&gt;&lt;a href=&quot;#Redux：如果你不知道是否需要-Redux，那就是不需要它。&quot; class=&quot;headerlink&quot; title=&quot;Redux：如果你不知道是否需要 Redux，那就是不需要它
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="Redux理解" scheme="http://yoursite.com/tags/Redux%E7%90%86%E8%A7%A3/"/>
    
      <category term="Redux单向数据流" scheme="http://yoursite.com/tags/Redux%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
      <category term="react-redux" scheme="http://yoursite.com/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>react组件化</title>
    <link href="http://yoursite.com/2019/02/12/react02/"/>
    <id>http://yoursite.com/2019/02/12/react02/</id>
    <published>2019-02-12T06:18:17.000Z</published>
    <updated>2019-03-06T06:25:18.911Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><h5 id="适用ant-design组件"><a href="#适用ant-design组件" class="headerlink" title="适用ant-design组件"></a>适用ant-design组件</h5><ul><li><p>起步安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br></pre></td></tr></table></figure></li><li><p>试用button组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Button from &apos;antd/lib/button&apos;</span><br><span class="line">import &apos;antd/dist/antd.css&apos;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;p&gt;hello world&lt;/p&gt;</span><br><span class="line">        &lt;Button type=&quot;primary&quot;&gt;Button&lt;/Button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p>配置按需加载：上边组件如果使用就需要全部引用antd.css ,引用别的组件还得import</p><blockquote><p>安装react-app-rewired取代react-script，可以对webpack的配置进行扩展，类似于vue.config.js，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-app-rewired@2.0.2-next.0 babel-plugin-import --save</span><br></pre></td></tr></table></figure><blockquote><p>更改package.json ,使用react-app-rewired</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"react-app-rewired test"</span>,</span><br><span class="line">    <span class="string">"eject"</span>: <span class="string">"react-app-rewired eject"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>新增config-overrids.js文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;injectBabelPlugin&#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config,env</span>) </span>&#123;</span><br><span class="line">    config =injectBabelPlugin(</span><br><span class="line">        [<span class="string">'import'</span>,&#123;<span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="string">'css'</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>参考官网使用 </p></li></ul><p>  [ant-desgin]: <a href="https://ant.design/docs/react/use-with-create-react-app-cn" target="_blank" rel="noopener">https://ant.design/docs/react/use-with-create-react-app-cn</a>    “ant-desgin”</p></li><li><h5 id="容器组件Vs展示组件"><a href="#容器组件Vs展示组件" class="headerlink" title="容器组件Vs展示组件"></a>容器组件Vs展示组件</h5><ul><li><p>基本原则：容器组件负责数据的获取，展示组件负责根据props显示信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class CommentList extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            comments:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;ul&gt;</span><br><span class="line">            &#123;this.props.comments.map(value =&gt; &#123;</span><br><span class="line">                return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123; // 模拟一下ajax数据获取</span><br><span class="line">       setTimeout(()=&gt;&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               comments:[&quot;哈哈&quot;,&quot;嘻嘻&quot;,&quot;嘿嘿&quot;]</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行分离，分离成容器组件和展示组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class CommentList extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            comments:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;CommentDetail comments=&#123;this.state.comments&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123; // 模拟一下ajax数据获取</span><br><span class="line">       setTimeout(()=&gt;&#123;</span><br><span class="line">           this.setState(&#123;</span><br><span class="line">               comments:[&quot;哈哈&quot;,&quot;嘻嘻&quot;,&quot;嘿嘿&quot;]</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 将上边的组件进行拆分 显示组件和动作组件也就是获取数据的组件</span><br><span class="line">class CommentDetail extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;ul&gt;</span><br><span class="line">            &#123;this.props.comments.map(value =&gt; &#123;</span><br><span class="line">                return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将上边显示组件 写成function的组件形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function CommentDetail(&#123;comments&#125;) &#123;</span><br><span class="line">    return &lt;ul&gt;</span><br><span class="line">        &#123;comments.map(value =&gt; &#123;</span><br><span class="line">            return &lt;li&gt;&#123;value&#125;&lt;/li&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行分离的优势：</p><ol><li>能清楚的看到如何工作和如何展示</li><li>重用性高</li><li>更高的可用性</li><li>更易于测试</li></ol></li></ul></li><li><h5 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h5><blockquote><p>定制了shouldComponentUpdate后的Component（进行浅比较）</p></blockquote><ul><li><p>形式 :直接使用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Comp extends PureComponent&#123; ....&#125;</span><br></pre></td></tr></table></figure></li><li><p>原理：定制shouldComponentUpdate生命周期，如果props没变化，阻止渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="comment">// 如果nextProps的内容等于this.porps,nextState的内容等于this.state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 : 如果不写shouldComponentUpdate这个生命周期的对比，则不管title变不变都重新渲染，但是使用了PureComponent或者加上下边生命周期 ，title不变就不会重新渲染，其PureComponent就是通过shouldComponentUpdate定制了一个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TitleDisplay extends Component&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState, nextContext) &#123;  // 通过对比</span><br><span class="line">        if (nextProps.title ===this.props.title)&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(&apos;title重新渲染了&apos;);</span><br><span class="line">        return &lt;h2&gt;</span><br><span class="line">            &#123;this.props.title&#125;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>缺点 ：只有class 形式的组件才能使用PureComponent这个功能</p></li><li><p>React16 新增一个新功能React.memo 来完美实现React组件，让函数式的组件也有PureComponent的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const TitleDisplay =React.memo(props=&gt;&#123;  // 函数式组件的</span><br><span class="line">    return &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ul><li><h5 id="HOC高阶组件：高阶组件一般都是以with开头进行命名"><a href="#HOC高阶组件：高阶组件一般都是以with开头进行命名" class="headerlink" title="HOC高阶组件：高阶组件一般都是以with开头进行命名"></a>HOC高阶组件：高阶组件一般都是以with开头进行命名</h5><blockquote><p>提高组件的复用率，首先想到就是抽离相同的逻辑，在React里就有了Hoc的概念，高阶组件也是一个组件，但是它返回另外一个组件。产生的新的组件可以对属性进行包装也可以重写部分生命周期</p></blockquote><ul><li><p>简单的高阶组件实现：高阶组件增加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import App from &apos;./App&apos;;</span><br><span class="line">import * as serviceWorker from &apos;./serviceWorker&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App  age=&quot;18&quot; /&gt;,  //这个age =18的属性后边的&#123;...props&#125;就可以接收到</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const withKaikeba = (Component)=&gt;&#123;</span><br><span class="line">    const newComp = props=&gt;&#123;    // 这个newComp是一个函数式的组件</span><br><span class="line">        console.log(props);</span><br><span class="line">        return &lt;Component &#123;...props&#125; name=&quot;开课吧高阶组件测试&quot;  /&gt;  </span><br><span class="line">// 将全部的props展开添加进属性中 比如在index.js中使用了App这个组件那么他的props就会传递进来</span><br><span class="line">    &#125;;</span><br><span class="line">    return newComp</span><br><span class="line">&#125;;</span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;XXX&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">App = withKaikeba(App);  //使用这个组件</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><p>简单的高阶组件实现：定制组件的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const withLog = Component=&gt;&#123;</span><br><span class="line">    class NewComponent extends Component&#123;</span><br><span class="line">        componentWillMount() &#123;</span><br><span class="line">            console.time(&apos;ComponentRender&apos;);</span><br><span class="line">            console.log(`组件$&#123;Component.name&#125;准备完毕了`)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;Component &#123;...this.props&#125; /&gt;  //这也是展开props属性</span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            console.timeEnd(&apos;ComponentRender&apos;)</span><br><span class="line">            console.log(`组件$&#123;Component.name&#125;渲染完毕了`)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return NewComponent;</span><br><span class="line">&#125;;</span><br><span class="line">App = withKaikeba(withLog(App)); //  高阶组价支持链式调用</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><h5 id="高阶组件的装饰器写法"><a href="#高阶组件的装饰器写法" class="headerlink" title="高阶组件的装饰器写法"></a>高阶组件的装饰器写法</h5><blockquote><p>上边的链式操作比较繁琐 ，逻辑比较绕，ES7中有一个优秀的语法——装饰器，专门处理这种问题</p></blockquote><ul><li><p>安装babel插件，用于解析Babel 5中的旧装饰器行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-transform-decorators-legacy</span><br></pre></td></tr></table></figure></li><li><p>在config-overrides.js进行扩展，才能编译 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;injectBabelPlugin&#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config,env</span>) </span>&#123;</span><br><span class="line">    config =injectBabelPlugin( <span class="comment">// 这是为能够按需加载的扩展</span></span><br><span class="line">        [<span class="string">'import'</span>,&#123;<span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="string">'css'</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    config=injectBabelPlugin(   <span class="comment">// 这是为支持装饰写法的扩展</span></span><br><span class="line">        [<span class="string">'@babel/plugin-proposal-decorators'</span>,&#123;<span class="attr">legacy</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">        config</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>之后直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@withKaikeba</span><br><span class="line">@withLog   </span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;XXX&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// App = withKaikeba(withLog(App));</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h5><ul><li><p>父组件向子组件通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component&#123;  //  class 组件</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &#123;this.props.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Child(props) &#123;    // 函数式组件</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &#123;props.name&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">class App extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Child name=&#123;&quot;向子组件传递值&quot;&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子组件向父组件通信 ——利用回调函数</p><blockquote><p>这块有必要说一下 ，在 cb={this.callback.bind(this)} ，由于cb是子组件传递过来的，msg当然应该绑定cb函数本身，不能绑定App组件的this也就是用箭头函数不能获取到传递的值</p><p>彻底理解可以参考</p><p>[彻底理解javascript中的this]: <a href="https://juejin.im/post/5c049e6de51d45471745eb98" target="_blank" rel="noopener">https://juejin.im/post/5c049e6de51d45471745eb98</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Child(props) &#123;    // 子组件</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &#123;props.name&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;Button type=&#123;&quot;primary&quot;&#125; onClick=&#123;()=&gt;props.cb(&apos;子组件传递的值&apos;)&#125;&gt;点击我传递&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">class App extends Component&#123;  //父组件</span><br><span class="line">    callback (msg) &#123;</span><br><span class="line">        console.log(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;Child name=&#123;&quot;向子组件传递值&quot;&#125;  cb=&#123;this.callback.bind(this)&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>跨级组件之间通信：使用 context 对象上下文(Context) 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性</p><h5 id="React-createContext：-const-Provider-Consumer-React-createContext-defaultValue"><a href="#React-createContext：-const-Provider-Consumer-React-createContext-defaultValue" class="headerlink" title="React.createContext：  const {Provider, Consumer} = React.createContext(defaultValue);"></a>React.createContext：  const {Provider, Consumer} = React.createContext(defaultValue);</h5><h5 id="Provider-提供者-lt-Provider-value-some-value-gt"><a href="#Provider-提供者-lt-Provider-value-some-value-gt" class="headerlink" title="Provider :提供者&lt;Provider value={/ some value /}&gt;"></a>Provider :提供者&lt;Provider value={/<em> some value </em>/}&gt;</h5><h5 id="Consumer-订阅者-lt-Consumer-gt-value-gt-…-lt-Consumer-gt"><a href="#Consumer-订阅者-lt-Consumer-gt-value-gt-…-lt-Consumer-gt" class="headerlink" title="Consumer:订阅者 &lt; Consumer&gt; {value =&gt; {…}} &lt; /Consumer&gt;"></a>Consumer:订阅者 &lt; Consumer&gt; {value =&gt; {…}} &lt; /Consumer&gt;</h5><blockquote><p>vuejs中可以使用privide&amp;inject模式来进行组件之间的通信，这个模式的来源–context</p><p>react中也有两个角色，Provider和Consumer，Provider在外层组件，内部需要数据，就使用Consumer来读取</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123;store&#125; from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">const AppContext = React.createContext();  //新建上下文 ，Provider和Consumer可以拆分出去</span><br><span class="line">const &#123;Provider,Consumer&#125; =AppContext;  </span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line">    render() &#123;  //  下边使用Consumer来进行接收</span><br><span class="line">        return &lt;Consumer&gt;   </span><br><span class="line">            &#123;</span><br><span class="line">                //  下边这块其实就是一个函数式的组件</span><br><span class="line">                store=&gt;&#123;</span><br><span class="line">                    return &lt;Button</span><br><span class="line">                        type=&#123;&quot;primary&quot;&#125;</span><br><span class="line">                        onClick=&#123;()=&gt;store.sayHi()&#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                        &#123;store.name&#125;</span><br><span class="line">                        &lt;/Button&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/Consumer&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class App  extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        // 直接进行嵌套 ,value是固定写法</span><br><span class="line">        return &lt;Provider value=&#123;store&#125;&gt;</span><br><span class="line">             &lt;div&gt;</span><br><span class="line">                 &lt;h1&gt;哈喽啊！小年依旧学习React&lt;/h1&gt;</span><br><span class="line">                 &lt;Demo/&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><h5 id="其他多数据的组件通信就可以使用Redux进行"><a href="#其他多数据的组件通信就可以使用Redux进行" class="headerlink" title="其他多数据的组件通信就可以使用Redux进行"></a>其他多数据的组件通信就可以使用Redux进行</h5></li><li><h5 id="实现createContext-？-createContext就是一个高阶组件，结合用法去理解"><a href="#实现createContext-？-createContext就是一个高阶组件，结合用法去理解" class="headerlink" title="实现createContext ？ createContext就是一个高阶组件，结合用法去理解"></a>实现createContext ？ createContext就是一个高阶组件，结合用法去理解</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//  createContext初始化 简单的实现原理</span><br><span class="line">import React ,&#123;Component&#125; from &apos;react&apos;</span><br><span class="line">function createContext() &#123;</span><br><span class="line">    let instance = &#123;   // 1. 先声明一个对象初始化value</span><br><span class="line">        value:null</span><br><span class="line">    &#125;;</span><br><span class="line">    class Provider extends Component&#123;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">            instance.vlaue = props.value   // 2. 赋给instance的value</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return this.props.children     // 3.这块类似于vuejs的&lt;slot&gt;&lt;/slot&gt;  扩展</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Consumer extends Component&#123;</span><br><span class="line">        constructor(props)&#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state=&#123;</span><br><span class="line">                value:instance.vlaue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return this.props.children(this.state.value)    // 4.这块就是一个函数，将instance.value 传递进去</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;Provider,Consumer&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><h3 id="React未来"><a href="#React未来" class="headerlink" title="React未来"></a>React未来</h3><ul><li>Fiber：异步渲染 ,底层在实现虚拟Dom中实现了类似CPU调度的功能，</li><li>Suspense ：用同步的代码实现异步的操作</li><li>Hooks:开发者可以完全抛弃class ，拥抱函数式编程</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;适用ant-design组件&quot;&gt;&lt;a href=&quot;#适用ant-design组件&quot; class
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="react组件化" scheme="http://yoursite.com/tags/react%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="React开发模式" scheme="http://yoursite.com/tags/React%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="高阶组件" scheme="http://yoursite.com/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React 入门</title>
    <link href="http://yoursite.com/2019/02/01/react01/"/>
    <id>http://yoursite.com/2019/02/01/react01/</id>
    <published>2019-02-01T05:44:05.000Z</published>
    <updated>2019-03-06T06:24:26.738Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h3><ul><li><p>安装官方脚手架 ，后边的脚手架更加好用，但由于官方推荐开始先试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure></li><li><p>初始化—创建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app 项目名</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="JSX-看起来是js和html的混合体，但实际上html也是由js实现"><a href="#JSX-看起来是js和html的混合体，但实际上html也是由js实现" class="headerlink" title="JSX:看起来是js和html的混合体，但实际上html也是由js实现"></a>JSX:看起来是js和html的混合体，但实际上html也是由js实现</h3><blockquote><p>React设计之初，就是使用JSX来描述UI，react只做逻辑层，reactDom去做渲染实际的dom，如果换到移动端，就用别的渲染库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        Hello world！</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,      //</span><br><span class="line">    document.getElementById(&apos;root&apos;)  //这里的root元素是在index.html中的dom元素</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fz7n8o6rj0j30fv09umxb.jpg" alt></p><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fz7n8uffgzj30ft0alglt.jpg" alt></p></li><li><h3 id="组件定义"><a href="#组件定义" class="headerlink" title="组件定义"></a>组件定义</h3><blockquote><p>在上边的代码中我们也可以看到class类在react中就是组件 ，然后使用对应的标签<app></app></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import App from &apos;./App&apos;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        Hello world！</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li><li><h3 id="state和setState"><a href="#state和setState" class="headerlink" title="state和setState"></a>state和setState</h3><ul><li><p>使用{ }来渲染变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const name = &apos;你好啊&apos;;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123;name&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是如果数据需要修改，并且同时页面响应变化，就需要将数据放在state中，并且使用setState来修改数据，super（props）是调用父级的construtor，来初始化各种生命周期啊，this指向等等数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">          name:&apos;开课吧&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123; this.state.name &#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用setState来修改数据 ,使用this.state每次传的是一个<strong>新对象</strong>，这样好处就是可以做时间旅行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">          name:&apos;开课吧&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">          this.setState(&#123;</span><br><span class="line">              name:&apos;开课吧真不错&apos;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123; </span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;p&gt;&#123; this.state.name &#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="属性传递-props"><a href="#属性传递-props" class="headerlink" title="属性传递 props"></a>属性传递 props</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;App title=&quot;今天开始React&quot; /&gt;, //使用的时候</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">       return (</span><br><span class="line">           &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">               &lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="条件渲染和循环"><a href="#条件渲染和循环" class="headerlink" title="条件渲染和循环"></a>条件渲染和循环</h3><ul><li><p>条件渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            showTitle:true</span><br><span class="line">        &#125;;</span><br><span class="line">        &#125;,2000)</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                showTitle: false  // 2秒之后改变成隐藏 </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;          </span><br><span class="line">                &#123;this.state.showTitle?&lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;:null&#125;</span><br><span class="line">                &lt;!--其实这相当于v-if和v-else null那块是else的内容 --&gt; </span><br><span class="line">                &#123;this.state.showTitle&amp;&amp;&lt;p&gt;&#123;this.props.title&#125;&lt;/p&gt;&#125;</span><br><span class="line">                 &lt;!--直接这样写就是v-if功能 --&gt; </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">    goodlist:[</span><br><span class="line">        &#123;text:&apos;百万年薪架构师&apos;,price:100,id:1&#125;,</span><br><span class="line">        &#123;text:&apos;web全栈架构师&apos;,price:100,id:2&#125;,</span><br><span class="line">        &#123;text:&apos;Python&apos;,price:100,id:3&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">render() &#123;</span><br><span class="line">       return (</span><br><span class="line">           &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">               &lt;ul&gt;</span><br><span class="line">                   &#123;this.state.goodlist.map(good=&gt;&#123;</span><br><span class="line">                       return &lt;li key=&#123;good.id&#125;&gt;</span><br><span class="line">                           &lt;span&gt;&#123;good.text&#125;&lt;/span&gt;</span><br><span class="line">                           &lt;span&gt;￥&#123;good.price&#125;&lt;/span&gt;</span><br><span class="line">                       &lt;/li&gt;</span><br><span class="line">                   &#125;)&#125;</span><br><span class="line">               &lt;/ul&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="数据的管理和绑定"><a href="#数据的管理和绑定" class="headerlink" title="数据的管理和绑定"></a>数据的管理和绑定</h3><ul><li><p>数据的绑定  </p><ul><li>在react中由于强制的单向数据流，数据绑定的input不能像vue中的那样双向数据修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(e)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            add:e.target.value //这样就是实现了input的双向绑定</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#123;/*由于value绑定了this.state react是强制的单项数据流，那么value就会被this.state数据监控，现在state的值不变value就不变*/&#125;</span><br><span class="line">&#123;/*当我们进行输入的时候会触发一个onchang事件 ，我们利用这个实现我们的双向绑定*/&#125;</span><br><span class="line">&#123;/*利用e.target.value 获得我们输入的值，然后进行对state中数据的修改,然后我们的input中value也会自动进行修改*/&#125;</span><br></pre></td></tr></table></figure><ul><li>实现将input中的数据，添加到上面state的goodlist数据中去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;this.handleAdd()&#125;&#125;&gt;添加&lt;/button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleAdd()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        goodlist:[...this.state.goodlist,&#123;text:this.state.add,price:20&#125;],</span><br><span class="line">        add:&apos;&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件绑定 </p><blockquote><p>上边的实现将input数据添加到goodlist中去的时候，那个onChange写的太繁琐对不对，我们想到把函数拿出去写，但是会<strong>报错</strong>，是因为this指向问题，因为当使用onChange={this.handleChange}这种写法时，把handleChange这个函数当成参数传递给了当前组件，组件再去调用自己的内部的this，取向值已经变了，因为这个函数的是给别人用的（谁用的这个函数，this指向谁）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; onChange=&#123;this.handleChange&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; handleChange(e)&#123;</span><br><span class="line">&gt;  this.setState(&#123;</span><br><span class="line">&gt;      add:e.target.value </span><br><span class="line">&gt;  &#125;)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决上边的问题有三种方案</strong></p><ul><li><p>在constructor(props) {}的时候 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);  </span><br><span class="line"><span class="comment">// 这个函数任何时候执行，this都是我们当前组件的this</span></span><br></pre></td></tr></table></figure></li><li><p>利用箭头函数，解决this指向问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(e)=&gt;this.handleChange(e)&#125;  </span><br><span class="line">    /&gt;</span><br><span class="line">//但是如果传参的话 onClick=&#123;this.handleClick(i)&#125;直接这样写就直接执行了</span><br><span class="line">//onClick = &#123;this.handleClick&#125;</span><br><span class="line">//但是 这个函数 需要携带一个 i 的参数过去</span><br><span class="line">//所以 就要用一个匿名函数把i 带过去啊。。</span><br><span class="line">//onClick = &#123;()=&gt; this.handleClick(i)&#125;</span><br><span class="line">//这样闭包 让 i 对 renderSquare 的i 保持引用</span><br><span class="line"></span><br><span class="line">//-----传参数的函数需要两次箭头函数</span><br></pre></td></tr></table></figure></li><li><p>直接在onChange时候使用bind(this)，并不推荐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot;</span><br><span class="line">    value=&#123;this.state.add&#125;</span><br><span class="line">    onChange=&#123;(this.handleChange.bind(this)&#125;  //和我们上边你的添加按钮一样</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义handleChang的时候直接使用箭头函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleChange=(e)=&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        add:e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="函数组件-："><a href="#函数组件-：" class="headerlink" title="函数组件 ："></a>函数组件 ：</h4><blockquote><p>如果一个组件只根据props进行渲染，没有内部的state，我们完全可以使用函数式组件的形式来实现</p><p>其实认真观察  函数式组件和class 组件的 props 是有区别的函数式props是通过参数传递就没有this</p><p>class的组件是有this的一般都是this.props</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 函数式组件</span><br><span class="line">function Title(props) &#123;   // React的函数式组件props就是传递的值props.title也能直接取到</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;hr/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Title title=&#123;this.props.title&#125; /&gt;  //使用的时候和组件一样</span><br></pre></td></tr></table></figure></li><li><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><blockquote><p>通过props进行通信</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">function Totol(&#123;cart&#125;)&#123;</span><br><span class="line">    return &lt;span&gt;</span><br><span class="line">        总价:&#123;cart.reduce((sum,a)=&gt;&#123;</span><br><span class="line">            return sum += a.price*a.count</span><br><span class="line">    &#125;,0)&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&#125;</span><br><span class="line">class Cart extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;商品名&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;价格&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;数量&lt;/th&gt;</span><br><span class="line">                    &lt;th&gt;总价&lt;/th&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &#123;this.props.data.map(good=&gt;&#123;</span><br><span class="line">                        return&lt;tr key=&#123;good.text&#125;&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.text&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.price&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.count&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;&#123;good.count*good.price&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                    &#125;)&#125;</span><br><span class="line">                    &#123;/*使用组件做一个总价*/&#125;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td colSpan=&quot;4&quot; align=&quot;right&quot;&gt;</span><br><span class="line">                            &lt;Totol cart=&#123;this.props.data&#125; /&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Cart</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AddCart(good)&#123;</span><br><span class="line">    let cartIndex;</span><br><span class="line">    const cartGood = this.state.cart.find((value,index) =&gt; &#123;</span><br><span class="line">        if (good.text === value.text) &#123;</span><br><span class="line">            cartIndex = index;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (cartGood)&#123;</span><br><span class="line">        // 我们要知道我们找到的是第几个,因为我们不能直接修改</span><br><span class="line">        let newCart = [...this.state.cart];</span><br><span class="line">        newCart[cartIndex].count+=1;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            cart:newCart</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            cart:[...this.state.cart,&#123;</span><br><span class="line">                text:good.text,</span><br><span class="line">                price:good.price,</span><br><span class="line">                count:1</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;Cart data=&#123;this.state.cart&#125;/&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><h4 id="利用react的每一次都需要setState使用一个新的对象-实现类似时间旅行功能"><a href="#利用react的每一次都需要setState使用一个新的对象-实现类似时间旅行功能" class="headerlink" title="利用react的每一次都需要setState使用一个新的对象{实现类似时间旅行功能"></a>利用react的每一次都需要setState使用一个新的对象{实现类似时间旅行功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//新加一个state的cartHistory:[]来记录</span><br><span class="line">在每次操作都将操作的数据记录，然后点击返回对应步骤的cartHistory</span><br><span class="line">this.setState(&#123;</span><br><span class="line">cartHistory:[...this.state.cartHistory,this.state.cart]</span><br><span class="line">&#125;)</span><br><span class="line">resetCart(i)&#123;  //点击的事件处理</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">    cart:this.state.cartHistory[i]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><blockquote><p>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</p><p>在React中，render执行的结果得到的并不是真正的DOM节点，而仅仅是JavaScript对象，称之为虚拟DOM。</p><p>虚拟DOM具有批处理和高效的Diff算法，可以无需担心性能问题而随时“刷新”整个页面，因为虚拟DOM可以确保只对界面上真正变化的部分进行实际的DOM操作。</p></blockquote><ul><li>传统APP：</li></ul><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fzc4p746pqj30da021jr7.jpg" alt></p><ul><li>React App:</li></ul><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fzc4p9uo4bj30db025glg.jpg" alt></p><ul><li>innerHTML：render html字符串 + 重新创建所有的DOM元素</li><li>虚拟DOM：render 虚拟DOM + diff + 更新必要的DOM元素</li><li>原理：React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，React会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</li></ul></li><li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote><p>React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁</p></blockquote><p><img src="http://wx1.sinaimg.cn/mw690/005N9IKrly1fzc5tbnw92j30kk0p0dhq.jpg" alt></p><ul><li><p>初始化</p><ol><li><p>getDefaultProps()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置默认的props，也可以用defaultProps设置组件的默认属性</span><br><span class="line">这个方法只会调用一次，该组件类的所有后续应用，getDefaultPops 将不会再被调用，其返回的对象可以用于设置默认的 props(properties的缩写) 值。</span><br></pre></td></tr></table></figure></li><li><p>getInitialState()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个方法的调用有且只有一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props。每一个React组件都有自己的 state，其与 props 的区别在于 state只存在组件的内部，props 在所有实例中共享。</span><br><span class="line">getInitialState 和 getDefaultPops 的调用是有区别的，getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用，而 getInitialState 是对于每个组件实例来讲都会调用，并且只调一次。</span><br></pre></td></tr></table></figure></li><li><p>componentWillMount()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该方法在  首次(也就是只调用一次) 渲染之前调用，也是再 render 方法调用之前修改 state 的最后一次机会。</span><br></pre></td></tr></table></figure></li><li><p>render()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点：</span><br><span class="line">1.只能通过 this.props 和 this.state 访问数据（不能修改）</span><br><span class="line">2.可以返回 null,false 或者任何React组件</span><br><span class="line">3.只能出现一个顶级组件，不能返回一组元素</span><br><span class="line">4.不能改变组件的状态</span><br><span class="line">5.不能修改DOM的输出</span><br><span class="line">render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。react之所以效率高，就是这个原因。</span><br></pre></td></tr></table></figure></li><li><p>componentDidMount()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件渲染之后调用，只调用一次</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><pre><code>- 更新 ：  &gt; 此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用  1. componentWillReceiveProps(nextProps)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。</span><br></pre></td></tr></table></figure>  2. shouldComponentUpdate(nextProps, nextState)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候</span><br><span class="line">该方法是非必须的，并且大多数情况下没有在开发中使用。</span><br></pre></td></tr></table></figure>  3. componentWillUpdata(nextProps, nextState)     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个方法和 componentWillMount 类似，在组件接收到了新的 props 或者 state 即将进行重新渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。</span><br></pre></td></tr></table></figure>  4. render()     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新之后再次进行组件渲染</span><br></pre></td></tr></table></figure>  5. componentDidUpdate()     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个方法和 componentDidMount 类似，在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM</span><br></pre></td></tr></table></figure>- 销毁  1. componentWillUnmount()     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行，完成所有的清理和销毁工作，在 componentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;React入门&quot;&gt;&lt;a href=&quot;#React入门&quot; class=&quot;headerlink&quot; title=&quot;React入门&quot;&gt;&lt;/a&gt;React入门&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装官方脚手架 ，后边的脚手架更加好用，但由于官方推荐开始先试试
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React入门" scheme="http://yoursite.com/tags/React%E5%85%A5%E9%97%A8/"/>
    
      <category term="create-react-app" scheme="http://yoursite.com/tags/create-react-app/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Vue-router单页面</title>
    <link href="http://yoursite.com/2019/01/18/vue03/"/>
    <id>http://yoursite.com/2019/01/18/vue03/</id>
    <published>2019-01-18T02:48:53.000Z</published>
    <updated>2019-01-23T03:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vue路由绝对是vue中的一大块，基本上路由都有两大模式history模式和hash模式，而我们常用的则是history模式</p></blockquote><ol><li><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h5 id="默认的路由使用的hash模式-http-localhost-8080-page1"><a href="#默认的路由使用的hash模式-http-localhost-8080-page1" class="headerlink" title="默认的路由使用的hash模式 (http://localhost:8080/#/page1)"></a>默认的路由使用的hash模式 (<a href="http://localhost:8080/#/page1" target="_blank" rel="noopener">http://localhost:8080/#/page1</a>)</h5><ul><li><p>起步 ：安装vue-router模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure></li><li><p>新建router.js进行路由配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> Page1 <span class="keyword">from</span> <span class="string">'./components/Page1'</span>;</span><br><span class="line"><span class="keyword">import</span> Page2 <span class="keyword">from</span>  <span class="string">'./components/Page2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在main.js中进行使用插件，赋予vue控制路由的能力</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line">Vue.use(VueRouter); <span class="comment">//将this.$router 挂载到原型链上，使得vue具有处理路由的能力</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></li><li><p>在App.vue中使用 ，使用router-view 标签进行占位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--路由占位符--&gt;</span><br><span class="line">&lt;router-view&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>按钮导航，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/page1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"page1"</span>&gt;页面<span class="number">1</span>&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link to="/</span>page2<span class="string">" class="</span>page2<span class="string">"&gt;页面2&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="history模式："><a href="#history模式：" class="headerlink" title="history模式："></a>history模式：</h5><blockquote><p>默认是hash 模式的路由，url 使用#后面定位路由，对SEO不利，设置history模式可以使用普通的url</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接在routes.js中配置 mode：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h5><blockquote><p>在配置路由的使用：id占位符，和angualar类似  ，一些参数可以使用this.$route.XX进行获取</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">component</span>:Page3&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ---------进行获取</span></span><br><span class="line">computed:&#123;</span><br><span class="line">    name()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$route.params.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种获取路由参数比较麻烦，更优雅的方式获取，使用属性传递的方式进行获取</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">props</span>:<span class="literal">true</span>,<span class="attr">component</span>:Page3&#125;, <span class="comment">// 使用props 表示属性传递</span></span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//-------在进行或去就比较优雅 ，直接使用props接收</span></span><br><span class="line">   props:[<span class="string">'id'</span>],</span><br></pre></td></tr></table></figure><h5 id="子路由嵌套"><a href="#子路由嵌套" class="headerlink" title="子路由嵌套"></a>子路由嵌套</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode:<span class="string">"history"</span>,</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:Login&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/dashboard'</span>,</span><br><span class="line">            component:DashBoard,</span><br><span class="line">            children:[      <span class="comment">//---------子路由的嵌套</span></span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">                &#123;<span class="attr">path</span>:<span class="string">'/page3/:id'</span>,<span class="attr">props</span>:<span class="literal">true</span>,<span class="attr">component</span>:Page3&#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//-------------第一层使用</span></span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;h1&gt;<span class="number">2019</span>年，新的一天你好！！！&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;hr&gt;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/路由占位符</span></span><br><span class="line"><span class="regexp">    &lt;router-view&gt;&lt;/</span>router-view&gt;   &lt;!--第一层，包含login和dashboard两个路由--&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/------------dashboard里边的嵌套</span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="navbar"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;router-link to="/</span>page1<span class="string">" class="</span>page1<span class="string">"&gt;页面1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">            &lt;router-link to="</span>/page2<span class="string">" class="</span>page2<span class="string">"&gt;页面2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">            &lt;router-link to="</span>/page3/vuejs<span class="string">" class="</span>page2<span class="string">"&gt;Vue&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;hr&gt;</span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt; &lt;!--这是第二层，子路由嵌套在这里--&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure><h5 id="路由的重定向：使用redirect进行重定向"><a href="#路由的重定向：使用redirect进行重定向" class="headerlink" title="路由的重定向：使用redirect进行重定向"></a>路由的重定向：使用redirect进行重定向</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/'</span>,<span class="attr">redirect</span>:<span class="string">'/login'</span>&#125;,</span><br></pre></td></tr></table></figure><h5 id="路由守卫-：（在路由跳转之前或者路由跳转之后hooks）钩子"><a href="#路由守卫-：（在路由跳转之前或者路由跳转之后hooks）钩子" class="headerlink" title="路由守卫 ：（在路由跳转之前或者路由跳转之后hooks）钩子"></a>路由守卫 ：（在路由跳转之前或者路由跳转之后hooks）<strong>钩子</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">let</span> routes = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;）</span><br><span class="line">routes.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeEach'</span>,to); <span class="comment">//  to 是和那个路由里的所有东西</span></span><br><span class="line">    <span class="keyword">if</span> (to.path!==<span class="string">'/login'</span>)&#123;   <span class="comment">//逻辑是如果不是login页面则随便跳转 ，但是如果是login页面则需要两秒之后跳转</span></span><br><span class="line">        next()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">routes.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'afterEach'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routes</span><br></pre></td></tr></table></figure><h5 id="组件内部生命周期：上边的路由守卫是全局的-，我们组件内部也有一些内部生命周期"><a href="#组件内部生命周期：上边的路由守卫是全局的-，我们组件内部也有一些内部生命周期" class="headerlink" title="组件内部生命周期：上边的路由守卫是全局的  ，我们组件内部也有一些内部生命周期"></a>组件内部生命周期：上边的路由守卫是全局的  ，我们组件内部也有一些内部生命周期</h5><blockquote><p>需要一些组件内部的守卫 ，有两种方法  </p></blockquote><ul><li><p>在routes配置path的时候进行，<strong>不推荐</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page1'</span>,<span class="attr">component</span>:Page1&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>:<span class="string">'/page2'</span>,<span class="attr">component</span>:Page2&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>再组件内部 执行  <strong>推荐</strong></p><blockquote><p>注意顺序是  ，路由守卫beforeEach -&gt;beforeRouteEnter -&gt;beforeRouteLeave-&gt;afterEach的顺序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        beforeRouteEnter(to,from,next)&#123;</span><br><span class="line">          console.log(&apos;page3进来了&apos;);</span><br><span class="line">          next();</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">          console.log(&apos;page3准备退出了&apos;);</span><br><span class="line">          if (window.confirm(&apos;您真的要退出么？&apos;))&#123;</span><br><span class="line">              next();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>当路由组件没有变但是路由的参数变了时，比如 由  page3/vuejs变为 page3/react </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate(to,form,next)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'page3路由，但是参数变化了'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h5 id="整个路由的操作逻辑-，我理解是执行顺序"><a href="#整个路由的操作逻辑-，我理解是执行顺序" class="headerlink" title="整个路由的操作逻辑 ，我理解是执行顺序"></a>整个路由的操作逻辑 ，我理解是执行顺序</h5><ol><li>导航被触发</li><li>调用全局的beforeEach守卫</li><li>在重用的组件里调用beforeRouteUpdate守卫</li><li>在路由配置里边调用beforeEnter    这个和组件里的beforeRouteEnter类似</li><li>在被激活的组件⾥调⽤ beforeRouteEnter。</li><li>调⽤全局的 beforeResolve 守卫 (2.5+)。  这个比全局的beforeEach守卫晚一点点</li><li>导航被确认。</li><li>组件的beforeRouteLeave</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li></ol><h5 id="异步组件-，懒加载"><a href="#异步组件-，懒加载" class="headerlink" title="异步组件 ，懒加载"></a>异步组件 ，懒加载</h5><blockquote><p>路由懒加载vue中配合webpack非常简单 ,在需要懒加载的组件的路由配置中直接import（）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如让login组件实现懒加载</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">'/login'</span>,<span class="attr">component</span>:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">import</span>(<span class="string">'./components/Login'</span>)&#125;</span><br><span class="line"><span class="comment">//&#123;path:'/login',component:Login&#125;,</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;vue路由绝对是vue中的一大块，基本上路由都有两大模式history模式和hash模式，而我们常用的则是history模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="vue路由" scheme="http://yoursite.com/tags/vue%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Vuex使用及理解</title>
    <link href="http://yoursite.com/2019/01/14/vue04/"/>
    <id>http://yoursite.com/2019/01/14/vue04/</id>
    <published>2019-01-14T02:56:28.000Z</published>
    <updated>2019-01-23T03:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vuex数据管理"><a href="#Vuex数据管理" class="headerlink" title="Vuex数据管理"></a>Vuex数据管理</h3><blockquote><p>如何理解数据管理?</p><p>这个Vuex就是vue中的数据管理中心 ，相信看过亮剑的大家都知道 ，本来独立团老李管理独立团那是想喝酒喝酒想吃肉吃肉 ，想打仗打仗，但这样的独立团就是比较混乱啊，就是和我们的vue一样 如果数据，都在data里边随取随用，那也一样很混乱，所以我们就需要一个单独的数据中心。也就是赵刚赵政委来了，管独立团的生活了，政委管生活，团长管打仗 ，这样分工也就比较明确。Vuex就是我们的政委。  来吧我们的资料数据管理，任何的管理都不能直接操作，而通过Vuex来统一的调配和转发。</p></blockquote><p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。– 摘自《 Redux 中文文档 》</p><ol><li><h4 id="起步安装"><a href="#起步安装" class="headerlink" title="起步安装"></a>起步安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure></li><li><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li>store : 我们的数据管理中心 ，任何的操作都需要通过store  ，也就是我们的赵政委</li><li>state ：就是我们存储数据的地方</li><li>mutations ： 我们修改数据都需要通过 mutations 来进行操作</li></ul></li><li><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>新建store.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">Vue.use(Vuex);  <span class="comment">// 虽然和我们的router使用类似但我们不能在main.js中use</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>main.js中使用  将我们的store.js 挂载到我们的原型链之上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.use(VueRouter); <span class="comment">//将this.$router 挂载到原型链上，使得vue具有处理路由的能力</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store, <span class="comment">// 相当于把我们的store挂载到原型链之上</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure></li><li><p>数据使用   在.vue中使用this.$store来获取  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Page2"</span>,</span><br><span class="line">        computed:&#123;</span><br><span class="line">            count()&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="当我们在对state的数据进行修改的时候-你一定想这样-—直接修改"><a href="#当我们在对state的数据进行修改的时候-你一定想这样-—直接修改" class="headerlink" title="当我们在对state的数据进行修改的时候,你一定想这样 —直接修改"></a>当我们在对state的数据进行修改的时候,你一定想这样 —直接修改</h4><blockquote><p>仔细想想这样修改的话不是又回到了我们原来那种 更改state 其他组件也相应，最后你想找到问题来源或者添加新功能时变得困难那种状态了么？</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Page2"</span>,</span><br><span class="line">        created()&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.$store.state.count++</span><br><span class="line">            &#125;,<span class="number">2000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>—解决使用vuex的严格模式使用，使用 mutations修改数据 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------store.js中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    strict:<span class="literal">true</span>  <span class="comment">//使用严格模式</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><h4 id="使用mutations修改数据"><a href="#使用mutations修改数据" class="headerlink" title="使用mutations修改数据"></a>使用mutations修改数据</h4><p>在vuex中，关于修改state的方式，需要commit提交mutation。官方文档中有这么一句话：</p><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      increment(state)&#123;</span><br><span class="line">          state.count++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    strict:true  //使用严格模式</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于我们现在不能直接去获取物资了，得去政委那等级一下子才能获取物资 </span></span><br><span class="line">created()&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="comment">// this.$store.state.count++</span></span><br><span class="line">         <span class="keyword">this</span>.$store.commit(<span class="string">'increment'</span>)          </span><br><span class="line">     &#125;,<span class="number">2000</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="上边其实是两种修改state的方式"><a href="#上边其实是两种修改state的方式" class="headerlink" title="上边其实是两种修改state的方式"></a>上边其实是两种修改state的方式</h4><ul><li><p>在vuex官方文档上看到了关于严格模式的描述</p><blockquote><p>开启严格模式，仅需在创建 store 的时候传入 strict: true；<br>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p></blockquote></li><li><p>于是，将vuex设置成了严格模式。 </p><p>直接修改state发现控制台确实是报出了错误，但是state修改成功，并且依然是响应式的。错误提示：</p><blockquote><p>Do not mutate vuex store state outside mutation handlers.</p></blockquote><ul><li>通过commit 提交 mutation 的方式来修改 state 时，vue的调试工具能够记录每一次state的变化，这样方便调试。但是如果是直接修改state，则没有这个记录。</li></ul></li><li><p>分析源码</p><ul><li><p>mutation通过commit修改state ，可以看到通过this._withCommit函数处理</p><p><img src="http://wx1.sinaimg.cn/mw690/005N9IKrly1fyw3yto2u7j30x40l5di5.jpg" alt></p></li><li><p>看_ withCommit   ，_ withCommit函数的参数是fn  也就是我们上边的更改state的函数，在执行fn之前 ，将this.comiting =true ,等fn执行完 ，再将this. _commiting = commiting</p><p><img src="http://wx4.sinaimg.cn/mw690/005N9IKrly1fyw42lxa9lj30t806cjrv.jpg" alt></p></li><li><p>那么这个commiting和 严格模式的strict:true 设置有什么关系</p><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fyw4ccbyewj312c067aam.jpg" alt></p></li><li><p>enableStrictMode() 干了什么  ?   </p><blockquote><p>在 enableStrictMode 函数内部，调用了 $watch 函数来观察 state的变化。当state变化时，就会调用 assert 函数，判断 store. _commiting( 上边的 this.committing） 的值，如果不为 true，就会报出异常： </p></blockquote><p><img src="http://wx3.sinaimg.cn/mw690/005N9IKrly1fyw4gdofhmj311408i753.jpg" alt></p></li><li><p>所以通过外部直接修改state，则没有执行 commit 函数，也就没有执行 <em>withCommit 函数，进而 this.</em> _ withCommitting 的值 不为 true，故当执行 enableStrictMode 时，则会执行 assert 函数，因为_withCommitting不为true，则报出异常了。</p></li></ul></li></ul></li><li><h4 id="getters-：Vuex内部也需要-computed这个功能-，比如将数据格式化"><a href="#getters-：Vuex内部也需要-computed这个功能-，比如将数据格式化" class="headerlink" title="getters  ：Vuex内部也需要 computed这个功能 ，比如将数据格式化"></a>getters  ：Vuex内部也需要 computed这个功能 ，比如将数据格式化</h4><blockquote><p>有时候我们需要从store中的state中派生出一些状态  ，可以理解为vuex中数据的computed功能</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------store.js</span></span><br><span class="line">getters:&#123;</span><br><span class="line">    money:<span class="function"><span class="params">state</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;state.count*<span class="number">1000</span>&#125;</span>`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------.vue 文件中 </span></span><br><span class="line">computed:&#123;</span><br><span class="line">    money()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.money</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Action-修改数据"><a href="#Action-修改数据" class="headerlink" title="Action :修改数据"></a>Action :修改数据</h4><blockquote><p>但是Mutations必须是同步的，Action是异步的Mutation，配合dispatch使用，定义上是一个异步的任务 ，大部分的任务 包括网络请求，网络数据的获取、文件的读取全部是异步的使用dispatch</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------.vue文件中 </span></span><br><span class="line"> created()&#123;</span><br><span class="line"> <span class="comment">// setTimeout(()=&gt;&#123;</span></span><br><span class="line"> <span class="comment">//     // this.$store.state.count++</span></span><br><span class="line"> <span class="comment">// &#125;,2000)</span></span><br><span class="line">     <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>)  <span class="comment">//在incrementAsync内部我们再去执行我们的异步操作</span></span><br><span class="line">     <span class="keyword">this</span>.$store.dispatch(<span class="string">'incrementAsync'</span>,&#123; <span class="comment">//还可以加参数</span></span><br><span class="line">         num:<span class="number">10</span></span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--------------store.js</span></span><br><span class="line">mutations:&#123;</span><br><span class="line">    increment(state,args)&#123;</span><br><span class="line">        state.count+= args.num || <span class="number">1</span>  <span class="comment">//加参数后的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions:&#123;</span><br><span class="line">    incrementAsync(store,args)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            store.commit(<span class="string">'increment'</span>,args);<span class="comment">//在去执行Mutations的任务，args参数</span></span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h4><blockquote><p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会使得代码冗余和重复</p><p>为了解决这个问题使用mapState辅助函数帮助我们生成计算属性 </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    ...  <span class="comment">//还有一堆的属性  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">        count:<span class="function"><span class="params">state</span>=&gt;</span>state.count</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// count()&#123;</span></span><br><span class="line">    <span class="comment">//     return this.$store.state.count</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h4><blockquote><p>和mapState类似 ，把actions方法映射进来</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    <span class="comment">// this.$store.dispatch('incrementAsync',&#123; //还可以加参数</span></span><br><span class="line">    <span class="comment">//     num:10</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="keyword">this</span>.incrementAsync(&#123;  <span class="comment">//直接使用这个更优雅 、更像组件内部的代码</span></span><br><span class="line">        num:<span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">     ...mapActions([<span class="string">"incrementAsync"</span>])</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h4><blockquote><p>聪明的你也一定和我一样想到了mapMutations</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.increment(&#123;<span class="attr">num</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"> methods:&#123;</span><br><span class="line">     ...mapMutations([<span class="string">"increment"</span>])</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>State：用来存状态。在根实例中注册了store 后，用 <code>this.$store.state</code> 来访问。</p><p>Getters：从 state 上派生出来的状态。可以理解为基于 State 的计算属性。很多时候，不需要 Getters，直接用 State 即可。</p><p>Mutations：用来改变状态。需要注意的是，Mutations 里的修改状态的操作必须是同步的。在根实例中注册了 store 后， 可以用 <code>this.$store.commit(&#39;xxx&#39;, data)</code> 来通知 Mutations 来改状态。</p><p>Actions：通过调用 Mutations 来改状态。Actions 可以包含异步操作。在根实例中注册了 store 后， 可以用 <code>this.$store.dispatch(&#39;xxx&#39;, data)</code> 来存触发 Action。</p></li><li><h4 id="Vuex完整数据流程"><a href="#Vuex完整数据流程" class="headerlink" title="Vuex完整数据流程"></a>Vuex完整数据流程</h4><p><img src="http://wx2.sinaimg.cn/mw690/005N9IKrly1fyw25cxe0gj30jg0fat8p.jpg" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vuex数据管理&quot;&gt;&lt;a href=&quot;#Vuex数据管理&quot; class=&quot;headerlink&quot; title=&quot;Vuex数据管理&quot;&gt;&lt;/a&gt;Vuex数据管理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何理解数据管理?&lt;/p&gt;
&lt;p&gt;这个Vuex就是vue中的数据管
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="vuex数据流" scheme="http://yoursite.com/tags/vuex%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>vue组件化设计思想</title>
    <link href="http://yoursite.com/2019/01/08/vue02/"/>
    <id>http://yoursite.com/2019/01/08/vue02/</id>
    <published>2019-01-08T02:40:42.000Z</published>
    <updated>2019-01-14T02:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现在很多UI库都有很多的好用的组件库，那这写组件的设计原理也必须知道，今天实现一下自定义form表单组件</p></blockquote><p>组件设计思想 :3个点</p><ol><li>属性 ：设计任何组件都需要传递一个属性</li><li>事件：组件内部对外通知的机制</li><li>组件可以扩展：组件内部不能写死，比如弹窗，不能只放按钮和文本，应该是用户想放什么放什么  ，slot插槽，需要分层  。</li></ol><h3 id="组件化设计思想实现"><a href="#组件化设计思想实现" class="headerlink" title="组件化设计思想实现"></a>组件化设计思想实现</h3><ol><li><h5 id="采坑-："><a href="#采坑-：" class="headerlink" title="采坑  ："></a>采坑  ：</h5><ul><li><p>v-model 双向绑定表单元素的数据：实质是绑定了value、checked、selected属性</p></li><li><p>父组件向子组件传递数据 ， 可以使用 :name 进行传递 ，也可以直接绑定属性  target=”yuhior”,那么这样传递的就是yuhior的值   不是变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot; target=&quot;yuhior&quot; &gt;&lt;/Cart&gt; </span><br><span class="line">&lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>父组件是使用这个子组件的组件 ，而不是template里嵌套子元素的是父组件，比如说这里KInput、FormItem、KForm的父组件都是App.vue   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--App.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;k-form :model=&quot;ruleForm&quot; :rules=&quot; rules&quot;&gt;</span><br><span class="line">      &lt;form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;   //父组件这是   *****理解错误 </span><br><span class="line">        &lt;k-input v-model=&quot;ruleForm.name&quot; name=&quot;name&quot;&gt;&lt;/k-input&gt;  //开始我以为子组件</span><br><span class="line">      &lt;/form-item&gt;</span><br><span class="line">      &lt;form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;</span><br><span class="line">        &lt;k-input v-model=&quot;ruleForm.age&quot; name=&quot;age&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">      &lt;/form-item&gt;</span><br><span class="line">    &lt;/k-form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import KForm from &apos;./components/Form&apos;;</span><br><span class="line">  import FormItem from &apos;./components/FormItem&apos;;</span><br><span class="line">  import KInput from &apos;./components/KInput&apos;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;app&apos;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      KForm,</span><br><span class="line">      FormItem,</span><br><span class="line">      KInput</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">      return&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>v-model 是一个特殊的属性绑定，相当于绑定了:value和@input两件事情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</span><br><span class="line">&lt;custom-input </span><br><span class="line">        :value=&quot;searchText&quot;</span><br><span class="line">        @input=&quot;searchTex=$event&quot;</span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="form表单验证的设计实现"><a href="#form表单验证的设计实现" class="headerlink" title="form表单验证的设计实现"></a>form表单验证的设计实现</h5><blockquote><p>表单组件进行分层：</p><p>​    KForm组件：负责接收自定义的规则</p><p>​    KFormItem：负责显示错误信息也就是规则的验证</p><p>​    KFromInput：负责数据的双向绑定</p></blockquote><ul><li><p>子组件向父组件传递数据，通知父组件组件内部变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;</span><br><span class="line">        开课吧</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleClick(event)&#123;</span><br><span class="line">                this.$emit(&apos;toMessage&apos;,event);</span><br><span class="line">            &#125;,   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 父组件接收</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;k-input v-on:toMessage=&quot;toFuzhi&quot;&gt;&lt;/k-input&gt;  //toMessage 是子组件那个出发事件</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">             toFuzhi(msg)&#123;</span><br><span class="line"> this.msg = msg  //进行父组件的复制</span><br><span class="line">            &#125;,  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>先看看平常使用:  和lelement类似 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;k-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">        &lt;k-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">            &lt;k-input v-model=&quot;ruleForm.name&quot; name=&quot;name&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">        &lt;/k-form-item&gt;</span><br><span class="line">        &lt;k-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;</span><br><span class="line">            &lt;k-input v-model=&quot;ruleForm.age&quot; name=&quot;age&quot;&gt;&lt;/k-input&gt;</span><br><span class="line">        &lt;/k-form-item&gt;</span><br><span class="line">    &lt;/k-form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import KForm from &apos;./components/KForm&apos;;</span><br><span class="line">    import KFormItem from &apos;./components/KFromItem&apos;;</span><br><span class="line">    import KInput from &apos;./components/KInput&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &apos;app&apos;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            KForm,</span><br><span class="line">            KFormItem,</span><br><span class="line">            KInput</span><br><span class="line">        &#125;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                ruleForm:&#123;</span><br><span class="line">                    name:&apos;&apos;,</span><br><span class="line">                    age:&apos;&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                rules: &#123;</span><br><span class="line">                    name:&#123;required: true, message: &apos;用户名不能为空！&apos;&#125;,</span><br><span class="line">                    age: &#123;required: true, message: &apos;年龄不能为空！&apos;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>KFormInput  实现： 需要注意 理解 this.$emit 传值的时候，因为 父组件 v-model 绑定了:value和@input两件事情  ，所以 使用的时候直接 v-model =“ruleForm.age”  就相当于  @input = ‘’ ’‘ 所以也就接收到了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!--实现v-model--&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            :value=&quot;inputText&quot;</span><br><span class="line">            @input=&quot;handleInput&quot;</span><br><span class="line">            @blur=&quot;handleBlur&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;KInput&quot;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            value:&#123;</span><br><span class="line">                type:String,</span><br><span class="line">                default:&apos;&apos;,</span><br><span class="line">                require: true</span><br><span class="line">            &#125;,</span><br><span class="line">            name:&#123;</span><br><span class="line">                type:String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                inputText:this.value  // * 双向输入的输入-&gt;父元素传递过来的</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleInput(e) &#123;</span><br><span class="line">                let value = e.target.value;  // props 是单向数据流传递数据，所以修改值之后，props的值不变，父元素的值不改变</span><br><span class="line">                this.inputText = value;   // 当输入框输入值的时候，获取输入框的值</span><br><span class="line">                // * 双向数据的输出-&gt; 通知父元素进行回流绑定</span><br><span class="line">                this.$emit(&apos;input&apos;,value);  // 子组件向父组件传递数据 使用this.$emit(&apos;input&apos;) input事件触发  父组件使用@input接收</span><br><span class="line">                this.$bus.$emit(&apos;KFormItem&apos;, value); //将值通过总线机制，实现KInput和KFormItem不相关的组件的数据传递，传递给KFromItem值，它进行验证</span><br><span class="line">            &#125;,</span><br><span class="line">            handleBlur()&#123; //失去焦点是进行验证</span><br><span class="line">                let value = this.inputText;</span><br><span class="line">                this.$bus.$emit(&apos;KFormItem&apos;,value,);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>KFormItem 实现  ：</p><ol><li><p>我们接收到KInput发送过来的数据 ， 然后进行 验证</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//----------KFromItem接收</span></span><br><span class="line">created() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$bus.$on(<span class="string">'KFormItem'</span>, (value) =&gt; &#123;  <span class="comment">//接收KInput组件传递过来的值 进行调用validate方法进行验证</span></span><br><span class="line">          <span class="keyword">this</span>.validate(value);  </span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>需要验证 就需要 获取验证的规则 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------KForm发送数据实例  </span></span><br><span class="line">provide()&#123;  </span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">     kform:<span class="keyword">this</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"><span class="comment">//-----------KFormItem接收</span></span><br><span class="line">inject:[<span class="string">'kform'</span>],  <span class="comment">//  2.接收KForm车通过  provide传递过来的 组件实例 这样才能获取到规则</span></span><br><span class="line"><span class="comment">//-----------获取规则</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    getRules()&#123; <span class="comment">//获取规则的方法</span></span><br><span class="line">        <span class="keyword">let</span> formRules = <span class="keyword">this</span>.kform.rules[<span class="keyword">this</span>.prop];  <span class="comment">//找到对应的 rules.prop的值</span></span><br><span class="line">        <span class="keyword">return</span> formRules;</span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取了规则 就需要写 校验方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">validate(obj)&#123;</span><br><span class="line">    <span class="comment">//1.验证我需要获取验证规则 ,也就是使用组件使用时传递进来的规则</span></span><br><span class="line">    <span class="keyword">const</span> rule = <span class="keyword">this</span>.getRules(); <span class="comment">//3.调用获取rules</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.kform.model[<span class="keyword">this</span>.prop]; <span class="comment">//4.由于在KInput组件中我们已经将输入框的变化值使用this.$bus.$emit通知给父组件了，所以这样获取输入框的值</span></span><br><span class="line">    <span class="keyword">if</span> (rule.required&amp;&amp;!value)&#123;  <span class="comment">//5.进行验证 ，require为true ，!value为真(value的值为空)就说明验证未通过</span></span><br><span class="line">        <span class="keyword">this</span>.validateStatus = <span class="string">'error'</span>;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = rule.message</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                       <span class="comment">//6.验证通过</span></span><br><span class="line">        <span class="keyword">this</span>.validateStatus = <span class="string">'stating'</span>  <span class="comment">//验证状态为通过状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>KForm实现就简单了：给一个槽口 让KFormItem来占用就行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;!--子元素的插口--&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;KForm&quot;,</span><br><span class="line">        provide()&#123;   //给KFromItem传递规则 数据</span><br><span class="line">            return &#123;</span><br><span class="line">                kform:this</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // provide:&#123;</span><br><span class="line">        //     kform:this ;   也可以使用这种方式进行数据传递  ，但是我们现在需要返回this实例 所以需要使用provide:function()&#123;&#125;形式 但是如果返回变量就可以直接返回</span><br><span class="line">        // &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            model:&#123;</span><br><span class="line">                type:Object</span><br><span class="line">            &#125;,</span><br><span class="line">            rules:&#123;</span><br><span class="line">                type:Object</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>完成之后发现 不管输入哪一个输入框 都验证所有的验证框都响应，进行验证  </p><blockquote><p>这是由于 我们再KInput.vue中使用 的$emit 和$.on都是全局的，所以父组件接收也就是@input =“ ”的时候都接收到了变化，也就是多个KForm监听@input事件  ，所以多个验证都响应 ，</p><p>那么我们就判断一下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------在KFormInput的$bus.$emit 发送值的时候不仅仅发送一个value ，我们发送一个对象  </span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'KFormItem'</span>,&#123;</span><br><span class="line">        value,</span><br><span class="line">        name:<span class="keyword">this</span>.name</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// --------在KFormItem验证中判断一下，如果发送过来的name和这个prop不相等，说明不是当前输入的input</span></span><br><span class="line">    <span class="keyword">if</span> (obj.name!==<span class="keyword">this</span>.prop) &#123;  </span><br><span class="line">        <span class="keyword">return</span>    <span class="comment">//别的prop的 如果不是这个name则直接返回</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>规则扩展</p><ul><li><p>但是如果我们想有多个验证规则怎么办 ？如下 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">     name: [  <span class="comment">//如果有多个校验项 ,则验证需要修改</span></span><br><span class="line">         &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'用户名不能为空！'</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">minLength</span>: <span class="number">3</span>, <span class="attr">message</span>: <span class="string">"用户名长度要大于3"</span>&#125;,</span><br><span class="line">         &#123;<span class="attr">maxLength</span>: <span class="number">10</span>, <span class="attr">message</span>: <span class="string">"用户名长度要小于10"</span>&#125;,</span><br><span class="line">     ],</span><br><span class="line">         age: &#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">'年龄不能为空！'</span>&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>那就在验证里边加判断被！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.如果验证规则有多个，那就需要判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">    value.forEach(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rule.required &amp;&amp; !value)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rule.mixLength &amp;&amp; value.length&lt;rule.mixLength)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>[源码]: </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;现在很多UI库都有很多的好用的组件库，那这写组件的设计原理也必须知道，今天实现一下自定义form表单组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组件设计思想 :3个点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性 ：设计任何组件都需要传递一个属性&lt;/li&gt;

      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="自定义form表单验证组件" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Vue简单数据传递、模拟数据、数据持久化</title>
    <link href="http://yoursite.com/2019/01/02/vue-begin/"/>
    <id>http://yoursite.com/2019/01/02/vue-begin/</id>
    <published>2019-01-02T05:25:54.000Z</published>
    <updated>2019-01-02T07:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的大事应该就是尤雨溪要推出vue3.0了，2.0还没学完3.0又出来了。真的技术更新速度太快了，感觉跟不上了，不过话又说回来了不学怎么能体现出自己的价值，学吧！，先分享一下vue2.5+的基础。</p></blockquote><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ol><li><p>开始使用</p><ul><li><p>引入组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Cart from &apos;./components/Cart&apos;</span><br></pre></td></tr></table></figure></li><li><p>注册组件 ，使用components进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cart&gt; &lt;/Cart&gt;  使用Cart来引用组件</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组件数据传递</p><ul><li><p>父子关系之父传子</p><ul><li><p>父组件:     使用:name这种形式进行数据的传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot;&gt;&lt;/Cart&gt; &lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件：使用props进行接收 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">        props:&#123;</span><br><span class="line">            name:&#123;   </span><br><span class="line">                type:String,  //类型是string类型</span><br><span class="line">                required:true //数据必须传递</span><br><span class="line">            &#125;,</span><br><span class="line">            cart:&#123;</span><br><span class="line">                type: Array  //数组类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>父子关系之子传父</p><ul><li><p>子组件：我们可以调用内建的 <a href="https://cn.vuejs.org/v2/api/#vm-emit" target="_blank" rel="noopener"><strong>$emit</strong> 方法</a>并传入事件的名字，来向父级组件触发一个事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;!--进行传出一个值--&gt;</span><br><span class="line">&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;, 0.1)&quot;&gt; </span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>父组件: 监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;!--或者如果这个事件处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法--&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-on:enlarge-text=&quot;onEnlargeText&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">            this.postFontSize += enlargeAmount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>不相关的两个组件的数据传递</p><blockquote><p>vue每个实例都有订阅/发布模式的实现，使用$on和￥emit来传递数据</p></blockquote><ul><li><p>父组件进行广播数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;li class=&quot;cart-list&quot; v-for=&quot;(item, index) in goods&quot; :key=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;addCart(index)&quot; &gt;添加购物车&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    methods: &#123;</span><br><span class="line">            addCart(i)&#123;</span><br><span class="line">                const good = this.goods[i];</span><br><span class="line">                // 触发一个事件  发送</span><br><span class="line">                this.$bus.$emit(&apos;addCart&apos;, good) </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件监听时间进行接收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">     data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.$bus.$on(&apos;addCart&apos;, good=&gt;&#123; //接收到数据</span><br><span class="line">                const ret = this.cart.find(v=&gt;v.text===good.text);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="样式和class"><a href="#样式和class" class="headerlink" title="样式和class"></a>样式和class</h3><ol><li><p>样式 ：内联样式 v-bind:style ,可以简写为:style</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :style=&quot;&#123;color:c.active?&apos;red&apos;:&apos;black&apos;&#125;&quot;&gt;</span><br><span class="line">&#123;&#123;i&#125;&#125;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure></li><li><p>class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :class=&quot;&#123;yellow_active:c.active&#125;&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    tr.yellow_active&#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol><li><p>使用computed字段，可以进行富足逻辑的计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;td colspan=&quot;2&quot;&gt;&#123;&#123;activeCount&#125;&#125;/&#123;&#123;count&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;total&#125;&#125;&lt;/td&gt;  &lt;!-- 直接用 不用写total（）--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;    //虽然 也可以使用methods的方法实现 ，但是毕竟computed有它的价值，且再使用时不用写方法之后的括号（）</span><br><span class="line">    data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">       computed: &#123;</span><br><span class="line">            total() &#123;</span><br><span class="line">                return this.cart.reduce((sum,v)=&gt;&#123;</span><br><span class="line">                    if (v.active)&#123;</span><br><span class="line">                        return sum+v.price*v.count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return sum</span><br><span class="line">                &#125;,0)</span><br><span class="line">                // let num= 0;</span><br><span class="line">                // this.cart.forEach(v=&gt;&#123;</span><br><span class="line">                //     if (v.active)&#123;</span><br><span class="line">                //         num += v.price * v.count</span><br><span class="line">                //     &#125;</span><br><span class="line">                // &#125;);</span><br><span class="line">                // return num</span><br><span class="line">            &#125;,</span><br><span class="line">            count() &#123;  //购物车的所有商品条数</span><br><span class="line">                return this.cart.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            activeCount()&#123;  //选中的商品条数</span><br><span class="line">                return this.cart.filter(v=&gt;v.active).length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="mock数据"><a href="#mock数据" class="headerlink" title="mock数据"></a>mock数据</h3><blockquote><p>mock数据也就是模拟数据，进行前后端分离</p><p>简单的mock，使用自带的webpack-dev-serve即可实现，新建vue.config.js扩展webpack设置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">      devServer:&#123;</span><br><span class="line">          before(app) &#123;</span><br><span class="line">              app.get(<span class="string">'/api/goods'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">                  res.json(&#123;</span><br><span class="line">                      list:[</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"百万年薪架构师"</span>,<span class="attr">price</span>:<span class="number">100</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"web全栈架构师"</span>,<span class="attr">price</span>:<span class="number">80</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"Python爬虫"</span>,<span class="attr">price</span>:<span class="number">70</span>&#125;,</span><br><span class="line">                          &#123;<span class="attr">text</span>:<span class="string">"Java架构师"</span>,<span class="attr">price</span>:<span class="number">90</span>&#125;</span><br><span class="line">                      ]</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用axios进行请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;  <span class="comment">//需要下载axios模块</span></span><br><span class="line">created() &#123;</span><br><span class="line">    axios.get(<span class="string">'/api/goods'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goods = res.data.list;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><blockquote><p>对于我们来说购物车的数据不能每次刷新都消失，所以我们需要对数据进行数据的缓存，也就是数据的持久化</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义方法 setLocal方法</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    setLocal()&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">'cart'</span>,<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.cart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听数据变化</span></span><br><span class="line">watch:&#123;</span><br><span class="line">    cart:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setLocal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//创建完成后获取本地存储的数据</span></span><br><span class="line">created()&#123;</span><br><span class="line">    <span class="keyword">this</span>.cart = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'cart'</span>))||[];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p> 循环监听</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    cart:&#123;</span><br><span class="line">        handler() &#123;</span><br><span class="line">            <span class="keyword">this</span>.setLocal();</span><br><span class="line">        &#125;,</span><br><span class="line">            deep:<span class="literal">true</span>, <span class="comment">//深度监听</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近的大事应该就是尤雨溪要推出vue3.0了，2.0还没学完3.0又出来了。真的技术更新速度太快了，感觉跟不上了，不过话又说回来了不学怎么能体现出自己的价值，学吧！，先分享一下vue2.5+的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="父子组件数据传递" scheme="http://yoursite.com/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    
      <category term="Vue模拟数据" scheme="http://yoursite.com/tags/Vue%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="简单数据的持久化" scheme="http://yoursite.com/tags/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>vue2.5+ 之基础入门</title>
    <link href="http://yoursite.com/2019/01/01/vue01/"/>
    <id>http://yoursite.com/2019/01/01/vue01/</id>
    <published>2019-01-01T02:22:36.000Z</published>
    <updated>2019-01-14T02:40:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单的记录一下最近重学vue的过程</p></blockquote><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ol><li><p>安装vue-cli3   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install - g @vue/cli </span><br><span class="line">npm install - g @vue/cli-service-global</span><br></pre></td></tr></table></figure></li><li><p>新建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-buy   vue-buy是项目名称</span><br></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure></li></ol><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><ol><li><p>vue单文件组件 .vue文件 </p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>   <span class="comment">&lt;!--模板里边只能有一个root 也就是一个根--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">export default &#123;</span><br><span class="line">name:"app"  //这个是组件的名字</span><br><span class="line">data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ol><li><p>开始使用</p><ul><li><p>引入组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Cart from &apos;./components/Cart&apos;</span><br></pre></td></tr></table></figure></li><li><p>注册组件 ，使用components进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cart&gt; &lt;/Cart&gt;  使用Cart来引用组件</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组件数据传递</p><ul><li><p>父子关系的组件的数据传递</p><ul><li><p>父组件:     使用:name这种形式进行数据的传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Cart :name=&quot;name&quot; :cart=&quot;cart&quot;&gt;&lt;/Cart&gt; &lt;!--使用:name这种形式进行数据的--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Cart from &apos;./components/Cart&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&apos;app&apos;, //组件的名字</span><br><span class="line">    components:&#123;</span><br><span class="line">      Cart</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            name:&apos;开课吧&apos;,</span><br><span class="line">            cart:[]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件：使用props进行接收 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">        props:&#123;</span><br><span class="line">            name:&#123;   </span><br><span class="line">                type:String,  //类型是string类型</span><br><span class="line">                required:true //数据必须传递</span><br><span class="line">            &#125;,</span><br><span class="line">            cart:&#123;</span><br><span class="line">                type: Array  //数组类型</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>任意两个组件，使用总线机制进行传递</p><blockquote><p>vue每个实例都有订阅/发布模式的实现，使用$on和￥emit来传递数据</p></blockquote><ul><li><p>父组件进行广播数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;li class=&quot;cart-list&quot; v-for=&quot;(item, index) in goods&quot; :key=&quot;item.text&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;addCart(index)&quot; &gt;添加购物车&lt;/button&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">    methods: &#123;</span><br><span class="line">            addCart(i)&#123;</span><br><span class="line">                const good = this.goods[i];</span><br><span class="line">                // 触发一个事件  发送</span><br><span class="line">                this.$bus.$emit(&apos;addCart&apos;, good) </span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件监听时间进行接收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;  // 可以使用props进行数据验证</span><br><span class="line">     data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            this.$bus.$on(&apos;addCart&apos;, good=&gt;&#123; //接收到数据</span><br><span class="line">                const ret = this.cart.find(v=&gt;v.text===good.text);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="样式和class"><a href="#样式和class" class="headerlink" title="样式和class"></a>样式和class</h3><ol><li><p>样式 ：内联样式 v-bind:style ,可以简写为:style</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :style=&quot;&#123;color:c.active?&apos;red&apos;:&apos;black&apos;&#125;&quot;&gt;</span><br><span class="line">&#123;&#123;i&#125;&#125;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure></li><li><p>class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-for=&quot;(c,i) in cart&quot; :key=&quot;c.text&quot; :class=&quot;&#123;yellow_active:c.active&#125;&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    tr.yellow_active&#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">        color: orange;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol><li><p>使用computed字段，可以进行富足逻辑的计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;td colspan=&quot;2&quot;&gt;&#123;&#123;activeCount&#125;&#125;/&#123;&#123;count&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td colspan=&quot;2&quot;&gt;&#123;&#123;total&#125;&#125;&lt;/td&gt;  &lt;!-- 直接用 不用写total（）--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;    //虽然 也可以使用methods的方法实现 ，但是毕竟computed有它的价值，且再使用时不用写方法之后的括号（）</span><br><span class="line">    data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                cart:[]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">       computed: &#123;</span><br><span class="line">            total() &#123;</span><br><span class="line">                return this.cart.reduce((sum,v)=&gt;&#123;</span><br><span class="line">                    if (v.active)&#123;</span><br><span class="line">                        return sum+v.price*v.count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    return sum</span><br><span class="line">                &#125;,0)</span><br><span class="line">                // let num= 0;</span><br><span class="line">                // this.cart.forEach(v=&gt;&#123;</span><br><span class="line">                //     if (v.active)&#123;</span><br><span class="line">                //         num += v.price * v.count</span><br><span class="line">                //     &#125;</span><br><span class="line">                // &#125;);</span><br><span class="line">                // return num</span><br><span class="line">            &#125;,</span><br><span class="line">            count() &#123;  //购物车的所有商品条数</span><br><span class="line">                return this.cart.length;</span><br><span class="line">            &#125;,</span><br><span class="line">            activeCount()&#123;  //选中的商品条数</span><br><span class="line">                return this.cart.filter(v=&gt;v.active).length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单的记录一下最近重学vue的过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装vue-cli
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="脚手架安装" scheme="http://yoursite.com/tags/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    
      <category term="组件间的数据传递" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>前端求生之路</title>
    <link href="http://yoursite.com/2018/12/21/go/"/>
    <id>http://yoursite.com/2018/12/21/go/</id>
    <published>2018-12-21T06:34:59.000Z</published>
    <updated>2018-12-21T06:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近忙着加班学习  ，等哪天把学习笔记分享一下。</p></blockquote><p>根据 <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">w3schools</a>   网上的文章讲解：</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul><li>GET请求在浏览器回退时候是无害的，而POST请求会再一次提交请求的。</li><li>GET请求产生的URL地址可以被Bookmark(书签)，而POST不可以。</li><li>GET请求会被浏览器主动缓存，而POST请求不会，除非手动设置。</li><li>GET请求只能进行URL编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整的保留在浏览器历史记录里，而POST请求中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST请求的长度限制要远大于GET请求的参数长度。</li><li>对参数的数据类型，GET请求只接受字符串类型，而POST请求没有限制。</li><li>GET请求比POST请求更不安全，因为参数暴露在URL上，不能用来传递敏感信息。</li><li>GET请求参数通过URL传递，POST请求参数放在Request body中。</li></ul><p>但是，实际上GET请求和POST请求本质上是没有区别的。GET请求和POST请求是HTTP协议中的两种发送请求的方法。而HTTP是基于TCP/IP的关于数据在万维网中通信的协议。</p><p>HTTP的底层是TCP/IP。所以GET请求和POST请求的底层也是TCP/IP，即GET/POST都是TCP链接，GET和POST请求能做的事情是一样的。在理论上来说，可以给GET请求加上Request body，给POST请求带上URL参数。</p><p>那么，回到这个问题上，GET请求和POST请求的区别是什么？</p><h3 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h3><p>在万维网中，TCP就像是汽车，我们用TCP来运输数据，但是如果道路上都是一摸一样的汽车，那么这个路线看起来是一片混乱，送急件的汽车可能为前面装载货物的汽车拦堵在路上，整个交通系统一定会瘫痪的。</p><p>为了避免这种情况的发生，交通规则HTTP诞生了，HTTP给汽车运输设定了几种服务类型，例如GET、POST、PUT、DELETE、PATCH、OPTION等，HTTP规定，当执行GET请求的时候要给汽车贴上GET标签(设置method为GET)，并且要求把传送的数据放到车顶(URL)上以方便记录，如果是POST请求，就要在车上贴上POST标签(设置method为POST)，并把货物放到车厢(Request body)中。虽然我们可以在GET请求的时候往车厢里偷偷藏点货物，或是在POST请求的时候，在车顶放一些数据。HTTP只是一个行为准则，而TCP才是GET和POST的实现基本。</p><p>那么，为什么会有对参数的大小限制呢？</p><p>在万维网这个交通网络中，除了车辆，还有运输公司。不同的浏览器(发送HTTP请求)和服务器(接收HTTP请求)就是不同的运输公司。</p><p>虽然我们我们可以在车辆上装了无限的货物，但是运输公司对于装货和卸货也是要很大成本的。他们会限制单词运输量来控制风险，数据量过大对浏览器和服务器都是很大负担。大部分浏览器会限制URL长度在2K个字符，而服务器大部分最多处理 64K大小的URL。超出的部分是不会处理的。如果我们在GET请求中在request body藏了数据，不同的服务器处理的方式是不同的，有些会卸货读取数据，有些服务器直接就会忽略，所以，不建议GET请求的Request body中放数据。</p><p>所以，从这个角度来说：GET请求和POST请求本质都是TCP链接，并无差异，但是由于HTTP的规定和浏览器、服务器的限制，导致他们在应用过程里体现出不同。</p><p>除此以外，他们还有一个重大的区别：GET请求会产生一个TCP数据包，POST请求会产生两个TCP数据包。</p><p>对于GET请求，浏览器会把header和data一并发送出去，服务器响应200，返回数据。</p><p>对于POST请求，浏览器会先发送header，服务器响应100，浏览器再发送data，服务器响应200，返回数据。</p><p>换句话来，GET请求只需要汽车跑一趟就把货物送到了，POST请求需要跑两趟，第一趟过来先和服务器打一声招呼，“嗨，我等下要送一批货物过来，你们打开门迎接我一下”，然后再回头把货物送过去。</p><p>最后，为什么不能通过GET请求来替代POST请求？<br>GET请求与POST请求都有自己的语义，不能混用。<br>在网络环境良好的情况下，发一次包的时间和发两次包的时间差别基本可以忽略不计，而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器的POST请求会发送两次包，Firefox就只发送一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近忙着加班学习  ，等哪天把学习笔记分享一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据 &lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;w3scho
      
    
    </summary>
    
    
      <category term="HTTP扫盲" scheme="http://yoursite.com/tags/HTTP%E6%89%AB%E7%9B%B2/"/>
    
  </entry>
  
  <entry>
    <title>exports与module.exports区别</title>
    <link href="http://yoursite.com/2018/11/07/exports/"/>
    <id>http://yoursite.com/2018/11/07/exports/</id>
    <published>2018-11-07T07:54:21.000Z</published>
    <updated>2018-11-07T03:11:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实说起两者的区别也很简单 ，今天这个只是给自己和刚开始node的新手解释，大佬们不喜勿喷啊。</p></blockquote><h3 id="exports和module-exports区别"><a href="#exports和module-exports区别" class="headerlink" title="exports和module.exports区别"></a>exports和module.exports区别</h3><ul><li><p>解释之前先铺一个小例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;<span class="attr">name</span>:<span class="string">'lihua'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">b.name = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b= &#123;<span class="attr">name</span>:<span class="string">'lisi'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//结果</span><br><span class="line">&#123; name: &apos;lihua&apos; &#125;</span><br><span class="line">&#123; name: &apos;lihua&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;zhangsan&apos; &#125;</span><br><span class="line">&#123; name: &apos;lisi&apos; &#125;</span><br></pre></td></tr></table></figure><p>来分析一波吧！开始var了一个对象a，b是对a的引用。也就是说a和b此时指向同一块内存，当改变b.name时，还是指向的那块内存，改变了那块内存里的内容，所以a也发生了改变。当b被覆盖时（var b= {name:’lisi’}），b也就指向了一块新的内存，所以最后结果不同。</p></li><li><p>当一个node.js文件执行时 ，会创建一个module对象，同时module对象会创建一个exports属性，初始化的值是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果希望模块成为一个传统的模块实例，也就是 exports.xxx=xxx 这种情况下可以直接使用exports导出</p></li></ul><blockquote><p>这时exports.xxx就像开始例子中的直接改变b.name的情况，随着exports 的改变module.exports也改变</p></blockquote><ul><li><p>但是如果希望模块是一个特别的类型（我称它是覆盖式类型） ，引用时 直接就像下面这样，就必须使用module.exports了，不能只用exports。因为如果只是用exports就像开始例子中 var b= {name:’lisi’};b直接被覆盖，它此时指向就和module.exports不同了 。结果也就不同了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;rmbToDollar,dollarToRmb&#125; = <span class="built_in">require</span>(<span class="string">'./currency/currency'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rmbToDollar(<span class="number">6</span>));</span><br><span class="line"><span class="built_in">console</span>.log(dollarToRmb(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p>为甚么非要两者相同 ，因为module.exports才是真正的接口，exports只不过是它的一个辅助工具。require引用时最终返回调用的是module.exports而不是exports。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;其实说起两者的区别也很简单 ，今天这个只是给自己和刚开始node的新手解释，大佬们不喜勿喷啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;exports和module-exports区别&quot;&gt;&lt;a href=&quot;#exports和module
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="exports" scheme="http://yoursite.com/tags/exports/"/>
    
      <category term="module.exports" scheme="http://yoursite.com/tags/module-exports/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>node中请求静态文件（图片例子）</title>
    <link href="http://yoursite.com/2018/11/06/fs/"/>
    <id>http://yoursite.com/2018/11/06/fs/</id>
    <published>2018-11-06T02:32:45.000Z</published>
    <updated>2018-11-06T08:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>读node的API过程中发现了response的中一句</p><p>The response inherits from <a href="https://nodejs.org/api/http.html" target="_blank" rel="noopener">Stream</a>, and additionally implements the following:</p><p>（这个类实现了（而不是继承自）<a href="http://nodejs.cn/s/9JUnJ8" target="_blank" rel="noopener">可写流</a> 接口。 它是一个有以下事件的 [<code>EventEmitter</code>]：）</p></blockquote><ol><li><h3 id="来理解一下-fs-createReadStream-filePath-pipe-response"><a href="#来理解一下-fs-createReadStream-filePath-pipe-response" class="headerlink" title="来理解一下  fs.createReadStream( filePath).pipe(response);"></a>来理解一下  fs.createReadStream( filePath).pipe(response);</h3><ul><li>createReadStrem 是返回 : &lt;fs.ReadStream&gt;  详见<a href="http://nodejs.cn/s/YuDKX1" target="_blank" rel="noopener">可读流</a>。</li><li>response 当然就是响应</li><li>pipe是将两个数据流连接起来。</li></ul></li><li><p>这样就可以输出数据流了么？</p><ul><li>我们知道WriteStream （可写流是对数据要被写入的目的地的一种抽象。）</li><li>所有可写流的例子（包括fs的写入流）都实现了 stream.Writable类定义的接口。</li><li>也就是说可以输出数据流</li><li>而前言提到response 也实现了可写流接口 </li><li>那么fs.createReadStream 与response拼接响应，就可以输出了</li></ul></li><li><p>来个小例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> path =<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 从命令行参数获取root目录，默认是当前目录:</span></span><br><span class="line"><span class="keyword">var</span> root = path.resolve(process.argv[<span class="number">2</span>] || <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Static root dir: '</span> + root);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器:</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得URL的path，类似 '/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="comment">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span></span><br><span class="line">    <span class="keyword">var</span> filepath = path.join(root, pathname);</span><br><span class="line">    <span class="comment">// 获取文件状态:fs.stat() 来检查某个文件是否存在，stats 为 fs.Stats 对象，它提供了一个文件的信息</span></span><br><span class="line">    fs.stat(filepath, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; stats.isFile()) &#123;<span class="comment">//如果 fs.Stats对象表示一个普通文件，stats.isFile()则返回 true</span></span><br><span class="line">            <span class="comment">// 没有出错并且文件存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'200 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送200响应:</span></span><br><span class="line">            response.writeHead(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 将文件流导向response:</span></span><br><span class="line">            fs.createReadStream(filepath).pipe(response)；</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 出错了或者文件不存在:</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'404 '</span> + request.url);</span><br><span class="line">            <span class="comment">// 发送404响应:</span></span><br><span class="line">            response.writeHead(<span class="number">404</span>);</span><br><span class="line">            response.end(<span class="string">'404 Not Found'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;读node的API过程中发现了response的中一句&lt;/p&gt;
&lt;p&gt;The response inherits from &lt;a href=&quot;https://nodejs.org/api/http.html&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
      <category term="流" scheme="http://yoursite.com/tags/%E6%B5%81/"/>
    
  </entry>
  
</feed>
